<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog Posts on Gromit.Blog</title><link>https://gowoonsori.com/blog/</link><description>Recent content in Blog Posts on Gromit.Blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Wed, 27 Apr 2022 15:53:14 +0900</lastBuildDate><atom:link href="https://gowoonsori.com/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Red Black Tree</title><link>https://gowoonsori.com/blog/datastructure/red-black-tree/</link><pubDate>Fri, 23 Oct 2020 17:53:52 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/red-black-tree/</guid><description>BST (이진 탐색 트리)를 기반으로 둔 Tree. Tree의 Rebalancing 방법 중 하나로 balanced한 트리이다. 각 노드는 값(key)말고도 색을 갖고 있으며, 색은 레드 or 블랙 2종류이다. 1. Red Black Tree가 갖는 특성 Root Property : 루트(root)노드는 블랙(black)이다. External Property : 모든 외부 노드 (external node)는 블랙이다. Depth Property : 모든 단말 노드(leaf n</description></item><item><title>데이터 중심 애플리케이션 설계</title><link>https://gowoonsori.com/blog/books/designing-data-intensive-applications/</link><pubDate>Wed, 27 Apr 2022 15:53:14 +0900</pubDate><guid>https://gowoonsori.com/blog/books/designing-data-intensive-applications/</guid><description>이 책은 총 3부로 구성되어 1부에서는 근본 개념에 대해 설명하고 2부에서는 데이터를 분산 저장하기 위한 내용을, 3부에서는 한 데이터셋에서 다른 데이터셋을 파생하는 시스템애 대해 설명한다. 1장. 데이터 시스템의 기초 1) 신뢰성 잘못될 수 있는 일을 결함이라 부른다. 이 결함을 예측하고 대처할 수 있는 시스템을 내 결함성/탄력성을 가졌다고 말할 수 있다</description></item><item><title>Go in Action</title><link>https://gowoonsori.com/blog/books/go-in-action/</link><pubDate>Tue, 29 Mar 2022 22:22:01 +0900</pubDate><guid>https://gowoonsori.com/blog/books/go-in-action/</guid><description>저는 개인적으로 GoLang을 접한지는 꽤 되었습니다. 제가 Go를 학습할때는 인터넷을 통해 충분히 학습할 수 있었는 데, 키워드들이 많지 않았고 http://golang.site 에 대부분 필요한 내용은 설명되어있어 무리없이 학습할 수 있었습니다. 그런데 책을 구매하게 된 이유는 요즘 읽을 책이 마땅치 않았기도 하고, Go 책을 개인적으로 소장하고 싶어 구매해본 책입니다. 책이 나온</description></item><item><title>디지털 트랜스포메이션 엔진(ACCELERATE)</title><link>https://gowoonsori.com/blog/books/accelerate/</link><pubDate>Wed, 23 Mar 2022 15:28:07 +0900</pubDate><guid>https://gowoonsori.com/blog/books/accelerate/</guid><description>제목부터 낯선 이 디지털 트랜스포메이션 엔진이라는 책은 Redit을 통해 처음 접하게 되었고, 책의 원제목은 ACCELERATE:The Science Of Lean Software and DevOps:Building and Scaling High Performing Techonology Oragnizations 이다. 이름만 들었을때는 책 내용이 굉장히 어려워 보인다. 하지만, 쪽수도 얼마 안되고 내용이 재미있어 굉장이 빨리 읽힌 책이었다. 책의 전체적인 내용은 설문조사와 연구를 통해 DevOps가 소프트웨어의 전달</description></item><item><title>가상면접 사례로 배우는 대규모 설계 기초</title><link>https://gowoonsori.com/blog/books/large-scale-system-design-learned-from-virtual-interviews/</link><pubDate>Mon, 21 Mar 2022 22:30:51 +0900</pubDate><guid>https://gowoonsori.com/blog/books/large-scale-system-design-learned-from-virtual-interviews/</guid><description>나는 얇은 책이거나 꼭 소장할 책이 아니라면 주로 알라딘 에서 ebook으로 책을 구매해서 읽는다.(전공 서적은 주로 너무 두꺼워 집에 둘 곳이 없다&amp;hellip;) 책을 구매한 날도 알라딘에 어떤 ebook이 등록되었나 보고 있었고, 이 책의 제목이 굉장히 흥미를 끌었고 바로 구매를 해버렸다. 처음 구매후, 11장 까지는 굉장히 재미있게 읽어가다가</description></item><item><title>Google Analytics 추가하기</title><link>https://gowoonsori.com/blog/projects/hugo/google-analytics/</link><pubDate>Mon, 07 Feb 2022 15:50:57 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/hugo/google-analytics/</guid><description>개인마다 선택한 Theme에 이미 구글 애널리틱스 삽입 코드가 포함되어 있어 config.toml 파일에 추적코드만 삽입하면 되는 경우가 대부분일 것이다. 이 부분은 선택한 theme 문서를 잘 확인해보고 만약에 없다면 아래와 같은 방법으로 추가해줄 수 있다. 1. Google Analytics 추적 코드 발급 구글 애널리틱스를 추가하기 위해서는 당연히 구글의 애널리틱스에 가입을 먼저 해야 한다. 가입을 하</description></item><item><title>Home Server 만들기</title><link>https://gowoonsori.com/blog/settings/home-server/</link><pubDate>Fri, 04 Feb 2022 09:51:40 +0900</pubDate><guid>https://gowoonsori.com/blog/settings/home-server/</guid><description>집 서버를 만들게 된 배경 집 컴퓨터를 교체하고 지인의 컴퓨터를 교체해주면서 부품들이 여럿 남게 되는 상황이 생겼는데, 그냥 버리기 아까워 컴퓨터를 한대 더 조립을 하게 되었다. 사양은 Intel(R) Celeron(R) CPU G3930 에 4G, 250Gb 이다. 컴퓨터를 조립 후 막상 사용할 곳이 없어 고민하던 중에 aws 프리티어도 끝났겠다 싶어 개발이나 테스트용으로 서버를 사용하면 좋을 것 같아 서버로 만들어보</description></item><item><title>도메인 주도 설계로 시작하는 마이크로 서비스 개발</title><link>https://gowoonsori.com/blog/books/developing-ms-starting-with-ddd/</link><pubDate>Mon, 27 Dec 2021 11:41:53 +0900</pubDate><guid>https://gowoonsori.com/blog/books/developing-ms-starting-with-ddd/</guid><description>1. 마이크로서비스를 위한 조건 1) 업무 기능 중심의 팀 기술별로 팀이 나눠지게 되면 서비스 한개를 개발하는데 많은 의사소통이 필요하고 의사결정이 느려진다. 업무기능을 중심으로 다양한 기술을 가진 사람들이 하나의 팀이 되어 서비스를 만들어야 한다. 2) 폴리글랏 프로그래밍 각각의 서비스에 맞는 효율적인 방법론과 도구, 기술을 찾아 적용. 3) 개발 생명주기</description></item><item><title>CompletableFuture</title><link>https://gowoonsori.com/blog/java/completeablefuture/</link><pubDate>Wed, 08 Dec 2021 16:32:13 +0900</pubDate><guid>https://gowoonsori.com/blog/java/completeablefuture/</guid><description>1. Java에서의 Concurrent Concurrent 소프트웨어란? 동시에 여러 작업을 할 수 있는 소프트웨어 멀티 프로세싱 ( ProcessBuilder ) 멀티 스레딩 ( Thread/Runnable ) 1) 동시성(Concurrency) vs 병렬성(Parallelism) 동시성? 싱글코어에서 멀티 스레드를 동작시키기 위한 방식으로 멀티 태스킹을 위해 여러개 스레드가 번갈아가면서 실행. 한마디로 동시에 실행되는 것처럼</description></item><item><title>Date/Time</title><link>https://gowoonsori.com/blog/java/date-time/</link><pubDate>Wed, 08 Dec 2021 16:26:20 +0900</pubDate><guid>https://gowoonsori.com/blog/java/date-time/</guid><description>1. 등장 배경 1) 명확하지 않은 클래스 이름 날짜 클래스중 Date 는 시간과 TimeStamp 모두 표현할 수 있다. (사실상 TimeStamp) 시간 값이 에폭타임 이라 하여 세계 표준시(UTC)로 1970년 1월 1일 00시 00분 00초를 기준으로 현재까지 흐른 모든 시간을 초(sec)단위로 표현 하여 사람이 알아보기 어렵다. 2) Thread safe하지 않은 mutable한 속성 public static void main(String[] args) throws</description></item><item><title>Optional</title><link>https://gowoonsori.com/blog/java/optional/</link><pubDate>Wed, 08 Dec 2021 16:20:10 +0900</pubDate><guid>https://gowoonsori.com/blog/java/optional/</guid><description>Java 8에 새로 생긴 인터페이스로 라이브러리 메서드가 반환할 결과값이 없음을 명백하게 표현할 필요가 있는 곳에서 제한적으로 사용할 수 있는 메커니즘을 제공하기 위해 새로 생겨났다. Java api doc의 API 노트를 보면 다음과 같이 설명하고 있다. Optional은 주로 결과 없음을 나타낼 필요성이 명확하고 null을 사용하면 오류가 발생할 수 있는 메소드 반환</description></item><item><title>인터페이스</title><link>https://gowoonsori.com/blog/java/interface/</link><pubDate>Wed, 08 Dec 2021 16:17:41 +0900</pubDate><guid>https://gowoonsori.com/blog/java/interface/</guid><description>1. 인터페이스란? 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 유지보수를 용이하게 하기 위함 다형성? 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력 1) 추상클래스와 인터페이스 차이 추상메서드를 가짐으로써 다형성을 극대화하면서 어떤 역할을 구현하는 방법(객체들이 따라야 하는 책임의 집합을 서술한 것)이라는 공통</description></item><item><title>오브젝트: 코드로 이해하는 객체지향 설계</title><link>https://gowoonsori.com/blog/books/object/</link><pubDate>Fri, 12 Nov 2021 11:02:26 +0900</pubDate><guid>https://gowoonsori.com/blog/books/object/</guid><description>1. 객체지향 설계 설계란 코드를 배치하는 것이다. 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계 요구사항은 항상 변하기 마련이다. 2. 객체지향 프로그래밍 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴 이라고 한다. 자식 클래스가</description></item><item><title>Spring 요청처리 내부구조</title><link>https://gowoonsori.com/blog/spring/architecture/</link><pubDate>Thu, 11 Nov 2021 16:46:31 +0900</pubDate><guid>https://gowoonsori.com/blog/spring/architecture/</guid><description>내가 이해하고 나중에 보기 위해서 정리하는 스프링 요청 처리 구조 내부 구조 요약 1. Tomcat (Servlet Container) 톰캣은 WAS로써 미들웨어역할을 하지만 아파치의 일부분 기능을 서비스(httpd(웹서비스 데몬) native 모듈 포함)하고있어 Web Server역할도 수행할 수 있다. 톰캣의 메인 기능으로 서블릿 컨테이너역할인데 이는 서블릿의 라이플 사이클을 관리하며 Disp</description></item><item><title>Slice</title><link>https://gowoonsori.com/blog/golang/slice/</link><pubDate>Mon, 05 Jul 2021 22:11:57 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/slice/</guid><description>컴파일타임에 데이터 크기가 고정되어 런타임에 변경이 되지 않는 일반 배열과 달리 변경이 가능한 동적 배열 타입을 slice라고 한다. 정확하게 얘기하면 go에서 제공하는 배열을 가리키는 포인터 타입이다. 1. 선언 방법 var a []int //길이가 0인 slice fmt.Println(len(a)) //0 b := []int{1,2,3} //길이가 3인 slice fmt.Println(len(b)) //3 var c = []int{1, 5:2, 9:3} //길이가 10인 slice fmt.Println(c) //[1 0 0 0 0 2 0 0 0 3] 배열선언방</description></item><item><title>모듈과 패키지</title><link>https://gowoonsori.com/blog/golang/module-package/</link><pubDate>Wed, 09 Jun 2021 22:00:39 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/module-package/</guid><description>1. 모듈의 변천과정 Go 1.11 이전 : 모듈 존재 X Go 1.11 : 모듈이 소개되었지만 미완성 Go 1.13 : 모듈 완성 Go 1.16 : 모듈이 이제 기본이 되었다. 1) 모듈 모듈은 패키지의 모음 2) 패키지 패키지는 코드를 묶는 단위로 모든 코드는 반드시 패키지로 묶여야 한다. 우리가 흔히 부르는 프로그램은 다양한 관점에서 의미를 해석할수 있을 텐데 실핼파일 관점에서보면 실행시작 지점을 포</description></item><item><title>문자열</title><link>https://gowoonsori.com/blog/golang/string/</link><pubDate>Mon, 07 Jun 2021 22:02:17 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/string/</guid><description>문자의 집합(배열)이라는 의미이다. 기존의 문자는 ASCII코드로 1byte를 갖기 때문에 0~255로 총 255개의 문자를 표현할 수 있었는데 이 수로는 현재 존재하는 언어(문자)들을 모두 표시할 수 없기 때문에 더 큰 byte의 문자가 필요해졌다. 대표적으로 UTF-8이 있는데 이는 한 문자당 1~4byte를 갖고 UTF-16은 2by</description></item><item><title>최장 증가 수열</title><link>https://gowoonsori.com/blog/algorithms/longest-increasing-subsequence/</link><pubDate>Thu, 03 Jun 2021 23:06:55 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/longest-increasing-subsequence/</guid><description>주어진 수열에서 오름차순으로 정렬된 가장 긴 부분 수열이다. 예를 들어, 341256784134라는 수열에서 LIS는 345678 or 125678 이 된다. 1. 찾는 방법 LIS의 크기 구하는 방법은 dp와 이분탐색에 따라 방법이 나뉘며 경로 추적(trace) 방법은 두 방법 모두 인덱스를 가리키는 배열을 하나 추가하여, 탐색하면서 해당 값의 앞의 수열 인덱스를 저장하</description></item><item><title>Stack Queue</title><link>https://gowoonsori.com/blog/datastructure/stack-queue/</link><pubDate>Thu, 03 Jun 2021 23:02:30 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/stack-queue/</guid><description>1. 스택 Last In First Out으로 최근에 추가한 항목이 가장 먼저 제거되는 데이터 방식 1) 함수 pop() : 스택에서 가장 위에 있는 항목을 제거 push() : item하나를 스택의 가장 윗 부분에 추가 peek() : 스택의 가장 위에있는 항목을 제거없이 값만 반환 isEmpty() : 스택이 비었는지 검사 2) 사용 예 재귀 알고리즘 웹 방문기록 실행 취소 연결 list를 이용한 코드 예(C 언어) 2. 큐 First In First Ou</description></item><item><title>Heap</title><link>https://gowoonsori.com/blog/datastructure/heap/</link><pubDate>Thu, 03 Jun 2021 22:54:05 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/heap/</guid><description>Tree중 하나로 최대,최솟값을 찾아내는 연산을 빠르게 하기 위한 완전 이진 트리이다. (Complete Binary Tree ) 우선 순위를 무엇에 두냐에 따라 순서가 달라지기 때문에 자료가 들어온 시간을 우선순위로 놓는다고 하면 일반적인 큐도 우선순위 큐가 될 수 있다. 1. 최대 힙(Max Heap) 부모 노드의 key값이 자식 노드의 key값보다 크거나 같은 완전 이진 트리 c++을 이용한</description></item><item><title>Array와 List</title><link>https://gowoonsori.com/blog/datastructure/array-list/</link><pubDate>Thu, 03 Jun 2021 22:47:36 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/array-list/</guid><description>1. 배열 가장 기본적인 자료구조로써, 논리적 저장 순서와 물리적 저장 순서가 일치하고 인덱스를 통하여 원소에 접근이 가능하다. 대부분의 언어에서 [] 를 이용해서 배열을 제공한다. 2. 리스트 배열과 달리 원소들 간의 논리적인 순서로 연결되어 구성있고, 삽입과 삭제를 수행하기 위해서는 첫 원소부터 모두 search해야한다. 자료구조 Tree에 기본이</description></item><item><title>Graph</title><link>https://gowoonsori.com/blog/datastructure/graph/</link><pubDate>Thu, 03 Jun 2021 22:36:14 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/graph/</guid><description>연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조로 Tree도 그래프의 일종인데 그래프 중에서도 사이클이 허용되지 않는 그래프이다. 1. 개념 정점(vertex) / 노드(node) : 위치 간선(edge) / 링크(link) : 위치간의 관계 인접 정점 : 간선에 의해 직접 연결된 노드 차수 : 하나의 노드에 인접한 노드의 수 경로 길이 : 경로를</description></item><item><title>Splay Tree</title><link>https://gowoonsori.com/blog/datastructure/splay-tree/</link><pubDate>Thu, 03 Jun 2021 21:55:46 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/splay-tree/</guid><description>Splaying이라는 기법이 사용되며, 이는 특정 노드에 대해 접근을 하면, 이를 루트로 위치하도록 재배치 하는 기법의 트리 1. 특징 구현이 단순 많이 접근한 노드에 대해서 빠른 접근이 가능하다 접근 빈도가 불균등하거나 비 랜덤 패턴의 경우 O(lgn)보다 더 유리하다. AVL-Tree와 RB-Tree와 달리 추가 데이터 저장 필요 없다. 최악의 경</description></item><item><title>AA Tree</title><link>https://gowoonsori.com/blog/datastructure/aa-tree/</link><pubDate>Thu, 03 Jun 2021 20:36:30 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/aa-tree/</guid><description>RB-Tree를 응용한 트리로 RB-Tree의 많은 조건을 일부 제거하여 구현을 더 간단하게 만든 트리로 균형을 맞추기 위해 레벨의 개념을 사용한 트리이다. 부모와 레벨이 같은 자식 노드의 연결을 수평 링크라고 하며, 이 노드를 구분하기 위해 RED라는 개념을 이용한다. 1. 특징 왼쪽 자식은 RED가 될 수 없다. 연속으로 RED가 올 수 없다. (이중 RED</description></item><item><title>포인터</title><link>https://gowoonsori.com/blog/golang/pointer/</link><pubDate>Wed, 02 Jun 2021 22:06:54 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/pointer/</guid><description>메모리 주소를 값으로 갖는 데이터 타입 1. 선언 방법 var a int var p *int p = &amp;amp;a 메모리주소를 가리킬 데이터타입형에 *를 붙이면 해당 타입의 메모리주소를 담는 포인트형을 선언 할 수 있다. &amp;amp; 를 이용해서 변수의 메모리주소 시작값을 할당 할 수 있다. 메모리 주소 시작값은 하나의 값으로 일종의 숫자 값이다. 2. 사용 방법 var a int var p *int var b *int var c *int p = &amp;amp;a b = &amp;amp;a c =</description></item><item><title>Set</title><link>https://gowoonsori.com/blog/java/set/</link><pubDate>Tue, 01 Jun 2021 21:42:11 +0900</pubDate><guid>https://gowoonsori.com/blog/java/set/</guid><description>Set은 자바의 Collection중에 객체를 중복하지 않고 하나만 저장하는 자료구조로 List와 다르게 저장순서(index)를 따로 저장하지 않기 때문에 이를 통해 접근할 수 없다. Set interface 제공 메서드 메서드 리턴 값 설명 add(E e) boolean 객체 추가성공하면 true addAll(Collection c) boolean 컬렉션을 추가하면 데이터들을 Set에 맞게 저장 remove(Object o) boolean 객체 삭제 contains(Object o) boolean 객체가 포함되었</description></item><item><title>제어문</title><link>https://gowoonsori.com/blog/golang/control-statement/</link><pubDate>Tue, 01 Jun 2021 19:40:06 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/control-statement/</guid><description>1. if문 제어문 중에 하나로 다른 언어들과 사용목적은 동일하며 if~else if~else 를 똑같이 지원한다. 1) 선언 방법 score := 56 if score &amp;gt; 80 { fmt.Println(&amp;#34;A&amp;#34;) } else if(score &amp;gt; 50) { //소괄호로 감쌌지만 not Error fmt.Println(&amp;#34;B&amp;#34;) } else { fmt.Println(&amp;#34;C&amp;#34;) } if true { fmt.Println(&amp;#34;true&amp;#34;) //조건이 bool이면 success } if 1 { fmt.Println(&amp;#34;true&amp;#34;) //bool이 아니면 error } Java나 c처럼 **()**로 조건문을 감싸지 않고 바로 조건문을 작성하면 되고 Java처</description></item><item><title>구조체</title><link>https://gowoonsori.com/blog/golang/structure/</link><pubDate>Mon, 31 May 2021 22:01:25 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/structure/</guid><description>여러 필드를 묶어서 사용하는 타입으로 C의 structure와 비슷하며, go에서는 별도의 클래스를 키워드를 제공하지 않지만 구조체를 이용해서 클래스를 정의할 수 있다. 1. 선언 /* type 이름 sturct{ ... 필드명 } */ type School struct{ Name string CntTeacher int } type Student struct { school School Name string score float64 } //Student형 변수 선언 var student Student student.Name = &amp;#34;홍길동&amp;#34; student.score = 87.1 struct을</description></item><item><title>연산자</title><link>https://gowoonsori.com/blog/golang/operator/</link><pubDate>Fri, 28 May 2021 15:13:25 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/operator/</guid><description>1. 산술 연산자 구분 연산자 연산 피연산자 타입 사칙 연산과 나머지 + 덧셈 정수, 실수, 복소수, 문자열 - 뺄셈 정수, 실수, 복소수 * 곱셈 정수, 실수, 복소수 / 나눗셈 정수, 실수, 복소수 % 나머지 정수, 실수, 복소수 비트 연산 &amp;amp; AND 비트연산 정수 | OR비트 연산 정수 ^ XOR비트 연산 정수 &amp;amp;^ 비트 클리어 정수 시프트 연산 &amp;laquo; 왼쪽 시프트 정수 &amp;laquo; 양의 정수</description></item><item><title>Permutation(순열)</title><link>https://gowoonsori.com/blog/algorithms/permutation/</link><pubDate>Fri, 28 May 2021 10:25:08 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/permutation/</guid><description>1. next_permutation c++에는 algorithm헤더에 매개변수의 배열/iterator의 다음 순열을 적용시켜 바뀌었다면 true/false를 반환해주는 메서드가 존재해서 이를 do~while문으로 쉽게 순열문제를 해결할 수 있다. 하지만, 자바는 존재하지 않기 때문에 다음과 같이 구현할 수 있다. public boolean next_permutation(int[] arr){ //뒤에서부터 탐색해서 내림차순이 깨</description></item><item><title>List를 Array로 Array를 List로 변환</title><link>https://gowoonsori.com/blog/java/list-array/</link><pubDate>Thu, 27 May 2021 19:10:07 +0900</pubDate><guid>https://gowoonsori.com/blog/java/list-array/</guid><description>List와 Array간의 변환은 기본적으로 for문을 이용하여 하나하나 바꾸어주면 변환이 가능하다. 하지만 for이 아닌 stream API를 이용해서 더 간편하게 바꿀 수 있는 방법을 정리한다. 1. List에서 Array로 변환 1) List -&amp;gt; Object[] List&amp;lt;Integer&amp;gt; integerList = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;String&amp;gt; stringList = new ArrayList&amp;lt;&amp;gt;(); Integer[] integerArr = integerList.toArray(new Integer[integerList.size()]); String[] stringArr = stringList.toArray(new String[stringList.size()]); Object[] objectArr = integerList.toArray(); List에서 Wrapper객체배열로 바꾸는 것은 Li</description></item><item><title>상수</title><link>https://gowoonsori.com/blog/golang/constant/</link><pubDate>Wed, 26 May 2021 23:18:14 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/constant/</guid><description>상수는 Immutable(불변)한 특징을 갖으며 한 번 할당된 값을 변경할 수 없는 변수이다. const a int = 1 const b string = &amp;#34;hi&amp;#34; const d = 10 //자료형을 생략가능하다. f := 10 //이는 자동으로 var 형태의 변수로 선언이 되기 때문에 상수가 될 수 없다. var runTimeVar int = 1 const e = runTimeVar * 10 //runTimeVar는 런타임에 값이 할당되기 때문에 컴파일타임에 d의 값을 할</description></item><item><title>배열</title><link>https://gowoonsori.com/blog/golang/array/</link><pubDate>Wed, 26 May 2021 22:59:42 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/array/</guid><description>배열은 연속된 메모리에 저장된 자료구조로 다른 자료구조 중 Random Access가 가장빠르고 고정된 길이의 자료구조이다. 배열과 비슷한 자료구조로 go에는 slice가 존재하는데 slice는 동적인 길이의 배열과 같다. 1. 선언 방식 func main(){ var a [5]int } 배열은 고정된 size의 자료구조이기 때문에 변수를 선언하는 방식에서 타입을 **[]**를 이용해</description></item><item><title>함수</title><link>https://gowoonsori.com/blog/golang/function/</link><pubDate>Wed, 12 May 2021 22:43:51 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/function/</guid><description>1. 함수 생성 방법 package main func main(){ a := 1 say(a) } func say(a int) { println(a) } func키워드를 이용해서 함수를 선언할 수 있고 가장 기본적으로 만드는 main도 함수 이다. 2. 매개변수(인자) 1) 전달 방식 Java처럼 primitive자료형은 pass by value, reference자료형은 pass by refernece가 아닌 go는 C처럼 *을 이용해서 value인지 refer</description></item><item><title>표준 입출력</title><link>https://gowoonsori.com/blog/golang/io/</link><pubDate>Wed, 12 May 2021 00:00:35 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/io/</guid><description>GoLang의 표준 입출력은 다른 언어와 같이 터미널이 기본이며, 파일등으로 수정이 가능하고 fmt패키지에서 제공을 한다. 입출력은 BitStream형태로 되어있다. 1. 표준 출력 1) 함수 함수 기능 Print() 입력값들을 출력 Println() 마지막에 개행문자를 포함한 입력값들을 출력 Printf() c의 printf와 같이 특정 포맷에 맞게 출력 2) 포맷 서식 포맷형태 설명 %d 정</description></item><item><title>리눅스 Timezone 설정하기</title><link>https://gowoonsori.com/blog/settings/timezone/</link><pubDate>Tue, 11 May 2021 15:38:09 +0900</pubDate><guid>https://gowoonsori.com/blog/settings/timezone/</guid><description>1. 현재 서버 시간확인 $ date 리눅스를 설치할 때 timezone을 따로 설정하지 않으면 UTC 타임존으로 설치가 되고, date명령어로 현재 서버의 시간을 확인할 수 있다. 2. /etc/localtime 심볼릭 링크파일 수정 /usr/share/zoneinfo/에 여러 국가들의 정보가 존재하는데 바꾸고자 하는 지역을 /etc/localtime라는 이름으로 기존의</description></item><item><title>Spring Security Cors Mapping Error</title><link>https://gowoonsori.com/blog/error/spring-security-cors-error/</link><pubDate>Sun, 02 May 2021 21:17:07 +0900</pubDate><guid>https://gowoonsori.com/blog/error/spring-security-cors-error/</guid><description>CORS 란? Cross-Stie HTTP Requests의 약자로 한 도메인이 다른 도메인의 자원을 사용하는 것을 의미하는데, chrome cors 기본정책이 strict-origin-when-cross-origin으로 Same Origin에 대해서만 자원을 사용하도록 제한되어 있다. 여기서 Same-Origin이란 호스트명, 프로토콜, 포트가 같은 도메인을 말한다. Front</description></item><item><title>변수</title><link>https://gowoonsori.com/blog/golang/variable/</link><pubDate>Fri, 23 Apr 2021 16:54:29 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/variable/</guid><description>1. 변수 선언 1) 기본 방법 var a int var a int = 10 var b,c,d int = 1,2,3 //동시에 여러개 변수 선언도 가능하다. var키워드로 변수를 선언하고 변수명 다음 데이터 타입을 명시해주어야 하고, 선언만 하고 초기화를 해주지 않으면 go는 Zero value를 할당한다. Note Zero Value 숫자 = 0 bool = false string = &amp;quot;&amp;quot; 2) 타입 추론 var a = 10 var q,w,e = 1, true, &amp;#34;#&amp;#34; //동시에 여러개 변수 선언을 할때 다른</description></item><item><title>Golang 특징</title><link>https://gowoonsori.com/blog/golang/feature/</link><pubDate>Fri, 23 Apr 2021 15:48:20 +0900</pubDate><guid>https://gowoonsori.com/blog/golang/feature/</guid><description>1. 특징 1) 정적 컴파일 언어 JVM을 이용하는 Java와 같이 Runtime에 환경에 맞는 기계어로 번역을 하는 동적 컴파일 언어가 아닌 c나 c++와 같이 한번 compile을 통해 특정환경에 맞는 실행파일을 만들어내는 정적 컴파일 언어이다. 정적 컴파일 언어는 환경(Os, CPU종류)들이 다양해지면서 NxM개의 수만큼 많은 번역기가 존재했</description></item><item><title>돈버는 말투, 돈 버리는 말투</title><link>https://gowoonsori.com/blog/books/speech/</link><pubDate>Fri, 23 Apr 2021 15:09:03 +0900</pubDate><guid>https://gowoonsori.com/blog/books/speech/</guid><description>저자는 일본인으로 우리 한국과 일부 사회상이 안맞는 부분이 있긴 하지만 전체적으로 공감할 만한 부분들이 많았고 책도 양이 많지 않아 금방 읽힌 책이었으며, 책을 읽다보면 당연한 소리를 하고있는 것 같지만 그 당연한 것들을 지키기가 어려운 것이기에 공감한 부분들을 이곳에 정리해두려고 한다. 1. 자신의 업무 철학 확립 자신만의 업무 철학을 물었을때는 이것에 대</description></item><item><title>5분 와인</title><link>https://gowoonsori.com/blog/books/5minute-wine/</link><pubDate>Wed, 21 Apr 2021 19:23:15 +0900</pubDate><guid>https://gowoonsori.com/blog/books/5minute-wine/</guid><description>제목에서 그대로 보이듯이 와인에 대해 깊고 많은 역사를 알려주는 책이 아닌 집에서 보관방법, 와인 구매장소, 마트에서 좋은 와인 고르기, 선물용 와인 등 과 같이 가벼운 내용위주의 책들이라 간단하게 보기 좋고 책에서 언급하는 대로 아는 체,있어보이는 척 하기에 괜찮은 책이다. 샴페인을 한번 먹어본 이후로 화이트와인과 스파클링 와인에 빠져서 화이트와인을</description></item><item><title>DTO에 대하여</title><link>https://gowoonsori.com/blog/spring/dto/</link><pubDate>Thu, 15 Apr 2021 15:36:32 +0900</pubDate><guid>https://gowoonsori.com/blog/spring/dto/</guid><description>Spring boot 공부하면서 DTO의 개념과 깔끔하게 관리하는 방법등 생각하게 되는 데 다른사람들의 의견도 듣고싶고 방법을 기록하기 위해 글을 작성한다. 1. 변환 수행 계층 Controller Service Repository 데이터의 전달을 수행하는 Controller단이 가장 일반적이고 적합하다고 생각이 들지만, 다른사람들의 글을 보면 Service나 Repository에서 수행하는 것을 보</description></item><item><title>Intellij 시작시 바로 꺼지는 Error</title><link>https://gowoonsori.com/blog/error/intellij-down-error/</link><pubDate>Thu, 15 Apr 2021 12:12:22 +0900</pubDate><guid>https://gowoonsori.com/blog/error/intellij-down-error/</guid><description>윈도우로 작업을 위해 IDE를 실행시켜보면 아래와 같은 에러가 발생하며 IntelliJ뿐만 아니라 Jetbrain사의 모든 IDE들이 실행이 안되는데 매번 어떻게 해결했더라 기억을 되짚고 그때마다 여러 글을 뒤져보는게 힘들어 기록을 위해 작성한다. Internal error. Please refer to https://jb.gg/ide/critical-startup-errors java.util.concurrent.CompletionException: java.net.BindException: Address already in use: bind at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314) at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:319) at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1702) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:668) at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:665) at java.base/java.security.AccessController.doPrivileged(Native Method) at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1.run(Executors.java:665) at java.base/java.lang.Thread.run(Thread.java:834) Caused by: java.net.BindException: Address already in</description></item><item><title>[APSP] Floyd Warshall 알고리즘</title><link>https://gowoonsori.com/blog/algorithms/floyd-warshall/</link><pubDate>Mon, 12 Apr 2021 19:36:21 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/floyd-warshall/</guid><description>벨만-포드 알고리즘과 다익스트라 알고리즘과 달리 모든 최단 경로를 구하는 알고리즘이다. (물론 두 알고리즘도 모든 정점에대해 수행하면 모든 최단 경로를 구할 수 있다.) 1. 특징 음의 가중치 허용 optimal substructure 개념 이용 배열을 이용하여 구현 밀집그래프에서 모든 edge간 경로 구할때 적합 2. Pesudo Code let dist be a |V| × |V| array of minimum distances initialized to ∞ let p be a |V| × |V| array of previous node initialized to null</description></item><item><title>[MST] Prim 알고리즘</title><link>https://gowoonsori.com/blog/algorithms/prim/</link><pubDate>Mon, 12 Apr 2021 19:28:53 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/prim/</guid><description>우선순위 큐의 방법을 이용하는 알고리즘으로 vertex를 한개씩 선택하며 최소 비용의 edge를 찾는 방법이다. decrease-key의 개념을 이용하며 decrease-key는 현재 계산된 v노드까지의 거리보다 현재 노드 u부터 v까지의 경로가 더 작다면 값을 갱신해주는 방법을 이용한다. 1. 특징 정점 선택 기반 시작 정점부터 출발하여</description></item><item><title>[Disjoint Set] Union Find 알고리즘</title><link>https://gowoonsori.com/blog/algorithms/union-find/</link><pubDate>Mon, 12 Apr 2021 19:23:47 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/union-find/</guid><description>1. Disjoint Set 번역하면 서로소 집합으로 서로 중복 되지 않는 부분 집합들로 이루어진 집합(set)으로 교집합이 존재 하지 않는 부분집합들로 이루어진 집합이다. 2. Union-Find Union : 두개의 집합을 하나의 집합으로 합치는 것. Find : 어떤 원소가 주어졌을 때 이 원소가 속한 집합을 반환하는(찾는) 것. 집합들을 tree구조로 나타내어 해당원소가 어떤 집합에 속하는지 판단</description></item><item><title>[MST] Kruskal 알고리즘</title><link>https://gowoonsori.com/blog/algorithms/kruskal/</link><pubDate>Mon, 12 Apr 2021 19:19:18 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/kruskal/</guid><description>그래프 중에서 MST (Minumum Spannig Tree) 를 찾는 알고리즘중에 하나로 Union-Find알고리즘을 이용하며, 간선 (edge)의 가중치(weight)를 오름차순으로 정렬하여 가중치가 사이클이 생기지 않는 낮은 간선을 먼저 선택하는 방법이다. 사이클의 여부를 확인할때 union-find 알고리즘을 이용하여 찾는 알고리즘이다. union find 알고리즘 설명 보기 1. 특징 탐욕적인 방</description></item><item><title>[SPSP] Dijkstra 알고리즘</title><link>https://gowoonsori.com/blog/algorithms/dijkstra/</link><pubDate>Mon, 12 Apr 2021 19:00:55 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/dijkstra/</guid><description>그래프 중에서 최단 경로를 찾는 알고리즘중에 하나로 하나의 정점에서 다른 모든 정점까지의 최단경로를 구하는 알고리즘 (single-source shortest path algorithmm)으로 우선순위 큐의 방법을 이용하는 알고리즘이다. 가장 최적의 vertex를 한개씩 선택하며 최단 경로를 찾는 방법으로 relax의 개념을 이용하며 relax는 현재 계산된 v노드까지의 거리보다</description></item><item><title>[SPSP] Bellman Ford 알고리즘</title><link>https://gowoonsori.com/blog/algorithms/bellman-ford/</link><pubDate>Mon, 12 Apr 2021 18:48:53 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/bellman-ford/</guid><description>그래프 중에서 최단 경로를 찾는 알고리즘중에 하나로 하나의 정점에서 다른 모든 정점까지의 최단경로를 구하는 알고리즘 (single-source shortest path algorithmm)으로 음의 가중치도 계산 할수 있는 알고리즘이다. Vertex의 개수가 N개일 때, 한 vertex에서 다른 vertex까지 가는데 거치는 edge수는 최소 1개부터 최대 N-1번 거치게 된다. 이</description></item><item><title>Topological Sort (위상 정렬)</title><link>https://gowoonsori.com/blog/algorithms/topology-sort/</link><pubDate>Mon, 12 Apr 2021 18:46:06 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/topology-sort/</guid><description>조건 : 방향이 있고 사이클이 없는 그래프 (Directed Acyclic Graph) DAG일때, 방향성을 거스르지 않고 나열하는 것으로 순서가 있는 작업을 차례로 수행해야할때 순서를 결정해주기 위해 사용하는 알고리즘이다. 대학 커리큘럼의 선수과목이나 엄무의 일정을 시간 순서대로 배치한것이 그 예 이다. 1. 특징 방향이 있는 그래프이어야 한다. (directed) 사이클이 없어야 한다. (Acyclic) 2. Pesudo Code 1) InDegree</description></item><item><title>인증된 사용자 정보 조회</title><link>https://gowoonsori.com/blog/spring/secruity-get-userdetails/</link><pubDate>Sun, 11 Apr 2021 21:23:56 +0900</pubDate><guid>https://gowoonsori.com/blog/spring/secruity-get-userdetails/</guid><description>Spring Security의 Filter들을 모두 거쳐 인증에 통과한 User가 특정 Controller에 도달했을 때, User의 정보가 필요할때가 있다. 이때, Url의 도메인으로 id를 표시하거나 param/body로 계속 전달하기도 무리이며, Filter를 통한 인증시에 이미 한번 유저 정보를 조회하는 로직을 수행하게 된다. 그런데</description></item><item><title>@OneToMany 관계시 발생한 에러</title><link>https://gowoonsori.com/blog/error/one-to-many-error/</link><pubDate>Sun, 11 Apr 2021 20:51:45 +0900</pubDate><guid>https://gowoonsori.com/blog/error/one-to-many-error/</guid><description>JPA의 구현체인 hiberante를 이용해서 엔티티간의 상속관계를 설정하고 처음 사용해보는데 발생한 에러인 A collection with cascade=&amp;ldquo;all-delete-orphan&amp;rdquo; was no longer referenced by the owning entity instance 문제 해결한 방법을 기록하려고 한다. User의 엔티티와 Customer엔티티간의 1:N 양방향 연관관계를 맺기 위해 User에는 @OneToMany를 Customer에는 @ManyToOn</description></item><item><title>spring boot Graphql CustomContext 생성하기</title><link>https://gowoonsori.com/blog/projects/spring-graphql/custom-context/</link><pubDate>Wed, 07 Apr 2021 23:05:12 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/spring-graphql/custom-context/</guid><description>GraphQL의 요청을 핸들링하는 GraphQLServletContextBuilder를 implements하여 grpahQL요청에 대해 커스텀Context를 반환하도록 만들 수 있다. 예를들어 요청의 헤더에 접근하여 Context에 특정 헤더값을 저장하는 식으로의 custom이 가능하다. 이번 예시에서는 헤더에 a</description></item><item><title>spring boot Graphql 요청 Environment 접근</title><link>https://gowoonsori.com/blog/projects/spring-graphql/environment/</link><pubDate>Sat, 03 Apr 2021 23:53:22 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/spring-graphql/environment/</guid><description>이번에는 Spring Boot GraphQL 환경변수(쿼리명, 파라미터명, 값, 받고자하는 데이터명 등)들을 Controller에서 접근하는 방법을 포스팅하려고 한다. 보통 Rest한 서버의 Controller에서는 @PathVariable , @RequestBody 등과 같은 어노테이션을 이용해서 파라미터들에 접근할 수 있는데 요청자체가 body안에 json형태로 들어오는 graphQL은 위와</description></item><item><title>Spring Security 적용해보기</title><link>https://gowoonsori.com/blog/projects/spring-graphql/security/</link><pubDate>Thu, 01 Apr 2021 15:15:33 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/spring-graphql/security/</guid><description>지난번에 spring boot를 이용해서 graphQL서버를 구성해보았는데, 서비스를 운영할때 가장 중요한 보안을 설정하기 위해 springSecurity를 적용한 사례를 작성해보려고 한다. 우선, 인증 방식을 선택해야 하는데, 버스정보 어플같은 경우 사용자를 구분할 별도의 인증이 필요없기 때문에 간단하게 api-key를 통한 인증을 구현해</description></item><item><title>자바에서의 정렬</title><link>https://gowoonsori.com/blog/java/sort/</link><pubDate>Sun, 28 Mar 2021 16:19:06 +0900</pubDate><guid>https://gowoonsori.com/blog/java/sort/</guid><description>순서화가 가능한 자료구조를 정렬하는 방법에는 삽입정렬,버블정렬,분할정렬,퀵정렬 등 잘알려진 정렬 외에도 정말 많이 존재하는데 지금은 이러한 정렬의 알고리즘이 아닌 이미 자바 라이브러리에서 제공하는 자료구조들을 쉽게 정렬하는 방법을 정리하고자 한다. 자바에서의 크기를 비교할 수 있는 객체들은 모두 Comparable을 implemen</description></item><item><title>문자열</title><link>https://gowoonsori.com/blog/java/string/</link><pubDate>Sat, 27 Mar 2021 11:48:15 +0900</pubDate><guid>https://gowoonsori.com/blog/java/string/</guid><description>String 타입을 선언하는 방법 ◾ 리터럴 방식 String str = &amp;#34;Hello&amp;#34;; String str2 = &amp;#34;Hello&amp;#34;; System.out.println(str == str2); //true 편하기 때문에 많이 사용하는 방법으로 큰따옴표(&amp;quot; &amp;quot;)로 바로 할당하는 방법이다. 이 방법은 내부적으로 JVM메모리에 있는 상수풀에 저장이 되는데 이때문에 같은 문자열을 다른 변수에 선언을 하고 ==연산을 수행하면 true가 나오는 이유가 된다. 내부적으로</description></item><item><title>Spring boot와 EK스택 연결하기</title><link>https://gowoonsori.com/blog/spring/elk/</link><pubDate>Wed, 24 Mar 2021 15:12:34 +0900</pubDate><guid>https://gowoonsori.com/blog/spring/elk/</guid><description>현재 진행하고있는 spring boot 프로젝트에 쿼리 통계를 위해 ElasticSearch와 Kibana를 도입하기로 했고 이에 맞게 로깅방법이나 세팅 방법을 기록하기 위해 글을 작성하게 됬다. diagram 구성은 다음과 같은데 서버로 EC2 프리티어를 사용하고 있어 사양이 안좋기 때문에 서버 내부에 logstash없이 filebeat를 이용하여 로그를 전송하기로</description></item><item><title>페이징 기능 추가하기</title><link>https://gowoonsori.com/blog/projects/hugo/pagination/</link><pubDate>Wed, 10 Mar 2021 20:49:41 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/hugo/pagination/</guid><description>각종 css와 shortcode들을 추가했던 이전 글 에 이어 이번에는 pagination을 추가해보려고 한다. 저는 각 카테고리의 메인 페이지에서는 해당 카테고리의 글들을 paging처리하여 모두 볼 수 있게 구성을 하고 싶었는 데, 제가 사용하고 있는 docport 테마는 paging처리가 들어있지 않은 테마였다. 그래서 hugo 공식사이트 를 참고하여 적</description></item><item><title>GraphQL 서버 구축하기</title><link>https://gowoonsori.com/blog/projects/spring-graphql/start/</link><pubDate>Tue, 09 Mar 2021 20:03:04 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/spring-graphql/start/</guid><description>이번에 버스 공공api를 이용해 현재 gps를 기반으로한 승차 예약 시스템 프로젝트를 진행중에 있는데, 이때의 구축과정기를 작성하려고 한다. 1. Spring boot에 GraphQL적용 이유 우선, nodeJS를 이용하면 조금 더 편하게 구현할 수 있었을 텐데 그것이 아닌 Spring boot를 이용해서 GraphQL을 사용하는 이유가 프로젝트를 진행하면서 처</description></item><item><title>함수형 인터페이스와 람다식</title><link>https://gowoonsori.com/blog/java/lambda/</link><pubDate>Mon, 01 Mar 2021 20:57:12 +0900</pubDate><guid>https://gowoonsori.com/blog/java/lambda/</guid><description>1. 소개 함수형 인터페이스란 추상 메소드가 하나만 선언된 인터페이스이다. 1) 함수형 VS. 객체지향 Java 개발자에게 익숙한 객체지향 프로그래밍과의 차이를 비교하자면, 값을 취급하는 단위가 어디까지 인지 나눌 수 있다. Java 는 값(상태)과 행위를 다루기 위한 기본 단위를 객체로 정의하고, 이 객체를 클래스라는 형태로 구현한다. 함수형 프로그래밍은 행위(로</description></item><item><title>제네릭</title><link>https://gowoonsori.com/blog/java/generic/</link><pubDate>Wed, 24 Feb 2021 14:18:25 +0900</pubDate><guid>https://gowoonsori.com/blog/java/generic/</guid><description>제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법으로 컴파일 시에 더 많은 버그를 탐지할 수 있도록해 코드의 안전성을 더한다. C++의 템플릿과 처리 과정이나 방법의 차이점이 존재하지만 타입을 제거기술이라는 개념에서는 비슷하다고 볼 수 도 있다. Java 제네릭 컴파일타임에 에러를 검출할 수 있찌만 실제 동작코드는 제네릭을 사용하지 않</description></item><item><title>I/O</title><link>https://gowoonsori.com/blog/java/io/</link><pubDate>Tue, 09 Feb 2021 22:05:09 +0900</pubDate><guid>https://gowoonsori.com/blog/java/io/</guid><description>컴퓨터의 5대 기능인 입력/출력/연산/저장/제어 중 입력(Input)과 출력(Ouput)을 줄여 I/O라고 말한다. 1. 스트림 / 버퍼 / 채널 기반의 I/O 1) 스트림 입출력을 도와주는 모듈로써 Stream이라는 단어 그대로 흐름을 의미하며, 한 방향으로만 진행하는 단방향통신이다. 2) 버퍼 일종의 데이터 공간으로 메모리간, 컴퓨터와 사용자</description></item><item><title>클래스</title><link>https://gowoonsori.com/blog/java/class/</link><pubDate>Mon, 01 Feb 2021 01:21:12 +0900</pubDate><guid>https://gowoonsori.com/blog/java/class/</guid><description>객체 지향의 중심 객체를 정의하는 일종의 틀 같은 것으로 상태(변수) / 행동(메서드)이 있을 수 있다. 이로 인해 추상화, 캡슐화, 상속, 다형성 등을 가능하게 하여 개발 / 유지보수를 쉽게 해준다. 1. 클래스 정의하는 방법 class키워드를 통해 클래스를 새로 정의할 수 있다. class Fruit{ private String name; Fruit(String name){this.name = name;} public String getName(){ return name; } } 1) 필드 변수를 뜻하며 두가지 종류가 존</description></item><item><title>어노테이션</title><link>https://gowoonsori.com/blog/java/annotation/</link><pubDate>Sun, 31 Jan 2021 20:38:09 +0900</pubDate><guid>https://gowoonsori.com/blog/java/annotation/</guid><description>메서드를 오버라이딩 할때 사용했던 @Override와 같이 @ 기호를 사용하는 문법 요소로 Java5부터 등장했다. 단어의 의미인 주석과는 비슷하지만 다른 역할로써 사용되는데 메서드/클래스 등에 의미를 단순히 컴파일러에게 알려주기 위한 표식이 아닌 컴파일타임 이나 런타임에 해석될 수 있다. 1) 장점 기존의 자바는 선언적 프로그래밍방식으로 개</description></item><item><title>PointRee 프로젝트 3 - back 개발환경 셋팅과 db설계</title><link>https://gowoonsori.com/blog/projects/react-project/3/</link><pubDate>Fri, 29 Jan 2021 23:44:32 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/react-project/3/</guid><description>IntelliJ를 이용해서 pointRee폴더 내에 back폴더를 생성해주고 여기에 spring boot 2.4로 프로젝트를 시작했다. dependencies { implementation group: &amp;#39;org.springframework.boot&amp;#39;, name: &amp;#39;spring-boot-starter-web&amp;#39; testImplementation &amp;#39;org.springframework.boot:spring-boot-starter-test&amp;#39; //db implementation &amp;#39;org.springframework.boot:spring-boot-starter-data-jpa&amp;#39; implementation &amp;#39;org.springframework.boot:spring-boot-starter-validation&amp;#39; implementation &amp;#39;com.h2database:h2&amp;#39; implementation &amp;#39;mysql:mysql-connector-java&amp;#39; //lombok compileOnly &amp;#39;org.projectlombok:lombok&amp;#39; annotationProcessor &amp;#39;org.projectlombok:lombok&amp;#39; } dependency는 위와 같이 추가해주었다. 1. db설계 포인트의 유효기간을 처음에 생각을 했었으나 db설계와 구현과정에 있어 많은 시간이 생각보다 소요될</description></item><item><title>Junit5</title><link>https://gowoonsori.com/blog/java/junit5/</link><pubDate>Mon, 25 Jan 2021 20:13:58 +0900</pubDate><guid>https://gowoonsori.com/blog/java/junit5/</guid><description>자바 프로그래밍용 Unit 테스트 프레임워크 런타임시 Java 8이상이 필요하며 컴파일 타임시에 JAR로서 링크된다. Spring Boot를 이용하면 내부에 dependency가 포함되어 있다. 1. 구조 JUnit Platform : 테스트를 발견하고 계획을 생성하는 TestEngine 인터페이스를 갖고 있다. 이를 통해 테스트를 발견,실행,보고한다. JUnit Jupiter : TestEngine의 실제 구현체는</description></item><item><title>제어문</title><link>https://gowoonsori.com/blog/java/controlstatement/</link><pubDate>Mon, 25 Jan 2021 20:11:16 +0900</pubDate><guid>https://gowoonsori.com/blog/java/controlstatement/</guid><description>1. 조건문 1) Switch 특정 데이터의 값에 따라 수행할 작업을 선택하는 구문으로 switch를 사용한다. 일반적인 사용법은 C/C++와 다르지 않다. public class example { public static void main(String[] args) { String select = &amp;#34;ORANGE&amp;#34;; String fruit; switch(select){ case &amp;#34;APPLE&amp;#34; : fruit = &amp;#34;apple&amp;#34;; System.out.println(&amp;#34;사과&amp;#34;); break; case &amp;#34;BANANA&amp;#34; : fruit = &amp;#34;banana&amp;#34;; System.out.println(&amp;#34;바</description></item><item><title>Enum</title><link>https://gowoonsori.com/blog/java/enum/</link><pubDate>Sun, 24 Jan 2021 20:46:28 +0900</pubDate><guid>https://gowoonsori.com/blog/java/enum/</guid><description>백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다. Java의 Enum도 기본적으로 c나 c++의 enum과 같은 목적을 위한 클래스로 JDK 1.5이후에 생긴 클래스이다. 잠깐 C언어 얘기를 하자면 C언어의 C99 이전에는 boolean타입을 제공하지 않았기 때문에 다음과 같이 사용하고는 했었다. typedef enum _boolean { FALSE, TRUE } boolean; #define FALSE</description></item><item><title>PointRee 프로젝트 2 - front 개발환경 셋팅과 전체적인 디자인</title><link>https://gowoonsori.com/blog/projects/react-project/2/</link><pubDate>Sun, 24 Jan 2021 14:09:48 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/react-project/2/</guid><description>mkdir pointRee cd pointRee mkdir front cd front npm init -y npm install react-create-app 가장 먼저 vscode를 통해 wsl2에 접속하고 wsl2에 폴더를 만들어 주고 react-create-app으로 간단하게 react프로젝트를 시작했다. 그리고 npm run start로 시작해보면 정상적으로 프로젝트가 실행되는 것을 확인 할 수 있다. 이때 나처럼 wsl2로 실행시킨 사람이라면 window</description></item><item><title>연산자</title><link>https://gowoonsori.com/blog/java/operator/</link><pubDate>Sat, 23 Jan 2021 00:01:50 +0900</pubDate><guid>https://gowoonsori.com/blog/java/operator/</guid><description>백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다. 산술 연산자 두개의 피연산자를 갖는 이항 연산자로써, 기본적인 사칙연산을 다루는 연산자 ◾ 더하기 (+) 왼쪽의 피연산자에 오른쪽 피연산자를 더하는 연산자로 숫자+숫자, 문자열+문자열이 가능하고 문자열+숫자를 할 시 숫자를 자동으로 문자열로 변환하여 덧셈이 가능하다.</description></item><item><title>멀티 스레딩</title><link>https://gowoonsori.com/blog/java/thread/</link><pubDate>Fri, 22 Jan 2021 11:04:42 +0900</pubDate><guid>https://gowoonsori.com/blog/java/thread/</guid><description>백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다. Thread란? 쓰레드라는 개념을 이해하기 위해서는 프로세스와 병행성(Concurrency)의 개념을 알면 더 좋을 것같다. ◾ 프로세스란 프로세스의 사전적 의미는 컴퓨터에서 실행되고 있는 컴퓨터 프로그램을 말한다. 여러 개의 프로세서를 사용하는 것을 멀티 프</description></item><item><title>DataType과 변수</title><link>https://gowoonsori.com/blog/java/datatype/</link><pubDate>Fri, 22 Jan 2021 11:04:35 +0900</pubDate><guid>https://gowoonsori.com/blog/java/datatype/</guid><description>백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다. 자바에서 데이터 타입은 크게 원시(Primitive) 타입 과 참조(Reference) 타입 이 있다. 1. Primitive Type 정수, 실수, 문자, 논리 리터럴과 같은 실제 데이터 값을 저장하는 타입 종류 데이터 타입 크기(byte) 기본 값 범위 논리형 boolean 1byte false true, false 문자형 char 2byte \u0000 0 ~</description></item><item><title>JVM과 자바 실행</title><link>https://gowoonsori.com/blog/java/jvm/</link><pubDate>Fri, 22 Jan 2021 11:03:39 +0900</pubDate><guid>https://gowoonsori.com/blog/java/jvm/</guid><description>백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다. 1. JVM Java Virtual Machine의 약자로 Java와 OS사이에서 중개자 역할을 하여 메모리 관리, GC(garbage collection)을 수행하는 스택기반의 가상머신으로 C++,C와 같은 언어들과 다르게 OS에 상관없이 동작이 가능하다. Java는 C나 C++과 같이 바로 컴파일</description></item><item><title>Clean Code</title><link>https://gowoonsori.com/blog/books/cleancode/</link><pubDate>Fri, 22 Jan 2021 10:32:58 +0900</pubDate><guid>https://gowoonsori.com/blog/books/cleancode/</guid><description>1장. 깨끗한 코드 코드 품질을 측정하는 유일한 척도 = 분당 내지르는 &amp;lsquo;WTF!&amp;rsquo; 횟수 코드는 요구사항을 상세히 표현하는 수단 ( 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업 = 프로그래밍 ) 작성자가 아닌 사람도 읽고 고치기 쉽고 단순하고 직접적이다 중복을 피하고 한 기능만 수행하게 작제 추상화하기 프로그래밍은 코드를 읽는 시간 대 짜는 시간 비율이 9:1 잘</description></item><item><title>PointRee 프로젝트 1 - 설계와 환경 구성</title><link>https://gowoonsori.com/blog/projects/react-project/1/</link><pubDate>Thu, 21 Jan 2021 13:41:25 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/react-project/1/</guid><description>웹 전반적인 흐름도 익히고 프레임워크들도 공부하기 위해 토이 프로젝트로 간단한 고객 정보를 관리하고 포인트 적립을 하는 웹을 구현해보고자 한다. 사용할 스택으로는 크게 React와 Spring Boot를 사용해서 개발해보려고 한다. React는 사용을 해본적이 있고 JS에 관심이 많기 때문에 선택을 하였고, 백을 JS 프레임워크가 아닌 굳이 Spring Boot를 사</description></item><item><title>포인트 적립을 위한 웹 제작기</title><link>https://gowoonsori.com/blog/projects/react-project/start/</link><pubDate>Tue, 19 Jan 2021 14:09:48 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/react-project/start/</guid><description>방학때 엄마집에 있으며 엄마 가게를 도와주다가 갑자기 엄마가 운영하는 꽃집에 포인트 적립을 한번 도입해보고 싶다고 하셨다. 지류로 하는 도장형식은 하기 싫다고 하셨고 운영도 애매하다 하시면서 요즘 태블릿으로 전화번호만 입력하면 포스기랑 연동되어 적립이 된다더라라고 말을 하셨다. 그런데 이는 년단위 계약에 적지 않은 돈을 지불하는 유료 서비스이고 우</description></item><item><title>2020년을 보내며</title><link>https://gowoonsori.com/blog/etc/2020-restrospect/</link><pubDate>Tue, 05 Jan 2021 23:53:36 +0900</pubDate><guid>https://gowoonsori.com/blog/etc/2020-restrospect/</guid><description>2019년도에 했던 2020년 다짐으로 3학년 복학을 하면서 웹 개발 전반적으로 공부도하면서 학점관리와 토익, 토이 프로젝트를 진행하고자 했었다. 진행한 프로젝트 my-tech : 군휴학과 일반휴학포함 3년 휴학후에 다시 시작하는 컴퓨터과학 공부로써 기초부터 다시 공부하고 기록하기 위한 repository이고, 기본적인 markdown문법을 익</description></item><item><title>Packet Capture Program 만들기</title><link>https://gowoonsori.com/blog/projects/packet-capture/</link><pubDate>Fri, 11 Dec 2020 00:43:18 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/packet-capture/</guid><description>Linux환경에서 C를 이용해 raw socket을 이용한 tcpdump의 interface를 모방하는 패킷 캡쳐 프로그램 작성하는 것을 목표로 시작했습니다. 캡쳐할 정보는 IPv4(이더넷 타입이 0x0800 (ip헤더의 버전이 4)를 기반으로 2계층인 Ethernet 정보부터 패킷을 수집하여 앞에서부터 잘라내면서, Ethernet header | ip header | TCP/UDP/ICMP header | data(payload) 캡쳐 하는 프로그램</description></item><item><title>[WSL2] 포트포워딩과 window에서 workbench로 접속하기</title><link>https://gowoonsori.com/blog/settings/port-fowarding/</link><pubDate>Sun, 29 Nov 2020 12:07:28 +0900</pubDate><guid>https://gowoonsori.com/blog/settings/port-fowarding/</guid><description>WSL2를 이용하여 개발을 진행서 외부에서 접근하고 싶거나, 배포를 위해 접근하고 싶을 수가 있는데, 문제가 되는 것이 WSL2는 VM과 같은 환경이라 별도의 IP를 갖는다는 점이다. 그러면 포트포워딩을 하면 되지 않느냐라고 할 수 있는데 맞다 포트포워딩을 하면된다 하지만 재부팅을 할때마다 변경되는 IP에 매번 포트 포워딩을 할 수 없는 노릇이기에 Powershell</description></item><item><title>2020년 11월 회고</title><link>https://gowoonsori.com/blog/etc/2020-11-restrospect/</link><pubDate>Sat, 07 Nov 2020 14:58:55 +0900</pubDate><guid>https://gowoonsori.com/blog/etc/2020-11-restrospect/</guid><description>블로그 시작한지 2달째 작성해보는 회고 (첫 작성한 블로그 후기 보러가기 ) 블로그 작성을 9월을 시작으로 벌써 2달이라는 시간이 지났다. 두달동안 나름 블로그를 열심히 작성해보겠다고 게시글들을 꽤 많이 작성했는데 지금 회고를 작성하면서 돌이켜 생각해보니 잘못 하고있었구나 생각이 든다. 분명 블로그 작성을 처음 마음먹었을때는 좋은 글솜씨로 작성은</description></item><item><title>[WSL2] Mysql 자동실행 설정하기</title><link>https://gowoonsori.com/blog/settings/wsl2-mysql/</link><pubDate>Fri, 06 Nov 2020 18:41:47 +0900</pubDate><guid>https://gowoonsori.com/blog/settings/wsl2-mysql/</guid><description>[wsl2 설치가 안된 분은 여기를 참고하자 ] 나는 이번년도에 wsl2를 알게 되어 wsl2을 통해 편하게 개발을 진행하였다. 그런데, wsl2가 아직 여럿 불편한 점이 있었고 그 중 하나가 wsl2의 자동 실행 미지원이다. wsl2는 컴퓨터 시작시 자동 실행을 지원하지 않아 수동으로 ssh나 mysql, nginx와 같은 프로그램들을 실행시켜줘야하는 불편함이 있</description></item><item><title>AVL Tree</title><link>https://gowoonsori.com/blog/datastructure/avl-tree/</link><pubDate>Fri, 23 Oct 2020 17:53:52 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/avl-tree/</guid><description>BST (이진 탐색 트리)를 기반으로 둔 Tree. 어떤 노드를 기준으로 하더라도 왼쪽자식의 깊이와 오른쪽 자식의 깊이 차이가 1을 넘지 않는 트리 1. 용어 개념 정리 균형치 (Balance factor) : 자식노드의 깊이 차이 ( 왼쪽 서브트리의 높이 – 오른쪽 서브트리의 높이 ) BF는 -1, 0, 1이 기준이며, 이 범위를 벗어난다면, 그 트리의 균형은 깨진것이다. 2. 특징 BST의 모든 특징을 갖는다</description></item><item><title>KPU S/W 경진대회 본선 후기</title><link>https://gowoonsori.com/blog/etc/tukorea-sw-competition-final/</link><pubDate>Sun, 18 Oct 2020 19:22:51 +0900</pubDate><guid>https://gowoonsori.com/blog/etc/tukorea-sw-competition-final/</guid><description>본선일정은 2020.10.14 (수)에 13:30 ~ 17:00까지로 예선 후 1주일 뒤에 잡혀있었다. 수요일 본선 당일 12시 반까지 있던 수업을 마치고 기숙사에 들려 노트북을 챙겨 시험장소인 소강당으로 향했다. 도착해서 점심으로 서브웨이와 스프라이트를 받고 자리를 잡자마자 샌드위치를 허겁지겁 먹어치웠다. (아침 점심을 안먹었더니 배가 너무 고팠었다&amp;hellip</description></item><item><title>한국공학대학교 S/W 경진대회 예선 후기</title><link>https://gowoonsori.com/blog/etc/tukorea-sw-competition/</link><pubDate>Fri, 16 Oct 2020 20:39:09 +0900</pubDate><guid>https://gowoonsori.com/blog/etc/tukorea-sw-competition/</guid><description>학교공부에 치여 살다보니 알고리즘 문제 풀이를 안한지 3달정도가 지났는 데 학교 엘레베이터에 위와 같은 코테 포스터가 붙여진 것을 보았는데 실력 테스트도 해보고 상금도 노릴겸 해서 겸사겸사 신청을 했다. 대회 시상관련은 본선 진출시 기념품과, 대상 1명 50만원, 우수상 7명 30만원, 장려상 15명 10만원이었다. 사실 예선 통과후 본선에 들면 40</description></item><item><title>Counting Sort ( 계수 정렬 )</title><link>https://gowoonsori.com/blog/algorithms/counting-sort/</link><pubDate>Tue, 13 Oct 2020 00:25:11 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/counting-sort/</guid><description>계수 정렬은 삽입, 버블, 선택, 퀵, 합병 정렬들과 같이 비교를 수행하는 방식이 아닌 비교를 하지 않는 Non-Comparisions Sorting Algorithm 이다. 그러면 여기서 값을 정렬하는데 어떻게 비교 없이 수행하나요? 와 같은 질문이 있을 텐데, 계수 정렬은 비교 대신 정렬할 수의 개수와 배열의 인덱스를 가지고 정렬을 수행하게 된다. 1. 기본적인 흐름 2 1 2 4 5 3 6 5 3 을 정렬하고자 한다면 1의</description></item><item><title>Hugo theme Custom 하기</title><link>https://gowoonsori.com/blog/projects/hugo/custom/</link><pubDate>Wed, 23 Sep 2020 17:45:19 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/hugo/custom/</guid><description>우선 theme 마다 파일 경로나 파일이름, 설정방법은 조금씩 다를 수 있다는 것을 알리고 시작하겠다. 저는 theme-docport 를 사용하고 있고, 왼쪽에 카테고리 별로 구분할 수있는 기능과 오른쪽에 특정 header로의 이동기능이 있는 테마를 찾다가 이 테마를 선택했다. 1. Code 태그 수정 1) 인라인 코드 해당 code 태그의 css가 정의된 파일을 찾아야 되는데 hugo는 적용방식이 t</description></item><item><title>Hugo와 Github page로 블로그 구축</title><link>https://gowoonsori.com/blog/projects/hugo/start/</link><pubDate>Wed, 23 Sep 2020 17:45:19 +0900</pubDate><guid>https://gowoonsori.com/blog/projects/hugo/start/</guid><description>Note 블로그를 작성하기로 마음 먹은 후에 가장 먼저 할 일이 블로그를 만드는 것이었다. hugo와 github을 사용하면서 블로그를 open하는 과정과 겪었던 문제점들, 추가한 내용들을 정리하여 hugo를 선택하신분들에게 조금이나마 도움이 되고자 한다. hugo를 선택한 이유 github page를 이용하여 블로그를 운영하는데 다양한 generat</description></item><item><title>Sorting Algorithm</title><link>https://gowoonsori.com/blog/algorithms/sorting-algorithm/</link><pubDate>Sun, 20 Sep 2020 19:15:05 +0900</pubDate><guid>https://gowoonsori.com/blog/algorithms/sorting-algorithm/</guid><description>1. 종류 선택 정렬 ( Selection Sort ) 삽입 정렬 ( Insertion Sort ) 버블 정렬 ( Bubble Sort ) 셸 정렬 ( Shell Sort ) 퀵 정렬 ( Quick Sort ) 힙 정렬 ( Heap Sort ) 합병 정렬 ( Merge Sort ) 기수 정렬 ( Radix Sort ) 계수(카운트) 정렬 ( Count Sort ) 트리 정렬 큐브 정렬 팀 정렬 2. 시간 복잡도 ( Big-O ) 알고리즘 최선 평균 최악 선택 정렬 Ω(n^2) Θ(n^2) O(n^2) 버블 정렬 Ω(n) Θ(n^2) O(n^2) 삽입 정렬 Ω(n) Θ(n</description></item><item><title>Tree</title><link>https://gowoonsori.com/blog/datastructure/tree/</link><pubDate>Sun, 20 Sep 2020 01:28:52 +0900</pubDate><guid>https://gowoonsori.com/blog/datastructure/tree/</guid><description>그래프의 일종으로, 여러 노드가 한개의 노드를 가리킬 수 없는 구조 선형구조가 아닌 (비선형), 부모자식의 관계를 가지는 계층형 구조 1. 용어 개념 (설명) Node (노드): 트리를 구성하고 있는 각각의 요소를 의미한다. Edge (= link, 간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다. Root Node (루트 노드) : 트리 구조에서 최상위에 있는 노드를 의</description></item><item><title>블로그 첫 시작 👋</title><link>https://gowoonsori.com/blog/etc/start-blog/</link><pubDate>Fri, 18 Sep 2020 18:51:53 +0900</pubDate><guid>https://gowoonsori.com/blog/etc/start-blog/</guid><description>우선, 나는 말수가 적은 편이다. 말을 적게한다고 생각을 안하는 것이 아니라 머리속에서 생각은 정말 많으나, 그것을 입밖으로 꺼낼때 정리가 되지 않아 버벅거리기도 하고, 조사를 잘못 선택하여 말을 하거나 말을 하는 도중에 머리속이 꼬여 중간에 말을 멈추기도 한다. 말은 생각을 언어로 바꾼 것이기 때문에 많은 생각들을 정리하는 연습과 맞춤법, 올바른 조사사</description></item></channel></rss>