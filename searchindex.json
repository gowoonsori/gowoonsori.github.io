[{"section":"Blog","slug":"/blog/datastructure/red-black-tree/","title":"Red Black Tree","description":"레드 블랙 트리(Red Black tree)의 개념을 공부하고 c++을 이용해 구현 해보고자 한다","date":"2020년 10월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"Tree, Red Black Tree","content":"BST (이진 탐색 트리)를 기반으로 둔 Tree.\nTree의 Rebalancing 방법 중 하나로 balanced한 트리이다.\n각 노드는 값(key)말고도 색을 갖고 있으며, 색은 레드 or 블랙 2종류이다.\n1. Red Black Tree가 갖는 특성 Root Property : 루트(root)노드는 블랙(black)이다.\nExternal Property : 모든 외부 노드 (external node)는 블랙이다.\nDepth Property : 모든 단말 노드(leaf node)의 경우 루트부터 외부 노드 까지 방문하는 블랙 노드의 수가 같다.\nInternal Property : 빨강 노드의 자식은 블랙이다.\n== No Double Red : 레드 노드는 두개가 연속해서 올 수 없다. 2. 특징 BST의 모든 특징을 갖는다.\n노드의 자식이 없는 경우 자식을 가리키는 포인터는 NULL값을 저장 ( NULL을 leaf node로 간주)\n루트 노드 부터 단말 노드(leaf node)까지 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. ( balanced 상태 )\nAVL Tree 에 비해 덜 깐깐하기에 탐색속도는 느릴 수 있으나, 삽입 / 삭제 속도는 더 빠르다.\n삽입, 삭제, 탐색의 시간복잡도는 O(log n)\n3. 사용 예 Java Collection의 ArrayList HashMap의 Separate Chaining C++ map 4. 해시와 비교해서 본 장점 순서가 있는 자료일 경우 좋다. ( 해쉬는 순서가 없음 )\n일관성있는 퍼포먼스를 보여준다. ( 해쉬는 rehashing시 비정상적 시간이 걸릴 수 있음 )\n해쉬는 페이지폴트를 일으킬 수 있다.\n연속된 삽입간의 공간 지역성을 유지하기 쉽다. ( 더 적은 I/O 발생)\n트리는 부정확한 검색에 사용될 수 있다.\n5. 구현 1) Insert ( 삽입 ) BST 특징대로 삽입 후, 삽입 노드의 색깔을 RED로 설정. 삽입 후 RBT의 특징을 위배할 시 노드의 색깔을 조정하고, Black-Height가 위배되었다면, rotation을 통하여 height을 조정.\n이때, 여러 case가 존재하는 데, 새로 삽입한 노드를 z라고 할때, 부모 노드인 p[z]가 부모 노드의 부모 노드인 할아버지 노드 p[p[z]]의 왼쪽 자식인지 오른쪽 자식인지에 따라 case가 나뉘게 된다. 두개의 경우가 서로 대칭이다.\n크게 보면 아래와 같이 2가지의 경우일 때, red-black tree의 규칙이 위배가 된다.\ncase 1 : z 삼촌이 레드 ➡ 색상 변환 ( Recoloring ) z의 부모와 z의 삼촌 노드를 레드에서 블랙으로 바꾸고, z의 할아버지 노드를 블랙에서 레드로 바꾼다. z의 할아버지 노드의 부모노드가 레드인 경우 이 경우를 반복 한다. z의 부모가 블랙을 만날때 종료 되며, 루트까지 올라가게 되면 루트노드를 블랙으로 바꾸고 종료한다. (루트노드까지 올라가게 되면 black-height는 1 증가하게 된다.) case 2 : z의 삼촌이 없거나 블랙 ➡ 회전 ( rotation , restructuring) 부모노드 (p[z])가 할아버지 노드 (p[p[z]]) 의 왼쪽 자식일때 case 2-1 : z가 p[z]의 오른쪽 자식 -\u0026gt; p[z]를 중심으로 왼쪽으로 회전 시키고, 여전히 레드 블랙트리 특성을 위반하므로 case 2-2를 수행한다. case 2-2 : z가 p[z]의 왼쪽 자식 -\u0026gt; p[p[z]]를 중심으로 오른쪽 회전 시키고, p[z]와 p[p[z]]의 색상을 바꾼다. (부모노드는 블랙으로, 할아버지 노드는 레드로) 부모노드 (p[z])가 할아버지 노드 (p[p[z]]) 의 오른쪽 자식일때 case 2-1 : z가 p[z]의 왼쪽 자식 -\u0026gt; p[z]를 중심으로 오른쪽으로 회전 시키고, 여전히 레드 블랙트리 특성을 위반하므로 case 2-2를 수행한다. case 2-2 : z가 p[z]의 오른쪽 자식 -\u0026gt; p[p[z]]를 중심으로 왼쪽 회전 시키고, p[z]와 p[p[z]]의 색상을 바꾼다. (부모노드는 블랙으로, 할아버지 노드는 레드로) z를 할아버지 노드 ( p[p[z]] )로 바꿔주고 할아버지의 부모가 Red가 아닐때까지 위의 case를 반복해준다.\n2) Delete (삭제) BST의 특성을 유지하면서 삭제한 후, 삭제할 노드의 자식노드 개수에 따라 rotation 방법이 달라진다. 또한, 지워진 노드의 색깔이 Black이라면, Black-Height가 1감소한 경로에 black node가 1개 추가되도록 rotaion한다.\nNULL node(leaf node) 역시 black 이다.\ncase default 삭제할 노드를 z라 할때 z가 RED라면 그냥 삭제하고, (z의 자식이 두개인 경우는 오른쪽 자식의 가장 작은 key와 key값을 교환 후 z-\u0026gt;right의 minimum 노드를 삭제하게 되므로 이 노드의 색이 RED라면)\nBLACK이라면, black-height가 안맞게 되므로 fix up을 수행한다. (이때, double-black개념이 등장한다.)\n삭제도 삽입과 마찬가지로 삭제한 노드 z대신 위치할 노드 x가 p[x]의 왼쪽 자식인지 오른쪽 자식인지에 대해 대칭한다.\n삭제한 노드 z대신 새로 위치한 노드를 x, 그 형제 노드를 s라고 하자.\nFix up case case 1 : s가 RED인 경우 이때는 s의 자식들은 leafNode 일 수 없다.(조건 5 위반) =\u0026gt; 한개라도 leafnode일 시 black-heigh가 달라지므로 무조건 두개를 가지고 있다.\n-\u0026gt; x가 부모노드 p[x]의 왼쪽 자식일때\ns를 BLACK으로 p[x]를 RED로 바꿔준다. p[x]를 left-Rotate 시켜준다. x의 새로운 형제노드를 달아준다. (s = p[x]-\u0026gt;right) ==\u0026gt; x의 새로운 형제노드는 원래 s의 왼쪽 자식노드 (left-Rotate시켜주었기 때문) -\u0026gt; x가 부모노드 p[x]의 오른쪽 자식일때\ns를 BLACK으로 p[x]를 RED로 바꿔준다. p[x]를 right-Rotate 시켜준다. x의 새로운 형제노드를 달아준다. (s = p[x]-\u0026gt;left) ==\u0026gt; x의 새로운 형제노드는 원래 s의 왼쪽 자식노드 (left-Rotate시켜주었기 때문) 아직 double-black이 남았기 때문에 case 2/3/4를 진행한다.\ncase 2 :s가 BLACK, s의 자식들도 BLACK일때 x의 double-blackd을 지우고 s를 RED로 바꾼다. p[x]를 x로 해서 계속 한다. 만약, case 1을 거치고 case 2로 왔다면, p[x]는 red였기때문에 종료된다. ( =\u0026gt; s의 자식들이 모두 black인 채로 있기 때문에 black-height는 유지) case 3 : s는 BLACK, s의 왼쪽 자식이 RED, 오른쪽 자식이 BLACK 인 경우 -\u0026gt; x가 부모노드 p[x]의 왼쪽 자식일때\ns를 RED, s의 왼쪽 자식을 BLACK으로 바꿔준다. s를 중심으로 right-Rotate 시켜준다. x의 새로운 형제노드를 달아준다. ( s = p[x]-\u0026gt;right) -\u0026gt; x가 부모노드 p[x]의 오른쪽 자식일때\ns를 RED, s의 왼쪽 자식을 BLACK으로 바꿔준다. s를 중심으로 left-Rotate 시켜준다. x의 새로운 형제노드를 달아준다. ( s = p[x]-\u0026gt;left) case 3의 경우는 위의 과정을 끝내고 case 4를 이어서 수행한다.\ncase 4 : s는 BLACK, s의 오른쪽 자식이 RED인 경우 ➡ -\u0026gt; x가 부모노드 p[x]의 왼쪽 자식일때\ns의 색을 p[x]의 색으로 바꿔준다. - p[x]의 색을 BLACK, s의 오른쪽 자식을 BLACK으로 바꿔준다. p[x]에 대해서 left-rotate를 시켜준다. x의 double-black을 제거하고 종료한다. -\u0026gt; x가 부모노드 p[x]의 오른쪽 자식일때\ns의 색을 p[x]의 색으로 바꿔준다. p[x]의 색을 BLACK, s의 왼쪽 자식을 BLACK으로 바꿔준다. p[x]에 대해서 right-rotate를 시켜준다. x의 double-black을 제거하고 종료한다. x가 root이거나 double black이 깨질때까지 반복해준 후, x를 black으로 바꿔준다.\n3) Search (탐색) Red Black Tree는 BST의 일종이기 때문에 탐색의 밥법은 일반적인 Bianry Tree의 탐색 방법과 다르지 않다.\n찾는 값이 해당 노드보다 작다면 왼쪽으로 크다면 오른쪽으로 내려가며 값을 탐색\n6. 동작원리 아래에서 그림을 통해 동작하는 원리를 한번 살펴보자.\n1) 삽입 case 1 : z 삼촌이 레드 ➡ 색상 변환 ( Recoloring ) 아래와 같은 트리에 5를 추가한다고 하자. 그러면 오른쪽 같이 될 것이다. 이는 leafnode부터 루트까지 black-height는 모두 동일 하나 double-red로 규칙에 위배가 된다. recoloring을 통해 색깔을 바꾸어 규칙을 만족시켜주어야 한다.\nRecoloring을 통해 부모와 삼촌을 블랙으로 바꾸고 할아버지 노드를 레드로 바꾸고 할아버지를 z로 두고 루트이거나, case1조건을 위배 안 할때 까지 반복해주면 된다.\n만일 root에 도달했다면, 빨간색으로 바뀐 루트를 블랙으로 바꿔주면 이중 red는 해결이 된다.\n결국, 한 level이 red에서 black이 되었으므로, black-height는 1이 증가하게 된다.\ncase 2 : z의 삼촌이 블랙 ➡ 회전 ( rotation , restructuring) 위 와 같은 트리에서 5를 삽입하려 할 때 삼촌이 블랙이면 (없어도 leafnode는 black) case1과 같이 recoloring은 black-height가 깨지기 때문에 다른 방법을 이용해야 한다. (recoloring시 왼쪽은 black-height가 2, 오른쪽은 black-height가 1)\n이 때는, AVL Tree에서 썼던 rotate개념을 이용하여 트리의 구조를 바꿔 줌으로써, recoloring을 수행하여 double-red를 해결한다.\nAVL-Tree와 같이 삽입한 노드 z가 왼쪽에 있냐, 오른쪽에 있냐에 따라 경우가 나뉘며, 왼쪽과, 오른쪽에 있는 방법은 서로 대칭이다.\nL : 부모노드가 할아버지 노드의 왼쪽 노드일때 case 2-1 : z가 부모노드의 오른쪽 자식 부모노드를 중심으로 왼쪽으로 회전시키고, 여전히 RBT특성을 위반하므로 case2- 2를 수행한다.\ncase2는 삽입할 노드의 부모 노드는 자식을 2개를 갖고 있을 수 없기 때문에, rotate시에 문제없이 10이 부모 노드가 되면서 왼쪽자식으로 부모노드가 올 수 있다.\n삼촌이 블랙이면, 무조건 부모는 red이어야 한다.(black-height를 만족시키기 위해) 그때, 자식을 삽입시에 아래와 같은 case로 restructing이 일어나기 때문에 새로운 노드 삽입 시 case2의 경우에는 무조건 부모 노드는 하나의 자식을 갖는다.\n이중 레드에, black-height가 여전히 다르고 현재 상태가 case2와 동일 하기 때문에 case2를 진행 하면 된다.\ncase 2-2 : z가 부모노드의 왼쪽 자식 할아버지를 중심으로 오른쪽 회전시키고\n부모 노드는 블랙으로, 할아버지 노드는 레드로 서로 색상을 바꾼다.\n이렇게 되면, 삽입한 z부터 할아버지 노드까지는 규칙에 위배되지 않으니, 할아버지 노드를 기준으로 다시 case에 위배 되지 않는지 검사하면서 root까지 검사하여 balancing을 해주면 된다.\nR : 부모노드가 할아버지 노드의 오른쪽 노드일때 이 경우는 부모 노드가 할아버지 노드의 왼쪽 자식인 경우와 대칭으로 rotate 방향만 바꿔주면 방법은 동일하다.\ncase 2-1 : z가 부모노드의 왼쪽 자식 부모노드를 중심으로 right-rotate시키고, 여전히 RBT특성을 위반하고 case 2-2 와 모양이 같기 때문에 부모노드를 z로 기준으로 2-2를 수행한다,\ncase 2-2 : z가 부모노드의 오른쪽 자식 할아버지 노드를 중심으로 왼쪽 회전시키고, 부모와 할아버지의 색상을 바꾼다.\nz를 할아버지 노드로 바꿔주고 할아버지의 부모가 Red가 아닐 때까지 위의 case를 반복해준다. 만일 z가 root이라면 root를 black으로 바꾸고 종료한다.\n결과적으로 black-height가 증가한다.\n2) 삭제 case default : 무조건 실행하는 케이스 삭제할 노드를 z라 할 때, z가 RED라면 그냥 삭제하고, BLACK이라면, 그 자리를 대체하는 노드를 검은색으로 칠한다. 새로 대체하는 노드가 red인경우 black으로 바꿔 주면, 문제가 해결 되지만, 새로 대체하는 노드가 black인 경우 이중 black이 되는 경우로 이를 이중 흑색 노드라고 부르고 아래의 case에 따라 balancing을 해결하면 된다.\n깨진 이중 흑색 노드는 black-height를 맞추기 위해 한 노드가 black색을 두개 가지고 있는 노드로 결국 black-height규칙이 깨졌다는 소리이므로 fix-up을 해주어야 한다.\n삭제한 노드 z대신 새로 위치한 노드를 x, 그 형제 노드를 s라고 하자.\ncase 1 : s가 RED인 경우 이때는 s의 자식들은 leafNode 일 수 없다. 조건 5를 위반하기 때문에 한개라도 leafnode이면 black-height가 달라지므로 무조건 두개를 가지고 있다.\nL : x가 부모 노드 p[x]의 왼쪽 자식일때 위 트리에서 5를 삭제하려고 한다면, 대체되는 노드 x는 leafnode가 대체되며, 이중 흑색 노드가 되어 black-height가 깨지기 때문에 rotate와 recoloring을 통해 규칙을 바로잡아주어야 한다.\ns를 BLACK으로 부모를 RED로 바꿔주고 부모기준으로 left-Rotate 시켜준다. rotate시켜줌으로써, x(leafnode)의 형제 노드s가 red(20)에서, black(15)로 바뀌었다.\n그래도 여전히 이중 흑색 노드를 갖고 있기 때문에, 다른 case들을 수행해주어야 한다.\nR : x가 부모 노드 p[x]의 오른쪽 자식일때 40을 삭제한다고 한다면, null이 x, 10이 s가 되고 x는 이중 흑색 노드가 되므로 rebalancing을 해주어야 한다.\ns를 BLACK으로 p[x]를 RED로 바꿔준 후 px 를 right-Rotate 시켜준다. 아직 이중 흑색 노드가 남았기 때문에 다른 case를 진행한다.\ncase 2 : s가 BLACK, s의 자식들도 BLACK일때 case1을 거치고 온 경우도 이에 속하며, 이중 흑색 노드가 존재하기 때문에 recoloring을 통해 balancing을 해주어야 한다.\nx의 double-black을 지우고 s를 RED로 바꾼후 부모를 black으로 칠해준다. 만약, case 1을 거치고 case 2로 왔다면, p[x]는 red였기 때문에 종료되고, x의 부모 노드가 black이라면 다시 이중 흑색 노드가 생기기 때문에 부모를 기준으로 다시 다른 case를 수행해준다\ncase 3 L : x가 부모 노드 p[x]의 왼쪽 자식일때 x가 부모 노드 p[x]의 왼쪽 자식일때, s는 BLACK, s의 왼쪽 자식이 RED, 오른쪽 자식이 BLACK 인 경우 case2와 같은 방법으로 s(15)를 red로 부모(10)를 black으로 바꿔줄 경우 double-red가 되므로 recoloring을 할 수 없다. 그래서 rotate를 하여 구조를 바꿔준 후 recoloring을 수행해야한다.\ns를 중심으로 right-Rotate 시켜준 후, s와 s의 왼쪽 자식의 색을 바꿔준다. 그러면, s는 15(black)에서 12(black)으로 바뀌고 s의 자식은 오른쪽으로 이동하게 되는 것을 볼 수 있다.\n여전히, 이중 흑색 노드는 존재하므로 다른 case를 반복 수행하는 데, case3을 마치고 나면 case4의 모양이 되기 때문에, 바로 case4를 수행한다.\nR : x가 부모 노드 p[x]의 왼쪽 자식일때 x가 부모 노드 p[x]의 오른쪽 자식일때, s는 BLACK, s의 오른쪽 자식이 RED, 왼쪽 자식이 BLACK 인 경우 case 3-L의 대칭으로 똑같이 rotate를 하여 구조를 바꿔준 후 recoloring을 수행해야한다.\ns(25)를 중심으로 left-Rotate 시켜준 후, s와 s(28)의 오른쪽 자식의 색을 바꿔준다. 그러면, s는 25(black)에서 28(black)으로 바뀌고 s의 자식은 왼쪽으로 이동하게 되는 것을 볼 수 있다.\n이경우에도, 여전히 이중 흑색 노드는 존재하므로 다른 case를 반복 수행하는 데, case3을 마치고 나면 case4의 모양이 되기 때문에, 바로 case4를 수행한다.\ncase 4 L : x가 부모 노드 p[x]의 왼쪽 자식일 때 s는 BLACK, s의 오른쪽 자식이 RED인 경우 s의 색을 부모의 색으로 부모의 색을 BLACK, s의 오른쪽 자식을 BLACK으로 바꿔준다. Recoloring을 해주면 black-height가 여전히 깨져있기 때문에, rotate를 시켜줘야 한다.\np[x]에 대해서 left-rotate를 시켜주고 x의 double-black을 제거해주면, 모든 규칙이 성립하게 되어 끝난다.\nR : x가 부모 노드 p[x]의 오른쪽 자식일 때 s는 BLACK, s의 왼쪽 자식이 RED인 경우 이는 4-L의 대칭으로 s의 색을 p[x]의 색으로 p[x]의 색을 BLACK, s의 왼쪽 자식을 BLACK으로 바꿔준다.\n부모에 대해서 right-rotate를 시켜주고 x의 double-black을 제거해주면, 모든 규칙이 성립하게 되어 끝난다.\n3) 추가 구현시에 leafnode가 black임을 명시해주기 위해 비어 있는 자식 포인터에 color를 black으로 초기화한 leafnode를 가리켜야 구현이 수월한데, 새 노드를 삽입할 때 마다 leafnode를 생성해서 붙여주는 것은 메모리적으로 봐도 매우 비효율적이고, leafnode인지 확인하기 위해 ‘==’ 연산을 수행해도 메모리주소가 다르기 때문에 leafnode가 아니라고 할 수 있다.\n그래서, 모든 leafnode들을 가리키는 포인터는 하나의 leafnode를 가리키게 함으로써, 메모리 절약과, 연산의 효율을 더하는 방법으로 구현을 하면 수월하다. 7. 구현 코드 코드 보기 github에서 보기 /* * C++ 이용하여 Red Black Tree 구현하기 * * 목적 : Red Black Tree 공부 하기 위해 작성했으며, * C++ 이용하여 작성하시는 분들에게 도움이 되고자 했다. * * 설명 : key 값은 int만 가능 하며 중복 key는 허용 x * 이중 연결 리스트로 구현 * Red / Black은 식별하기 쉽게 enum이용 했으며, bool 이용시 데이터 크기 절약 * * class RBTree * * 변수 : root node =\u0026gt; root노드는 항상 black * leaf node =\u0026gt; 끝에 해당하는 노드들은 leaf node들을 가지고 있다. * leaf node라는 것만 알면 되기 때문에 새로운 노드 삽입 때마다 leaf node를 생성 해줄 필요없이 * 모든 말단 노드들은 이 leaf node를 가리키는 식으로 구현 * leaf node는 항상 black * * 생성자 : RBTREE =\u0026gt; node 구조체 생성후 * 색은 black 초기화 * 모든 자식은 nullptr로 초기화. * * 함수 : IsKey =\u0026gt; key값이 있는지 검사하는 함수 * Insert =\u0026gt; 삽입 함수 * InsertFixUp =\u0026gt; 삽입 후 규칙 깨졌을 시 재조정 함수 * Delete =\u0026gt; 삭제 함수 * DeleteFixUp =\u0026gt; 삭제 후 규칙 깨졌을 시 재조정 함수 * Transplant =\u0026gt; 삭제 시 이용하며, 삭제할 노드의 자식 노드를 부모노드에 연결해주는 함수 * RotateRight(x) =\u0026gt; x기준 오른쪽으로 회전 * RotateLeft(x) =\u0026gt; x기준 왼쪽으로 회전 * * Inorder,Preorder,Postorder =\u0026gt; 순회 함수 * tree_minimum(x), tree_maximum(x) =\u0026gt; 노드 x 기준으로 가장 왼쪽, 오른쪽 return 함수 * * DisplayMenu, SelectMenu =\u0026gt; 초기 Menu판 print 함수 * Insert_helper,Delete_helper,order_helper,print_helper =\u0026gt; 각각 수행시 입력받고 조건 에러 처리 위한 함수 와 tree print 해주는 함수 * * 작성자 : gowoonsori * github : https://github.com/gowoonsori/my-tech/tree/master/dataStructure/Tree * 해당 source gist : https://gist.github.com/gowoonsori/a725e29ef1880f0592fe5760f4908c6b */ #include \u0026lt;iostream\u0026gt; enum Color { RED, BLACK }; struct node { int key; node *left = nullptr; node *right = nullptr; node *parent = nullptr; Color color = BLACK; }; typedef node *NodePtr; class RBTREE { private: NodePtr root; //루트 노드 NodePtr leafNode; //단말노드 //key값이 있는지 없는지 검사 있으면 pointer 값, 없으면 nullptr NodePtr IsKey(int item) { NodePtr t = root; NodePtr parent = NULL; /*key값을 찾거나 없다면 break*/ while (t != NULL \u0026amp;\u0026amp; t-\u0026gt;key != item) { parent = t; t = (item \u0026lt; parent-\u0026gt;key) ? parent-\u0026gt;left : parent-\u0026gt;right; } return t; } void Insert(int item) { // x : 삽입할 곳 찾기위한 포인터 | y : 삽입할 곳의 부모노드 NodePtr x = this-\u0026gt;root, y = nullptr; NodePtr z = new node(); z-\u0026gt;key = item; z-\u0026gt;color = RED; z-\u0026gt;parent = nullptr; z-\u0026gt;left = leafNode; z-\u0026gt;right = leafNode; /*BST의 일반 삽입 연산*/ while (x != leafNode) { y = x; if (x-\u0026gt;key \u0026lt; item) x = x-\u0026gt;right; else x = x-\u0026gt;left; } z-\u0026gt;parent = y; if (y == nullptr) root = z; else if (z-\u0026gt;key \u0026gt; y-\u0026gt;key) y-\u0026gt;right = z; else y-\u0026gt;left = z; //z가 root노드라면 if (z-\u0026gt;parent == nullptr) { z-\u0026gt;color = BLACK; return; } // z의 부모노드가 root노드라면 Fix Up 필요없이 red컬러로 붙여주면 된다. if (z-\u0026gt;parent-\u0026gt;parent == nullptr) { return; } InsertFixUp(z); return; } void InsertFixUp(NodePtr z) { /*root 노드가 아니고 부모 색이 red라면*/ while (z != root \u0026amp;\u0026amp; z-\u0026gt;parent-\u0026gt;color == RED) { NodePtr grandparent = z-\u0026gt;parent-\u0026gt;parent; NodePtr uncle = (z-\u0026gt;parent == grandparent-\u0026gt;left) ? grandparent-\u0026gt;right : grandparent-\u0026gt;left; bool side = (z-\u0026gt;parent == grandparent-\u0026gt;left) ? true : false; //if p[z]가 p[p[z]]의 왼쪽 자식이면 1 / 오른쪽이면 0 /*case 1*/ if (uncle \u0026amp;\u0026amp; uncle-\u0026gt;color == RED) { z-\u0026gt;parent-\u0026gt;color = BLACK; uncle-\u0026gt;color = BLACK; grandparent-\u0026gt;color = RED; z = grandparent; } /*case 2 side == true ) p[z]는 p[p[z]]의 왼쪽 자식 인 경우이다. side == false ) p[z]는 p[p[z]]의 오른쪽 자식 인 경우이다. */ else { /*case 2-1*/ if (z == (side ? z-\u0026gt;parent-\u0026gt;right : z-\u0026gt;parent-\u0026gt;left)) { z = z-\u0026gt;parent; side ? RotateLeft(z) : RotateRight(z); } /*case 2-2*/ z-\u0026gt;parent-\u0026gt;color = BLACK; grandparent-\u0026gt;color = RED; side ? RotateRight(grandparent) : RotateLeft(grandparent); } } root-\u0026gt;color = BLACK; } bool Delete(int item) { NodePtr z = IsKey(item); if (!z) return false; else { NodePtr x, y; Color OriginalColor = z-\u0026gt;color; /*자식이 없거나 1개인 경우 삭제할 노드(z)가 블랙이면 doulbe red이므로 fix*/ if (z-\u0026gt;left == leafNode) { x = z-\u0026gt;right; Transplant(z, z-\u0026gt;right); } else if (z-\u0026gt;right == leafNode) { x = z-\u0026gt;left; Transplant(z, z-\u0026gt;left); } else { y = tree_minimum(z-\u0026gt;right); OriginalColor = y-\u0026gt;color; x = y-\u0026gt;right; //y의 왼쪽 자식은 없다. if (y-\u0026gt;parent == z) { //z의 오른쪽 자식이 가장 작은 key x-\u0026gt;parent = y; // x가 leafnode일 때, fix하게 될 때 사용 } else { Transplant(y, y-\u0026gt;right); y-\u0026gt;right = z-\u0026gt;right; y-\u0026gt;right-\u0026gt;parent = y; } Transplant(z, y); y-\u0026gt;left = z-\u0026gt;left; y-\u0026gt;left-\u0026gt;parent = y; y-\u0026gt;color = z-\u0026gt;color; } delete z; if (OriginalColor == BLACK) { DelteFixUp(x); } } return true; } void DelteFixUp(NodePtr x) { NodePtr s; //형제노드 s //root이거나 double black 이 깨질때 까지 while (x != root \u0026amp;\u0026amp; x-\u0026gt;color == BLACK) { /* x가 p[x]의 왼쪽자식인 경우 */ if (x == x-\u0026gt;parent-\u0026gt;left) { s = x-\u0026gt;parent-\u0026gt;right; // case 1 if (s-\u0026gt;color == RED) { s-\u0026gt;color = BLACK; x-\u0026gt;parent-\u0026gt;color = RED; RotateLeft(x-\u0026gt;parent); s = x-\u0026gt;parent-\u0026gt;right; } // case 2 if (s-\u0026gt;left-\u0026gt;color == BLACK \u0026amp;\u0026amp; s-\u0026gt;right-\u0026gt;color == BLACK) { s-\u0026gt;color = RED; x = x-\u0026gt;parent; } else { // case 3 if (s-\u0026gt;right-\u0026gt;color == BLACK) { s-\u0026gt;left-\u0026gt;color = BLACK; s-\u0026gt;color = RED; RotateRight(s); s = x-\u0026gt;parent-\u0026gt;right; } // case 4 s-\u0026gt;color = x-\u0026gt;parent-\u0026gt;color; x-\u0026gt;parent-\u0026gt;color = BLACK; s-\u0026gt;right-\u0026gt;color = BLACK; RotateLeft(x-\u0026gt;parent); x = root; } } /*x가 p[x]의 오른쪽 자식인 경우*/ else { s = x-\u0026gt;parent-\u0026gt;left; // case 1 if (s-\u0026gt;color == RED) { s-\u0026gt;color = BLACK; x-\u0026gt;parent-\u0026gt;color = RED; RotateRight(x-\u0026gt;parent); s = x-\u0026gt;parent-\u0026gt;left; } // case 2 if (s-\u0026gt;left-\u0026gt;color == BLACK \u0026amp;\u0026amp; s-\u0026gt;right-\u0026gt;color == BLACK) { s-\u0026gt;color = RED; x = x-\u0026gt;parent; } else { // case 3 if (s-\u0026gt;left-\u0026gt;color == BLACK) { s-\u0026gt;right-\u0026gt;color = BLACK; s-\u0026gt;color = RED; RotateLeft(s); s = x-\u0026gt;parent-\u0026gt;left; } // case 4 s-\u0026gt;color = x-\u0026gt;parent-\u0026gt;color; x-\u0026gt;parent-\u0026gt;color = BLACK; s-\u0026gt;left-\u0026gt;color = BLACK; RotateRight(x-\u0026gt;parent); x = root; } } } x-\u0026gt;color = BLACK; root-\u0026gt;color = BLACK; } /* u의 위치에 v를 이식 */ void Transplant(NodePtr u, NodePtr v) { if (u-\u0026gt;parent == nullptr) root = v; else if (u == u-\u0026gt;parent-\u0026gt;left) u-\u0026gt;parent-\u0026gt;left = v; else u-\u0026gt;parent-\u0026gt;right = v; v-\u0026gt;parent = u-\u0026gt;parent; } /*x를 중심으로 왼쪽으로 회전*/ void RotateLeft(NodePtr x) { NodePtr y; y = x-\u0026gt;right; x-\u0026gt;right = y-\u0026gt;left; if (y-\u0026gt;left != leafNode) { y-\u0026gt;left-\u0026gt;parent = x; } y-\u0026gt;parent = x-\u0026gt;parent; if (!x-\u0026gt;parent) { root = y; } else if (x == x-\u0026gt;parent-\u0026gt;left) { x-\u0026gt;parent-\u0026gt;left = y; } else { x-\u0026gt;parent-\u0026gt;right = y; } x-\u0026gt;parent = y; y-\u0026gt;left = x; } /*x를 중심으로 오른쪽으로 회전*/ void RotateRight(NodePtr y) { NodePtr x; x = y-\u0026gt;left; y-\u0026gt;left = x-\u0026gt;right; if (x-\u0026gt;right != leafNode) { x-\u0026gt;right-\u0026gt;parent = y; } x-\u0026gt;parent = y-\u0026gt;parent; if (!y-\u0026gt;parent) { root = x; } else if (y == y-\u0026gt;parent-\u0026gt;left) { y-\u0026gt;parent-\u0026gt;left = x; } else { y-\u0026gt;parent-\u0026gt;right = x; } y-\u0026gt;parent = x; x-\u0026gt;right = y; } /*show tree*/ void print_helper(NodePtr root, std::string indent, bool last) { // print the tree structure on the screen if (root != leafNode) { std::cout \u0026lt;\u0026lt; indent; if (last) { std::cout \u0026lt;\u0026lt; \u0026#34;R----\u0026#34;; indent += \u0026#34; \u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;L----\u0026#34;; indent += \u0026#34;| \u0026#34;; } std::string sColor = (root-\u0026gt;color == RED) ? \u0026#34;RED\u0026#34; : \u0026#34;BLACK\u0026#34;; std::cout \u0026lt;\u0026lt; root-\u0026gt;key \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; sColor \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; print_helper(root-\u0026gt;left, indent, false); print_helper(root-\u0026gt;right, indent, true); } } /*중위순회*/ void Inorder(NodePtr target) { if (target == leafNode) return; Inorder(target-\u0026gt;left); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; Inorder(target-\u0026gt;right); } /*후위순회*/ void Postorder(NodePtr target) { if (target == leafNode) return; Postorder(target-\u0026gt;left); Postorder(target-\u0026gt;right); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } /*전위순회*/ void Preorder(NodePtr target) { if (target == leafNode) return; std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; Preorder(target-\u0026gt;left); Preorder(target-\u0026gt;right); } public: RBTREE() { leafNode = new node; leafNode-\u0026gt;color = BLACK; leafNode-\u0026gt;left = nullptr; leafNode-\u0026gt;right = nullptr; leafNode-\u0026gt;parent = nullptr; root = leafNode; } //최솟값 찾기 NodePtr tree_minimum(NodePtr x) { while (x-\u0026gt;left != leafNode) { x = x-\u0026gt;left; } return x; } //최댓값 찾기 NodePtr tree_maximum(NodePtr x) { while (x-\u0026gt;right != leafNode) { x = x-\u0026gt;right; } return x; } void DisplayMenuBoard() { std::cout \u0026lt;\u0026lt; \u0026#34; ** Red Black Tree ** \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; Menu \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 1. Insert Key \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 2. Delete Key \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 3. Show Tree \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 4. choose order \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 5. show Menu \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 6. clear Display \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 7. exit \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::endl; } void SelectMenu() { DisplayMenuBoard(); int i = -1; while (i != 8) { std::cout \u0026lt;\u0026lt; \u0026#34;--\u0026gt; select : \u0026#34;; std::cin \u0026gt;\u0026gt; i; switch (i) { case 1: Insert_helper(); break; case 2: Delete_helper(); break; case 3: print_helper(root, \u0026#34;\u0026#34;, true); break; case 4: Order_helper(); break; case 5: DisplayMenuBoard(); break; case 6: system(\u0026#34;cls\u0026#34;); DisplayMenuBoard(); break; case 7: return; default: std::cout \u0026lt;\u0026lt; \u0026#34; !!! Wrong entered !!!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; } } } void Insert_helper() { int item; std::cout \u0026lt;\u0026lt; \u0026#34;Key to insert : \u0026#34;; std::cin \u0026gt;\u0026gt; item; if (IsKey(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;!!! \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; is already exists !!!\\n\u0026#34;; return; } Insert(item); } void Delete_helper() { int item; std::cout \u0026lt;\u0026lt; \u0026#34;Key to delete : \u0026#34;; std::cin \u0026gt;\u0026gt; item; if (!Delete(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;!!! \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; is not exists !!!\\n\u0026#34;; return; } return; } void Order_helper() { int i; std::cout \u0026lt;\u0026lt; \u0026#34; == Order Menu ==\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 1. PreOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 2. InOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 3. PostOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 4. exit\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; select : \u0026#34;; std::cin \u0026gt;\u0026gt; i; switch (i) { case 1: Preorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 2: Inorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 3: Postorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 4: return; default: std::cout \u0026lt;\u0026lt; \u0026#34; !!! Wrong enter !!!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; break; } return; } }; int main() { RBTREE tree; tree.SelectMenu(); return 0; } "},{"section":"Blog","slug":"/blog/books/designing-data-intensive-applications/","title":"데이터 중심 애플리케이션 설계","description":"데이터 중심 애플리케이션 설계 (신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 시스템을 지탱하는 핵심아이디어) 를 읽고","date":"2022년 4월 27일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/designing-data-intensive-applications/preview_hub6f83a8436334c22eb71fdb373145325_49229_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"315\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/designing-data-intensive-applications\\/preview_hub6f83a8436334c22eb71fdb373145325_49229_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/designing-data-intensive-applications/preview_hub6f83a8436334c22eb71fdb373145325_49229_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/designing-data-intensive-applications\\/preview_hub6f83a8436334c22eb71fdb373145325_49229_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"이 책은 총 3부로 구성되어 1부에서는 근본 개념에 대해 설명하고 2부에서는 데이터를 분산 저장하기 위한 내용을, 3부에서는 한 데이터셋에서 다른 데이터셋을 파생하는 시스템애 대해 설명한다.\n1장. 데이터 시스템의 기초 1) 신뢰성 잘못될 수 있는 일을 결함이라 부른다. 이 결함을 예측하고 대처할 수 있는 시스템을 내 결함성/탄력성을 가졌다고 말할 수 있다.\n결함과 장애는 동일하지 않은데, 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우이다.\n결함 유형 하드웨어 결함 소프트웨어 오류 : 하드웨어 결함과 달리 신속한 해결책이 없으며 아래와 같은 방법들이 도움을 줄 수 있다. 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기 빈틈없는 테스트 프로세스 격리 죽은 프로세스의 재시작 허용 시스템 동작의 측정 모니터링 인적 오류 2) 확장성 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어로 시스템에 부여하는 일차원적인 표식이 아니다! \u0026ldquo;X시스템은 확장 가능하다\u0026rdquo; 와 같은 말은 의미가 없는 말이다.\n부하 기술하기 현재 시스템의 부하를 기술해야 부하 성장 질문 (부하가 두 배로 되면 어떻게 될까? 와 같은 질문) 을 논의 할 수 있다. 이때 부하는 초당 요청수, db의 읽기 대 쓰기 비율, 동시 활성사용자 수, 캐시 적중률과 같은 부하 매개변수라 부르는 값들을 통해 나타낼 수 있다.\n"},{"section":"Blog","slug":"/blog/books/go-in-action/","title":"Go in Action","description":"Go in Action을 읽고 쓴 후기글","date":"2022년 3월 29일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/go-in-action/preview_hud3b4467563c8fb3ee51a35d1845e293d_5693_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"526\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/go-in-action\\/preview_hud3b4467563c8fb3ee51a35d1845e293d_5693_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/go-in-action/preview_hud3b4467563c8fb3ee51a35d1845e293d_5693_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/go-in-action\\/preview_hud3b4467563c8fb3ee51a35d1845e293d_5693_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"저는 개인적으로 GoLang을 접한지는 꽤 되었습니다. 제가 Go를 학습할때는 인터넷을 통해 충분히 학습할 수 있었는 데, 키워드들이 많지 않았고 http://golang.site 에 대부분 필요한 내용은 설명되어있어 무리없이 학습할 수 있었습니다. 그런데 책을 구매하게 된 이유는 요즘 읽을 책이 마땅치 않았기도 하고, Go 책을 개인적으로 소장하고 싶어 구매해본 책입니다.\n책이 나온지는 꽤 된 책입니다. 하지만, go언어가 version이 높아지면서 언어에 큰 변화가 생기지 않았기 때문에 별 무리 없이 책을 읽을 수 있었습니다. 책의 전체적인 내용은 RSS 피드 검색 예제와 같은 실제 서비스들을 예시로 go언어의 특징이나 키워드들을 설명해주고 있습니다. 그래서 책 초반에 추천 독자를 중급 수준의 개발자로 설정하고 있다고 설명하고 있는 것 같습니다. 하지만, 예제 코드들마다 주석으로 매우 친절하게 설명이 되어있고 조금 복잡해지는 아키텍쳐나 내용이라면 그림을 통해 설명하면서 이해를 도와주고 있습니다. 번역도 잘 되어있기 때문에 무리없이 책을 이해할 수 있었습니다.\n아직 초급 수준의 개발자인 내가봐도 충분히 잘 읽히는 책인 것 같습니다. 한가지 아쉬운 것은 과거에 집필된 책인 만큼, 현재 1.18이 release되면서 추가된 generic에 대한 설명은 포함되어있지 않습니다.\n전체적으로 봤을때 GoLang을 입문하려고 하는 사람이 봐도 좋을만한 책인 것 같습니다. 책이 두껍지 않으며 핵심키워드들마다 간결하면서도 쉽게 설명이 잘되어있습니다.\n"},{"section":"Blog","slug":"/blog/books/accelerate/","title":"디지털 트랜스포메이션 엔진(ACCELERATE)","description":"ACCELERATE:The Science Of Lean Software and DevOps:Building and Scaling High Performing Techonology Oragnizations(디지털 포메이션 엔진)을 읽고 정리한 글","date":"2022년 3월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/accelerate/preview_hucfb9f1cf5f74b8fff269f37f25d2804e_7439_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"633\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/accelerate\\/preview_hucfb9f1cf5f74b8fff269f37f25d2804e_7439_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/accelerate/preview_hucfb9f1cf5f74b8fff269f37f25d2804e_7439_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/accelerate\\/preview_hucfb9f1cf5f74b8fff269f37f25d2804e_7439_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"제목부터 낯선 이 디지털 트랜스포메이션 엔진이라는 책은 Redit을 통해 처음 접하게 되었고, 책의 원제목은 ACCELERATE:The Science Of Lean Software and DevOps:Building and Scaling High Performing Techonology Oragnizations 이다.\n이름만 들었을때는 책 내용이 굉장히 어려워 보인다. 하지만, 쪽수도 얼마 안되고 내용이 재미있어 굉장이 빨리 읽힌 책이었다. 책의 전체적인 내용은 설문조사와 연구를 통해 DevOps가 소프트웨어의 전달 성과, 팀원들의 만족도, 더 나아가 고객만족도에 미치는 영향을 분석하고 고성과 조직으로 가는 요소를 제시하는 책이다.\n책을 읽다보면 이해하기 어려운 단어들이 존재하는데 번역이 어색하게 된 것인지 원문을 봐야 정확한 뜻을 이해할 수 있을 것 같다.\n1부. 2013년 후반부터 4년간 기업에 주는 가치가 무엇인지 연구후 그 결과를 작성한 책으로 Cross-sectional study(단면연구)를 사용하여 소프트웨어와 조직 성과를 향상시키는 것이 무엇인지 조사한 내용을 담고있다. 연구를 위해 약 23,000개 이상의 설문 조사 응답과 스타트업부터 10,000명이 넘는 기업까지 2,000개 이상의 기업을 대상으로 조사했다고 한다.\n단면연구? 특정 시점,즉 단면 데이터에서 모집단이나 대표 하위 집합의 데이터를 분석하는 관측 연구\n책 초반부분에 나온 내용에 따르면 저자들은 구글 조직원들을 대상으로 조직을 효과적인 팀으로 만든 원인을 조사를 진행했다고 하며, 그들은 핵심요인으로 개인별 역량/특성이나 특별한 기술의 조합이 될 줄 알았으나 실제로는 팀 구성원이 어떻게 상호작용하고 일을 구조화하고 그들이 이룬 결과를 바라보는지가 더 중요하게 작용했다고 한다.\n1부의 내용은 이 처럼 개개인의 역량보다는 지속적 전달이 미치는 영향 범위에 대해 설명을 하고 있는데 요약해보면 다음과 같다.\nNote\n배포 빈도가 잦으며 변경사항의 리드타임과 평균 복구시간이 낮을 수록 소프트웨어 전달 성과가 고성과 조직이었으며 그에 따라 변경 사항 실패율 또한 낮았다. 소프트웨어 전달 성과가 높을수록 그 조직의 성과에도 영향을 미친다. 개인이 좁은 책임범위를 가지고 실수나 실패가 발생했을때 그를 정의하고 색출해내는게 아니라 책임의 위험은 다같이 공유하면서 실패는 질문으로 이루어지고 재실패를 예방해야 한다. 문화를 바꾸는 방법은 사람들의 사고방식을 먼저 바꾸는게 아니라 사람들이 행동하는 방식(즉, 그들이 하는 일을 바꾸는 것에서 시작) ⇒ 린/애자일의 이론에 따라 프랙티스르 조직에 구현하면 저절로 문화에 영향을 미칠 수 있다. 지속적 전달 실제로 전달 성과, 조직문화, 팀 번아웃에 주목할 만한 영향을 미친다. 여기서 지속적 전달의 특성은 품질의 내재화, 작은 배치 크기, 반복적인 작업은 단순화하고 자동화, 끊임없는 발전추구, 위험책임공유, 자동화된 형상 관리, 지속적 통합, 지속적 테스트 등이 있다. 시스템과 그 시스템을 구축하고 유지하는 팀들이 느슨하게 결합돼 있다면 모든 졸류의 시스템에서 고성과를 얻는것이 가능하다. 효과적인 제품관리가 성과를 높인다. 고객 피드백을 수집하고 구현/ 작업 흐름이 가치 흐름 내내 시각적으로 보이도록 하고 팀은 작업을 일주일 이내에 완료할 수 잇는 작은 조각으로 나누고 팀 실험을 활성화해야 한다. 이 부분에서 얼마전에 읽은 당근마켓의 포스팅이 생각났다. (당근마켓의 1주 1개 실험하는 프로덕트팀에 관한 글 ) 직무만족도가 조직 성과에 영향을 미치며 직무만족도 들은 위에서말한 것들에 영향을받는다. 또한, 1부 마지막쯤에는 좋은 리더의 특징과 리더가 팀에 투자할 수 있는 방법의 예시들을 제시하고 있었다.\n1) 좋은 리더의 특징 비전(향후 5년 내의 방향) 제시 동기를부여하는 의사소통 (불확실하거나 변화하는 상홍에서도 영감과 동기를 부여 지적 자극(새로운방식으로 문제를 생각하게 하는 방향으로 자극) 지원적 리더십 : 사람의 개인적 요구와 감정에 관심과 배려 개인적 인정: 목표달성과 업무의 질향상에 칭찬과 인정 / 뛰어난 성과라면 개인적으로 칭찬 리더십의 영향력은 소프트웨어 전달 성과와 조직성과로 이어진다고 한다. 한마디로 리더 단독으로는 높은 성과를 볼수 없으며 리더십은 훌륭한팀, 훌륭한 기술, 훌륭한 조직을 만드는데 도움이되지만, 간접적으로 팀이 시스템을 다시 설계하고 지속적 전달과 프랙티스를 시행할 수 있도록 함으로써 성과르 개선시킬 수 있다는 의미라고 한다.\n2) 리더가 팀에 투자할 수 있는 방법 예시 서로 다른 부서에 속한 팀들이 모여 프로젝트를 진행할 수 있도록 핵 데이 지정 기술 부채 문제를 해결하는 야크데이 조직 정기적으로 내부 컨퍼런스/세미나 개최 직원들에게 20%시간, 릴리즈 후 며칠 등 새로운 도구,기술을 실험할 수 있는 전용 시간 할당 2부와 3부. 2부는 위와 같은 결과를 도출하기 위해 사용한 연구, 분석, 조사방법에 대한 설명과 그를 사용한 이유 설명하고 있으며 3부에는 결론과 분석한 연구의 통계, 자료들을 보여줌으로써 말의 신뢰성을 높이고 있다.\n하지만, 번역말투 때문인지 읽다보면 마치 결과를 어느정도 예상하거나 정해놓고 조사를 한 느낌도 받았고 설문조사의 대상이 결국 모든 IT종사자들을 대상으로 조사를 진행한 것이 아니기 때문에 분명 다르거나 적용이 되지 않는 케이스들도 존재할 것 같다.\n그래도 책은 전체적으로 재미있게 읽었고 내가 재미있게 일할 수 있는 팀의 방향을 생각해보았는데 제시한 문화를 가진 팀이라면 정말 재미있게 일할 수 있을 것 같다는 생각이 드는 내용들이었다. 이 책을 통해 자신의 팀에 적용하고자 하는 분들이라면 한 가지 명심해야 할 부분이 있다. 책을 읽어보면 알겠지만 곳곳에서 언급하고 있는 내용인 제시하는 것을 답습하는 것이 아닌 이를 토대로 조직에 맞는 방향을 스스로 정해야 한다라는 부분을 중점에 두고 읽으면 좋을 것 같다.\n"},{"section":"Blog","slug":"/blog/books/large-scale-system-design-learned-from-virtual-interviews/","title":"가상면접 사례로 배우는 대규모 설계 기초","description":"가상면접 사례로 배우는 대규모 설계 기초를 읽고 정리한 글","date":"2022년 3월 21일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/large-scale-system-design-learned-from-virtual-interviews/preview_hu245306b9860b71fc1591d235505b5c88_54497_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"552\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/large-scale-system-design-learned-from-virtual-interviews\\/preview_hu245306b9860b71fc1591d235505b5c88_54497_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/large-scale-system-design-learned-from-virtual-interviews/preview_hu245306b9860b71fc1591d235505b5c88_54497_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/large-scale-system-design-learned-from-virtual-interviews\\/preview_hu245306b9860b71fc1591d235505b5c88_54497_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"나는 얇은 책이거나 꼭 소장할 책이 아니라면 주로 알라딘 에서 ebook으로 책을 구매해서 읽는다.(전공 서적은 주로 너무 두꺼워 집에 둘 곳이 없다\u0026hellip;)\n책을 구매한 날도 알라딘에 어떤 ebook이 등록되었나 보고 있었고, 이 책의 제목이 굉장히 흥미를 끌었고 바로 구매를 해버렸다. 처음 구매후, 11장 까지는 굉장히 재미있게 읽어가다가 점점 루즈해져갔고, 읽는것을 한동안 중단했었다. 업무가 바쁘기도 했고 다른 DDD책이 더 재미가 있었다.. 그러다가 최근 부터 이직준비를 조금씩 하고 있었는데, 이 때문인지 책을 다시 읽기 시작했고 11장 부터 끝까지 한번에 다 본 것 같다.\n책의 Flow는 장마다 같은 느낌으로 흘러가는데, 단독 시스템부터 대규모 시스템까지 한가지 주제를 가지고 면접을 본다는 가정하에 어떤 방법으로 설계를 해나가는지를 보여준다. 면접의 주제는 책의 목차에서도 알 수 있는데 다음과 같은 주제들이 있다.\n처리율 제한 장치 안정 해시 키-값 저장소 유일 ID 생성기 Short URL 웹 크롤러 알림 뉴스 피드 채팅 검색어 자동완성 유튜브 구글 드라이브 굉장히 다양한 주제를 다루고 있기도 하고, 설계의 방법은 정답이 없기때문에 주제마다 자세하게 들어가 설명을 진행하지는 않고 있다.\n이 때문에, 사람에 따라서는 많은 것을 배워 갈 수 없는 책일 수도 있다. (마지막 장인 16장에는 참고한 빅테크들의 블로그, 포스트, 논문 등의 링크가 첨부되어있어 자세한 부분은 해당 링크 참고하라고 한다..)\n하지만 나한테는 많은 도움이 된 책이었다. 아직 1년이 안된 주니어 개발자인 나의 입장에서 봤을때 면접질문은 주로 cs나 알고리즘, 나아가면 토이 프로젝트 중의 문제점 등이 되었다.\n실제 대규모 시스템은 물론, 기획자와 같이 협업을 했었던 적도 없기에 요구사항에 맞는 설계는 해본적이 없었기에 설계 면접은 어떤 방식으로 진행되는 것인지 상상이 안되었으며 답변도 어떻게 해야하는 지 미지의 영역이었다.\n그런데 이 책을 읽고 설계 면접의 목적이 이해가 되었고, 그에 맞게 커뮤니케이션을 통해 요구사항을 조절하는 방법 등 나에게는 많은 인사이트를 주는 책이었다.\n책 리뷰중에 신입개발자와 시니어보다는 3~5년차 개발자에게 가장 추천하는 책이라는 리뷰도 있는데, 어느정도는 공감하지만 나는 신입개발자도 한번쯤 읽어보면 꽤 많은 인사이트를 얻어갈 수 있을 것이라고 생각이 든다. 책 내용도 전체적으로 가볍기 때문에 슬슬 읽다보면 금방 읽는다.\n"},{"section":"Blog","slug":"/blog/projects/hugo/google-analytics/","title":"Google Analytics 추가하기","description":"hugo 블로그에 google analytics 추가하는 방법을 정리한 글","date":"2022년 2월 7일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/hugo/preview_hu637364512dd31ad226a1f796bce6289e_49062_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"115\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/hugo\\/preview_hu637364512dd31ad226a1f796bce6289e_49062_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/hugo/preview_hu637364512dd31ad226a1f796bce6289e_49062_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/hugo\\/preview_hu637364512dd31ad226a1f796bce6289e_49062_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"Hugo, Github Page","content":"개인마다 선택한 Theme에 이미 구글 애널리틱스 삽입 코드가 포함되어 있어 config.toml 파일에 추적코드만 삽입하면 되는 경우가 대부분일 것이다. 이 부분은 선택한 theme 문서를 잘 확인해보고 만약에 없다면 아래와 같은 방법으로 추가해줄 수 있다.\n1. Google Analytics 추적 코드 발급 구글 애널리틱스를 추가하기 위해서는 당연히 구글의 애널리틱스에 가입을 먼저 해야 한다. 가입을 하고 나면 계정과 속성을 등록해야 한다.\n계정은 일종의 그룹과 같은 느낌으로 계정하나에 여러 속성(사이트,도메인)를 관리 할 수 있다. 구글 고객센터 에 계정과 속성을 추가하여 추적 코드를 발급 받는 방법이 잘 나와있다.\n2. 추적 script 삽입 구글 애널리틱스 페이지에서 관리 \u0026gt; 속성 \u0026gt; 추적 정보 \u0026gt; 추적 코드 경로 따라 들어가면 범용 사이트 태그(gtag.js) 에 js를 그대로 이용해도 무방하나 나는 config.toml에서 추적코드를 관리하여 script를 유동적으로 변경되도록 작성해주고자 아래와 같은 코드를 head에 삽입 해주었다.\n\u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id={{ .Site.Params.googleAnalytics }}\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag(\u0026#34;js\u0026#34;, new Date()); gtag(\u0026#34;config\u0026#34;, \u0026#34;{{ .Site.Params.googleAnalytics }}\u0026#34;); \u0026lt;/script\u0026gt; 이때 이 스크립트를 삽입해주는 위치는 theme/테마명/layouts/partials/html-head.html 에 직접 추가해주어도 되고 theme 파일은 건드리기 싫다 하면 /layouts/partials/html-head.html 파일을 재정의 하여 추가해도 가능하다.\n나는 테마의 html-head.html에 {{- partial \u0026ldquo;head.html\u0026rdquo; . -}} 을 추가해준 후, head에 무언가 데이터를 추가해주고자 할때는 /layouts/partials/head.html 파일을 통해 추가해주었다. ( meta(og, twitter), 페이지네이션이나 갤러리 같은 추가 기능(css/js) 에 관한 부분들은 이 파일에 정의하고 theme의 파일은 건드리지 않는 방식으로 개발했다. )\n3. 포스팅 중에는 적용 안되게 하기 hugo server 명령어로 local 서버를 켜놓고 포스팅을 하다보면 md파일을 저장할때마다 페이지가 자동 새로고침이 되고 구글 애널리틱스 추적 스크립트가 살아있어 애널리틱스의 데이터를 신뢰하기 어려워 진다. 그렇기 때문에 개발(포스팅)중에는 구글 애널리틱스를 적용이 안되게 코드를 조금만 수정해보자.\n\u0026lt;!-- google analytics--\u0026gt; {{ if and ( ne (printf \u0026#34;%v\u0026#34; $.Site.BaseURL) \u0026#34;http://localhost:1313/\u0026#34; ) (.Site.Params.googleAnalytics) }} \u0026lt;!-- Global site tag (gtag.js) - Google Analytics --\u0026gt; \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id={{ .Site.Params.googleAnalytics }}\u0026#34; \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag() { dataLayer.push(arguments); } gtag(\u0026#34;js\u0026#34;, new Date()); gtag(\u0026#34;config\u0026#34;, \u0026#34;{{ .Site.Params.googleAnalytics }}\u0026#34;); \u0026lt;/script\u0026gt; {{ end }} 위와 같이 scipt 전에 if 문으로 localhost인지 확인하고 config.toml에 추적코드 속성이 있다면 삽입되게 코드를 수정하여 해결 할 수 있다.\n4. google analytics script 최적화 google analytics 추적 스크립트를 보면 알겠지만 외부 js를 로드하게 되며 이때 로딩되는 js는 약 73kb인데 만일 google analytics의 다양한 기능은 필요없고 단순히 뷰카운트가 목적이라고 하면 Minimal analytics 에서 제공하는 script를 통해 1.5kb 로 최적화를 할 수 있다.\n위에서 삽입했던 script 대신에 아래의 script를 삽입 해주면 간단하게 교체가 가능하다.\n\u0026lt;!-- google analytics--\u0026gt; {{ if and ( ne (printf \u0026#34;%v\u0026#34; $.Site.BaseURL) \u0026#34;http://localhost:1313/\u0026#34; ) (.Site.Params.googleAnalytics) }} \u0026lt;script\u0026gt; (function (a, b, c) { var d = a.history, e = document, f = navigator || {}, g = localStorage, h = encodeURIComponent, i = d.pushState, k = function () { return Math.random().toString(36); }, l = function () { return g.cid || (g.cid = k()), g.cid; }, m = function (r) { var s = []; for (var t in r) r.hasOwnProperty(t) \u0026amp;\u0026amp; void 0 !== r[t] \u0026amp;\u0026amp; s.push(h(t) + \u0026#34;=\u0026#34; + h(r[t])); return s.join(\u0026#34;\u0026amp;\u0026#34;); }, n = function (r, s, t, u, v, w, x) { var z = \u0026#34;https://www.google-analytics.com/collect\u0026#34;, A = m({ v: \u0026#34;1\u0026#34;, ds: \u0026#34;web\u0026#34;, aip: c.anonymizeIp ? 1 : void 0, tid: b, cid: l(), t: r || \u0026#34;pageview\u0026#34;, sd: c.colorDepth \u0026amp;\u0026amp; screen.colorDepth ? screen.colorDepth + \u0026#34;-bits\u0026#34; : void 0, dr: e.referrer || void 0, dt: e.title, dl: e.location.origin + e.location.pathname + e.location.search, ul: c.language ? (f.language || \u0026#34;\u0026#34;).toLowerCase() : void 0, de: c.characterSet ? e.characterSet : void 0, sr: c.screenSize ? (a.screen || {}).width + \u0026#34;x\u0026#34; + (a.screen || {}).height : void 0, vp: c.screenSize \u0026amp;\u0026amp; a.visualViewport ? (a.visualViewport || {}).width + \u0026#34;x\u0026#34; + (a.visualViewport || {}).height : void 0, ec: s || void 0, ea: t || void 0, el: u || void 0, ev: v || void 0, exd: w || void 0, exf: \u0026#34;undefined\u0026#34; != typeof x \u0026amp;\u0026amp; !1 == !!x ? 0 : void 0, }); if (f.sendBeacon) f.sendBeacon(z, A); else { var y = new XMLHttpRequest(); y.open(\u0026#34;POST\u0026#34;, z, !0), y.send(A); } }; (d.pushState = function (r) { return ( \u0026#34;function\u0026#34; == typeof d.onpushstate \u0026amp;\u0026amp; d.onpushstate({ state: r }), setTimeout(n, c.delay || 10), i.apply(d, arguments) ); }), n(), (a.ma = { trackEvent: function o(r, s, t, u) { return n(\u0026#34;event\u0026#34;, r, s, t, u); }, trackException: function q(r, s) { return n(\u0026#34;exception\u0026#34;, null, null, null, null, r, s); }, }); })(window, \u0026#34;{{ .Site.Params.googleAnalytics }}\u0026#34;, { anonymizeIp: true, colorDepth: true, characterSet: true, screenSize: true, language: true, }); \u0026lt;/script\u0026gt; {{ end }} "},{"section":"Blog","slug":"/blog/settings/home-server/","title":"Home Server 만들기","description":"집에 있던 남은 부품들로 집 서버 구축해보고 경험들을 기록한 글","date":"2022년 2월 4일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Settings","tags":"Server, Home Server","content":"집 서버를 만들게 된 배경 집 컴퓨터를 교체하고 지인의 컴퓨터를 교체해주면서 부품들이 여럿 남게 되는 상황이 생겼는데, 그냥 버리기 아까워 컴퓨터를 한대 더 조립을 하게 되었다. 사양은 Intel(R) Celeron(R) CPU G3930 에 4G, 250Gb 이다.\n컴퓨터를 조립 후 막상 사용할 곳이 없어 고민하던 중에 aws 프리티어도 끝났겠다 싶어 개발이나 테스트용으로 서버를 사용하면 좋을 것 같아 서버로 만들어보기로 했다.\n1. OS 설치 OS로는 aws에서도 사용했었던 Ubuntu Server20.04 LTS 로 설치하기로 했고 그에 맞춰 굴러다니던 usb를 이용해 부팅usb로 만들어 주었다.\nOS iso 다운(공식 홈페이지) 부팅 usb만드는 프로그램(Rufus) 위의 홈페이지에서 iso파일과 Rufus파일을 다운받을 수 있고, Rufus프로그램에 iso를 등록하여 usb를 부팅usb로 쉽게 만들 수 있다. 이렇게 만들어진 usb를 이용해 os를 설치 해주자!\n2. 인터넷 설정 집 구조상 내방까지 인터넷선을 끌어오면 굉장히 보기 안좋아지기 때문에 내방의 컴퓨터는 wifi를 이용하고 있다. 서버를 거실에 둘 수도 없기 때문에 서버에 무선랜카드를 추가하여 wifi를 잡도록 설정해야 한다.\n서버에 사용한 랜카드는 iptime A3000U모델이다. 랜카드를 꽂게 되면 서버는 해당 랜카드를 인식하지 못한다. iwconfig명령어를 입력하면 무선 인터페이스가 없는 것을 확인할 수 있다.\n1) A3000U 드라이버 설치 A3000U는 리얼텍 RTL8812BU 칩셋을 이용하고 있고 이 칩셋은 리눅스 커널에서 지원을 하지 않기 때문에 별도로 드라이버를 설치해주어야 한다. 이때 공식홈페이지에는 별도의 드라이버 파일이 존재하지 않기 때문에 github의 올라와있는 프로젝트 를 이용해 설치 해주면 된다.\n서버에 무선랜카드만 꼽았다면 인터넷이 되지 않기 때문에 따로 인터넷을 연결해준 뒤 설치해야 한다.\n# git clone $ git clone https://github.com/RinCat/RTL88x2BU-Linux-Driver $ cd RTL88x2BU-Linux-Driver # driver compile tools $ sudo apt-get install build-essential dkms # compile $ make clean \u0026amp;\u0026amp; make # install $ sudo make install 그리고 iwconfig를 입력해보면 랜카드가 잡힌 것을 볼 수 있다.\n만일 Nickname 옆에 disalbed가 존재하면 활성화가 되지 않은 상태로 ifconfig 무선인터페이스명 up 을 통해 활성화 해주면 된다. 이때 무선 인터페이스명은 iwconfig나, sudo lshw -C Network로 확인할 수 있다.\n나같은 경우는 wlx705dccfa5cb4 가 무선인터페이스명 이고 ifconfig wlx705dccfa5cb4 up을 입력하면 된다.\n2) WPA 프로그램 설치 $ sudo apt install wpasupplicant -y 3) wifi 설정 ubuntu 20 전에는 sudo vi /etc/network/interfaces 를 이용하여 정의 해주었었는데 20에서는 netplan을 통해 yaml파일로 정의해주면 된다.\n# vi로 yaml open sudo vi /etc/netplan/00-installer-config.yaml 다른 블로그들을 보면 **00-installer..**이 아닌 50-installer-\u0026hellip; 인 경우가 존재하는데 개인 마다 파일명은 다를 수 있는 것 같다. netplan/ 까지 입력후 tab을 이용하여 존재하는 파일을 열면 된다.\n만일 존재하지 않는다면 sudo netplan generate 으로 생성해주면 된다.\nnetwork: ethernets: enp2s0: dhcp4: true version: 2 # 아랫 부분을 추가해주면 된다. wifis: 무선인터페이스명: addresses: [192.168.0.142/24] gateway4: 192.168.0.1 nameservers: addresses: [8.8.8.8, 8.8.4.4] optional: true access-points: \u0026#34;wifi 명\u0026#34;: password: \u0026#34;wifi 비밀번호\u0026#34; dhcp: false 이때 공유기의 포트포워딩 기능을 이용하여 외부에서 접속을 할 수 있도록 해줄 건데 dhcp를 이용한다면 매번 ip가 바뀔 수 있기 때문에 고정 ip로 설정해주었다.\n4) 설정 적용 # apply sudo netplan apply 5) 설정 확인 # ip 확인 ip addr ip route # ping, nslookup 이용해 인터넷동작 확인 nslookup google.com ping google.com 3. 포트포워딩과 DDNS 공유기로 iptime를 이용하고 있다면 192.168.0.1에 접속하여 네트워크 설정을 해줄 수 있다.\nssh 접속을 위해 22, http를 위해 80,443번 이렇게 3개의 포트포워딩 규칙을 추가해 주었다.\n또한, ip를 이용하여 접속하기에 ip를 외우기도 어렵고 ip가 몇개월마다 주기적으로 바뀌기 때문에 그때마다 확인하기 어려울 수 있다. 이때 ddns 서비스를 이용하면 항상 같은 도메인으로 연결할 수 있다.\n4. 연결 확인 다른 컴퓨터나 어플을 이용하여 ssh접속을 한번 해보자!\n$ ssh 서버접속사용자명@ddns호스트이름 -p 5555 접속이 잘 되었다면 끝이다! 만일 접속이 안된다면 ssh가 설치가 되었는지 확인하고 방화벽에서도 허용되었는지 확인 해보자.\n5. 추가 설정 1) ssh-key 설정 # 외부에서 ssh-key 생성 $ ssh-keygen -t rsa -C \u0026#34;description 작성\u0026#34; Generating public/private rsa key pair. Enter file in which to save the key (/Users/ssun/.ssh/id_rsa): \u0026#34;키 파일명\u0026#34; Enter passphrase (empty for no passphrase): #비밀번호 Enter same passphrase again: 위 명령어를 통해 ssh-key를 생성할 수 있고 이 때 키 파일명, 키 파일명.pub 파일 두개가 생성된다. .pub 은 공개키이며 다른 한개의 파일은 비밀키이다.\n공개키를 server안으로 복사하여 이동시키자.\ncd ~ mkdir .ssh cd .ssh # .pub파일 해당 폴더에 이동후 파일명 변경 mv 파일명.pub authorized_keys 위처럼 파일명을 변경하거나 vi 편집기를 통해 authroized_keys를 새로 만들고 안에 .pub의 내용을 붙여넣어주면 된다.\n접속확인 ssh -i 비밀키명 gowoonsori@ddns명 -p5555 접속이 잘되었다면 성공이다! 이 후 나는 비밀번호 로그인을 허용하지 않도록 설정도 바꾸어 주었다.\n# config open sudo vi /etc/ssh/sshd_config # config 내용중 마지막 부분중 PasswordAuthentication을 no로 바꿔주자 # PasswordAuthentication yes PasswordAuthentication no 2) 원격 부팅/종료 현재 서버를 개발이나 테스트용으로 사용하다보니 항상 서버가 켜져있을 필요가 없으며 조금이라도 전기세를 막고자 원격으로 부팅과 종료를 할 수 있도록 설정해주었다.\n서버를 원격으로 종료시키는 건 쉽지만 부팅이 문제였는데 WOL기능을 이용하면 원격으로 킬 수 있겠지만 서버를 무선으로 작업을 했기 때문에 WOL을 사용은 할 수 없었다.\n고민 끝에 바이오스의 전원공급시 자동부팅 기능을 활용하기로 했다. 우선 어플을 이용해서 원격으로 전원을 공급/차단할 수 있는 플러그를 구매했다. 네이버에 스마트 플러그라고 검색하면 많은 제품이 검색되지만 가격이 꽤 나가기에 나는 알리에서 7천원대로 구매를 하여 설치했다.\n그후에 서버 바이오스에 들어가 자동 부팅기능을 활성화해주어야 하는데 이는 메인보드 제조사마다 부르는 기능명도 다르고 설정방법도 조금씩 다르기에 본인의 메인보드에 맞게 설정해주면 된다.\n제조사별 명칭 # ASUS Resotre ac power loss # ASROCK AC/Poser loss (advanced에 존재) # MSI Resotre after AC Power loss (advanced에 존재) # GigaByte AC BACK (Power에 존재) 이로써 외부에서 원격으로 서버를 부팅시킬 수 있게 되었다!\nReference 무선랜 드라이버 설치 고정 ip 설정 "},{"section":"Blog","slug":"/blog/books/developing-ms-starting-with-ddd/","title":"도메인 주도 설계로 시작하는 마이크로 서비스 개발","description":"도메인 주도 설계로 시작하는 마이크로 서비스 개발을 읽고 정리한 글","date":"2021년 12월 27일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/developing-ms-starting-with-ddd/preview_hu330aae7b6839dcb937820bc0b76bd72a_41121_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"315\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/developing-ms-starting-with-ddd\\/preview_hu330aae7b6839dcb937820bc0b76bd72a_41121_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/developing-ms-starting-with-ddd/preview_hu330aae7b6839dcb937820bc0b76bd72a_41121_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/developing-ms-starting-with-ddd\\/preview_hu330aae7b6839dcb937820bc0b76bd72a_41121_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"1. 마이크로서비스를 위한 조건 1) 업무 기능 중심의 팀 기술별로 팀이 나눠지게 되면 서비스 한개를 개발하는데 많은 의사소통이 필요하고 의사결정이 느려진다. 업무기능을 중심으로 다양한 기술을 가진 사람들이 하나의 팀이 되어 서비스를 만들어야 한다.\n2) 폴리글랏 프로그래밍 각각의 서비스에 맞는 효율적인 방법론과 도구, 기술을 찾아 적용.\n3) 개발 생명주기는 프로젝트단위가 아닌 제품 중심 초기에 모든 일정을 계획하고 요구사항 정의, 설계, 개발을 진행하는 것은 변경이나 새로운 아이디어를 포용하기 힘들다. 제품중심의 애자일 개방 방식을 채용하여 단기간의 스프린트로 계속한 개발/피드백으로 제품을 지속적으로 변화, 개선하는 것이 마이크로서비스이다.\n4) 통합 저장소가 아닌 데이터를 나눠 관리 과거에는 스토리지 가격 및 네트워크 속도에 따라 통합저장소를 많이 이용했지만 현재는 가격도 저렴하고 네트워크 대역폭이 매우 커졌다.\n폴리그랏 저장소 접근법 : 서비스별로 db를 갖도록 설계 ( 각 저장소가 서비스별로 분산 ) 다른 서비스의 저장소를 직접 호출할 수 없고 API를 통해서만 접근해야 한다는 의미\n문제점 : 데이터의 비즈니스 정합성를 맞춰야하는 데이터 일관성 문제\n해결방법 : 비동기 이벤트 처리를 통한 협업 (결과적 일관성) : 두 서비스의 데이터가 일시적으로 불일치하는 시점이 있고 일관성이 없는 상태지만 결국에는 두 데이터가 같아진다는 개념\n여러 트랜잭션을 하나로 묶지 않고 별도의 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념\n아래와 같이 메시지 큐를 이용\n5) 실패를 고려한 설계 테스트 환경 갖추기\n모니터링 체계 갖추기\n서킷 브레이커 패턴 : 각 서비스를 모니터링 하다가 한 서비스가 다운되거나 실패하면 이를 호출하는 서비스의 연계를 차단하고 적절하게 대응하는 것.\n넷플릭스는 카오스 몽키라는 일부러 장애를 발생시키는 도구를 만들어 탄력적인 아키텍처가 제대로 동작하는지 점검한다.\n2. MSA의 이해 1) 리액티브 시스템의 4가지 특성 응답성 : 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공 탄력성 : 장애가 발생하거나 부분적으로 고장나더라도 시스템 전체가 고장 나지 않고 빠르게 복구하는 능력 유연성 : 시스템의 사용량에 변화가 있더라도 균일한 응답성을 제공하는 것 ( 시스템 사용량에 비래하여 자원을 늘리거나 줄이는 능력) 메시지 기반 : 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향 2) 운영과 관리를 위한 플랫폼 패턴 서비스 디스커버리(서비스 레지스트리) 패턴 클라이언트가 여러개의 마이크로서비스를 호출하기 위해서 최적 경로를 찾아주는 라우팅(ex. Zuul), 부하분산을 위한 로드밸런싱(Ribbon) 기능이 필요하다. 이때 라우터는 최적의 경로를 탐색하기 위해 서비스 명칭에 해당하는 IP를 알아야 하는데 유동 IP의 정보를 매핑해서 보관할 저장소(Eureka)도 필요하는데 이러한 패턴을 서비스 레지스트리 패턴이라고 한다.\nNetflix OSS 뿐만이 아닌 쿠버네티스 DNS 및 서비스로도 제공하는 기능으로 다른 솔루션들도 존재\nAPI 게이트웨이 패턴 다양한 클라이언트가 다양한 서비스에 접근하기 위해 단일 진입점을 만들어 두는 패턴으로 L4와 같이 하드웨어로 구현할 수도 있고 소프트웨어로 구현할 수도 있다. API 게이트웨이는 아래와 같은 기능을 제공한다.\n레지스트리 서비스와 연계한 동적 라우팅, 로드 밸런싱 권한 서비스와 연계한 인증/인가 로그 집계 서비스와 연계한 로깅 메트릭 트레이싱 서비스와 연계한 서비스 추적 모니터링 서비스와 연계한 장애 격리 대표적인 솔루션으로 Spring API Gateway Service나 k8s service와 ingress resources가 있다.\nBFF 패턴 (Backend for Frontend) 다양한 종류의 클라이언트를 위해 특화된 처리를 위한 패턴으로 프런트엔드의 유형에 따라 각각 진입점을 두는 패턴.\n처리를 수행하는 BFF를 두고 이후에 통합적인 API 게이트웨이를 둠으로써 공통적인 인증/인가, 로깅 등을 처리하는 방식으로 구성\n외부 구성 저장소 패턴 Config원칙 : 애플리케이션이 배포되는 환경(스테이징, 프로덕션, 개발, 테스트)이 매번 달라지기 때문에 코드에서 사용하는 환경 설정 정보는 코드와 완전히 분리되어 관리해야 한다는 원칙.\n한마디로 클라우드에서 운영되는 애플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안된다는 원칙\n인증/인가 패턴 중앙 집중식 세션 관리 : 서비스들은 언제든 스케일아웃할 수 있으므로 각자의 서비스에 저장하는 것이 아니라 공유저장소에 세션을 저장 클라이언트 토큰 : 세션은 중앙 서버에 저장되고 토큰은 사용자의 브라우저에 저장되어 사용자의 신원 정보를 포함하고 있기 때문에 서버에서 인가 처리를 할 수 있다. API 게이트웨이를 사용한 클라이언트 토큰 : Auth service로 별도로 인증/인가를 처리하는 전담 서비스를 두어 인증/인가의 처리를 위임할 수 있다. Auth serivce를 이용하면 각 리소스 서비스가 자체적으로 인증/인가를 처리하지 않고 자신의 역할에 집중할 수 있도록 해준다. 서킷 브레이커 패턴 하나의 서비스에 장애가 발생했을때 다른 서비스가 영향을 받을 수 있는데 이때 장애가 발생한 서비스를 격리하여 유연하게 처리할 수 있도록 해주는 패턴\n서비스A가 서비스B를 호출하여 서비스를 할때 서비스B에서 장애가 발생하면 동기 요청 특성상 A까지도 장애가 발생한 것 처럼 느끼게 되는데 연속 실패 횟수가 임계값을 초과하면 fallback 메서드를 통해 대체응답을 보내는 방법\n모니터링과 추적 서비스 모니터링(Hystrix Dashboard), 분산 트레이싱 서비스(Zipkin) 등 다양한 솔루션을 활용하여 모니터링과 장애, 지연구간을 추적하여 개선할 수 있도록 해준다.\n로그 집계 패턴 로그는 시작과 끝이 고정된 것이 아니라 서비스가 실행되는 동안 계속 흐르는 흐름으로 이벤트 스트림으로 처리해야 한다.\n서비스 메시 패턴 문제 해결을 위한 기능(서비스 탐색, 서킷 브레이크, 추적, 로드 밸런싱) 등을 비즈니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 패턴\n사이드카 패턴 : 모는 서비스 컨테이너에 추가로 사이드카 컨테이너가 배포되는 패턴으로 각 서비스를 연계할 때 한 서비스가 다른 서비스를 직접 호출하지 않고 사이드카인 프록시를 통해 연계해서 개발자가 별도의 작업 없이 관리 및 운영에 대한 서비스 등을 적용\n3) 애플리케이션 패턴 UI 컴포지드 패턴 ( 마이크로 프런트엔드 패턴 ) 프론트엔드도 기능별로 분리하고 프레임 형태의 창을 통해 여러 프레임을 조합하여 동작하게 한다. 이 부모 서비스는 틀만 가지고 있고 실제 각 기능 표현은 마이크로 프론트엔드 조각이 구현하게 하고 이 각각의 프론트엔드들은 여러개의 백엔드 마이크로 서비스API를 호출한다.\n통신 패턴 동기 통신 : 일반적인 REST API같은 방법.\n호출받은 마이크로서비스에 장애가 발생하면 호출한 서비스는 반응이 올 때까지 기다리게 되어 장애가 연쇄적으로 발생할 우려가 있다.\n비동기 통신 : 메시지 큐를 통해 event driven 방식으로 구현\nkafka,rabbitMQ, ActiveMQ 등의 메시지 브로커를 이용하거나, AWS의 SQS/SNS, Azure의 EventHub/EventGrid 등의 완전관리형 클라우드 벤더를 이용해 구현할 수 있다.\n저장소 분리 패턴 각 서비스는 각자의 비즈니스를 처리하기 위해 데이터를 직접 소유한다는 것. 자신의 데이터를 다른 서비스에 직접 노출하지 않고 API를 통해서만 노출하기 때문에 정보은닉/폴리그랏 저장소를 만족하고 데이터를 토한 변경의 파급효과를 줄일 수 있다.\n분산 트랜잭션 처리 패턴 전통적인 방법은 2단계 커밋을 통해 구현할 수 있지만 이 방법은 각 서비스에 잠금이 걸려 발생하는 성능 문제 탓에 효율적인 방법이 아니며 MongoDB같은 NoSQL은 2단계 커밋을 지원하지 않는다.\nSaga 패턴 : 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴으로 분산된 여러 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상트랜잭션을 통해 데이터의 정합성을 맞춘다.\n보상 트랜잭션? 어떤 서비스에서 트랜잭션 처리에 실패할 경우 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션\n결과적 일관성? 모든 비즈니스 규칙들이 실시간으로 일관성을 맞출 필요가 없다. 예를 들어, 결제 주문이 완료된후 메일을 보내는 시스템인데 주문이 몰리는 블랙프라이데이라고 가정을 해보자. 수만개의 주문이 발생하는데 결제 서비스에서 타사 외부 연동 장애가 발생해 더는 주문을 받을 수 없는 상황이 발생할 수 있는데 비즈니스 관점에서 보면 이를 모두 순차적으로 처리하기보다 주문을 먼저 많이 받아놓는 것이 더 좋을 수도 있다. 그 후 결제 서비스가 복구되었을때 처리하여 결과적으로는 일관성을 만족하게 되는 것이 더 좋을 수 있다.\n이 처럼 데이터의 일관성이 실시간으로 맞지 않더라도 어느 일정 시점이 되었을때 일관성을 만족해도 되는 것.\nCQRS 패턴 Command Query Responsibility Segregation의 약자로 명령 조회 책임 분리를 의미.\n하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식으로 변화시켜 쓰기 서비스와 조회 서비스를 분리하거나, 물리적으로 쓰기 트랜잭션용 저장소와 조회용 저장소를 따로 준비하여 쓰기 시스템의 부하를 줄이고 조회 대기 시간을 줄이는 방법.\n이벤트 소싱패턴 저장소에 저장하는 것과 메시지를 보내는 것이 원자성을 지녀야 하는데 이 과정에서 객체의 상태변화를 메시지로 발행하고 객체 상태를 관계형 db에 저장하는 경우 SQL질의어로 변환해서 처리하기가 매우 번거롭고 까다로우며 성능이 빠르지 않은데 이를 해결할 수 있는 패턴\n비즈니스로직을 모두 수행후 최종 결과값을 저장하는 방식이 아닌 상태 트랜잭션 자체를 저장하는 전략으로 상태 변경 이벤트를 계산해서 데이터 모델로 변경하지 않고 바로 이벤트 저장소에 그대로 저장하는 방법. 메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용해 쓰기 속도가 훨씬 빠르다.\n만일 현재 시점의 상태가 필요하다면 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산하면 되며, 이것이 부담된다면 매일 자정에 상태를 계산한 후 스냅샷으로 저장하여 이 스냅샷 이후의 트랜잭션만 처리하면 된다. 이렇게 되면 특정 시점의 상태를 재현할 수 있기 때문에 로그 데이터를 기록할 필요도 없다.\n이렇게 되면 삭제/수정없이 입력/조회만 일어나기 때문에 명령 서비스를 확장해도 동시 업데이트/교착 상태가 발생하지 않는다.\n3. 애플리케이션 아키텍처 1) 레이어드 아키텍처 프레젠테이션 : 화면 표현 및 전환 처리 비즈니스 로직 : 비즈니스 개념 및 규칙, 흐름제어 데이터 액세스 : 데이터 처리 규칙 상위 계층이 하위 계층을 호출하는 단방향성 유지 상위 계층은 하위의 여러 계층을 모두 알 필요없이 바로 밑 계층만 활용 상위 계층이 하위 계층에 영향을 받지 않게 구성 하위 계층은 상위 계층을 알지 못하게 구성 계층간의 호출은 인터페이스를 통해 호출하도록 구성 구현 방식 규칙 5에 의해 각 계층의 인터페이스를 통해 호출하도록 구성했다고 해보자. 데이터 액세스 계층의 인터페이스를 이용하여 비즈니스 로직을 처리한다고 할때 DIP는 만족한 것 처럼 보인다. 하지만 OCP에 문제가 발생한다. 각 계층이 자기 자신의 인터페이스를 정의하고 소유하고 있는 구조로 하위 계층의 유형이 추가되어 확장되어 인터페이스가 바뀌게 되면 이를 사용하는 닫혀있어야 할 상위 계층에도 영향이 가기 때문이다.\n저수준이 가지고 있는 인터페이스를 고수준 계층으로 옮김으로써 DIP와 OCP를 해결할 수 있다.\n2) 헥사고날 아키텍처 https://gowoonsori.comimages/books/developing-ms-starting-with-ddd/hexagonal.PNG does not exist\r현대 애플리케이션은 위처럼 단순하게 3가지의 계층만 존재하는 것이 아니라 더 다양한 인터페이스,시스템 유형, 저장소 들이 존재하기 때문에 한계가 존재한다.\n앨리스테어 콕번이 제시한 아키텍처로 포트 \u0026amp; 어댑터 아키텍처라고도 한다.\n고수준의 비즈니스 로직을 표현하는 내부 영역과 인터페이스 처리를 담당하는 저수준의 외부영역으로 분리하는 아키텍처. 그리고 외부 영역과 연계되는 포트를 가지고 있다.\n포트\n헥사고날의 기본 어댑터로 인터페이스 라고도 불린다.\n인바운드 포트 : 내부 영역의 사용을 위해 호출된 api로 외부영역의 인바운드 어댑터가 호출한다. 아웃바운드 포트 : 내부 영역이 외부를 호출하는 방법을 정의 어댑터\n헥사고날의 보조 어댑터로 인프라 라고도 불린다.\n인바운드 어댑터 : 외부에서 들어오는 요청을 처리하는 어댑터로 외부영역이 소유. 컨트롤러, 커맨드 핸들러, 이벤트 메시지 구독 핸들러 등이 될 수 있다. 아웃바운드 어댑터 : 비즈니스 로직에 의해 호출되어 외부와 연계. DAO, 이벤트 발행 클래스, 외부 서비스 호출하는 프록시 등이 될 수 있다. 3) 클린 아키텍처 로버트 C.마틴은 소프트웨어는 행위 가치보다 구조 가치가 더 중요하다라고 말했는데 구조가치가 소프트웨어를 더 부드럽게 만들기 때문이라고 한다.\n엔티티 : 가장 중앙에 위치한 부분으로 비즈니스 업무 규칙이 정의 되어 있는 부분 유스케이스 : 어플리케이션 업무 규칙으로 엔티티 내부의 핵심 업무 규칙을 호출하며 시스템을 사용하는 흐름을 담는다. 세부사항 : 위 두개을 제외한 모든 영역으로 입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토콜들이 될 수 있다. 이때 세부사항과 유스케이스의 관계를 의존 관계 역전의 원칙을 이용해 플러그인처럼 유연하게 처리해야 한다. 로버트 C.마틴은 소프트웨어는 부드러워야 한다고 했다. 클라우드 플랫폼이나 k8s같은 외부 아키텍처를 적용하는 것만으로도 처음에 는 꽤나 유연해 질 수 있는데. 시스템의 핵심은 결국 소프트웨어이고 실제로 비즈니스를 제공하는 것은 마이크로 서비스이다. 영리하고 빠른 비즈니스를 제공하기 위해서는 핵심(내부)가 유연해야 한다. 내부가 유연해야 마이크로서비스 간의 관계도 느슨하게 구현할 수 있고 이러한 구조여야 비로소 서비스를 독립적으로 확장, 변경, 배포 할 수 있다.\n4) 추천하는 추가 도서 마이크로서비스 패턴(길벗) 클린 아키텍처(인사이트) 엔터프라이즈 애플리케이션 아키텍쳐 패턴(위키북스) 4. 개발 프로세스 1) 스크럼 기본 생명주기는 스크럼의 스프린트 활용. 점진/반복적인 생명주기로 1~4주 동안 실행되며 백로그라는 일감 목록을 기반으로 각 스프린트에 배분되어 매 스프린트마다 실제 동작하는 소프트웨어를 시연하고 피드백을 얻는다.\n스크럼 팀 : 스프린트가 진행되는 팀으로 다기능 팀으로 구성. 스크럼 미팅 : 매일 아침 각자의 일을 투명하게 공유 스프린트 계획 수립 : 모든 요구사항은 백로그에 담기고 일정에 맞게 스프린트를 몇번 수행할 것인지 결정. 스프린트 횟수가 결정되면 제품 백로그에 담긴 백로그를 각 스프린트에 적절히 배분한다. 시연 : 스프린트 마지막 활동중 하나로 초기에 정의한 백로그가 모두 구현되고 그 요건을 만족하는지 확인하고 피드백시간 회고 : 팀원들이 자기 스스로를 돌아보는 과정으로 설계 및 개발 과정에서 좋았던 점/안 좋았던점등을 공유하고 개선시키는 활동 2) 아키텍처 정의와 마이크로서비스 도출 아키텍처 정의 : 내부 영역과 외부 영역으로 구분해서 개발할때 외부 영역은 언제든지 교체될 수 있으므로 핵심인 내부영역에 집중하고 외부영역은 천천히 결정해도 된다. 변화에 염두에 둔 유연한 구조를 초기에 정의해야 한다. 마이크로서비스 도출 : 개발에 들어가기 위해 개발할 전체 마이크로서비스들을 파악하는 작업으로 마이크로서비스들을 도출하고 그것들 간의 대략적인 매핑관계를 정의후에 개발 우선순위에 근거해 스프린트를 진행해야 한다. 3) 개발 공정 백엔드 API 설계를 가장 우선적으로 해 프론트엔드 영역과 협의 및 조정을 해야 프론트엔드도 이를 기반으로 설계를 진행할 수 있다.\n도메인 모델과 데이터 모델을 설계.\n이때 UML등을 활용해 설계 모델을 작성하고 이를 코드로 변환하는 OOAD방식과는 달리 간략한 도메인 모델 등을 화이트보드나 포스트잇 등의 단순한 도구로 작성해서 공유한 후 개발을 진행\n프론트엔드 UI 레이아웃을 정의하고 API를 통해 받은 데이터를 어떻게 표현할 것인지 정의.\n빌드 및 배포 지속적으로 빌드되고 자동으로 배포되도록 빌드 및 배포환경을 자동화해 언제라도 현재 진행된 만큼의 실제로 돌아가는 소프트웨어를 확인할 수 있어야 한다.\n4) 추천하는 추가 도서 소프트웨어 장인(길벗) 5. 마이크로서비스 설계 1) 마이크로 서비스 도출 방법 비즈니스 능력에 근거해 도출 비즈니스의 흐름에 따라 비즈니스를 최상위에서 하위까지 대/중/소의 크기로 분리하고 수행하는 일들을 정렬하는 방식으로 도출하면 직관적으로 서비스를 식별할 수 있다. 이러한 방식은 전체적인 대략의 비즈니스를 이해할 때는 유용하지만 서비스 간의 관계를 파악하거나 서비스의 구체 기능과 연관된 서비스가 관리할 독립적인 데이터를 식별하기에는 미흡하다.\nDDD의 바운디드 컨텍스트 기반 도출 마이크로서비스를 도출할 때 서비스가 소유권을 가진 데이터를 독립젹으로 식별하는 것이 중요한데 비즈니스 능력에 근거한 도출 방식은 기능과 데이터가 분리되고 하나의 통합 데이터가 여러기능에서 사용되도록 모델링 되는 방식으로 비즈니스를 처리하는 기능과 기능에 영향을 받는 데이터가 분리되는 경향이 있다.\nDDD는 문제 영역인 하위 도메인 마다 별도의 도메인 모델(바운디드 컨텍스트)로 정의하는 방법으로 도메인 모델은 각 업무에 특화된 유비쿼터스 언어로 정의되고, 그 업무에 특화된 개념으로 구성된다.\n2) 설계 도메인과 서브도메인 하나의 큰 도메인을 전략적으로 중요한 것들을 찾아 중요도에 따라 도메인을 나누고, 각 도메인을 각각 하나씩 해결하는 방법을 기본으로 삼는데 이때 많은 개념들이 하나로 엮인 복잡한 비즈니스 도메인을 논리적으로 구분되는 여러 개의 하위 영역으로 분리해야 한다. 이렇게 분리된 하위 도메인을 서브도메인이라고 한다.\n서브 도메인은 중요도에 따라 핵심 서브도메인, 지원 서브도메인, 일반 서브도메인으로 나누니다.\n핵심 서브도메인 : 다른 경쟁자와 차별화를 만들 비즈니스 영역 지원 서브도메인 : 비즈니스에 필수적이지만 핵심은 아닌 부분 일반 서브도메인 : 비즈니스적으로 특화된 부분은 아니지만 전체 비즈니스 솔루션에는 필요한 부분 유비쿼터스 언어와 도메인 모델, 바운디드 컨텍스트 특정 도메인에서 해당 도메인에서의 의도를 명확히 반영하고 도메인의 핵심 개념을 잘 전달할 수 있는 언어를 유비쿼터스 언어라고 한다.\n특정 도메인에 특화된 개념이 유비쿼터스 언어로 정의되고, 이 개념들은 서로 관계를 맺는데 이와 같은 관계를 표현한 모델을 도메인 모델이라고 한다.\n각 도메인 모델과 다른 도메인 모델 간의 경계에서 사용하는 언어와 개념이 상이한 경계가 존재하는데 이런 도메인의 경계를 바운디드 컨텍스트라고 한다.\n컨텍스트 매핑 바운디드 컨텍스트를 식별할 때 각 컨텍스트는 내부적으로는 응집성이 높고, 다른 컨텍스트와는 의존관계가 낮도록 설계를 한다. 이때 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하면 비즈니스 수행을 위해 여러 개의 컨텍스트가 연계해야 하는 경우가 발생한다. 이러한 컨텍스트 간의 의존관계를 컨텍스트 매핑이라고 한다.\n컨텍스트 매핑 패턴\n공유 커널 바운디드 컨텍스트 사이에 공통적인 모델을 공유하는 관계로 두 개 이상의 팀에서 작지만 공통의 모델을 공유하는 관계. 보통 공통 라이브러리 등이 여기에 해당 되고 이 부분이 변경되면 여러 컨텍스트에 영향을 미치므로 공유하는 모델의 코드 빌드를 관리하고 테스트하는 것은 한 팀이 맡아 수행해야 한다. 소비자와 공급자 공급하는 컨텍스트를 UPSTREAM, 소비하는 컨텍스트를 DOWNSTREAM으로 표시하고 데이터의 흐름은 반드시 UPSTREAM에서 DOWNSTREAM으로만 흐른다. UPSTREAM이 변화가 생기면 DOWNSTREAM은 변화를 따라야한다. 준수자 (Confirmist) 소비자와 공급자 형식과 유사하지만 upstream이 downstream의 요구를 지원하지 않거나 못할때 상류팀에서 제공하는 모델을 그대로 사용하는 방법 충돌 방지 계층 (Anti-Corruption Layer) downstream이 upstrea의 모델에 영향을 받을 때 downstream의 고유 모델을 지키기 위해 번역 계층을 만들어 두는 것으로 downstream의 독립성을 유지 할 수 있다. MSA를 적용하는 시스템을 레거시 시스템과 통합하기 위해 주로 사용 공개 호스트 서비스(Open Host Service) downstream의 컨텍스트가 upstream 컨텍스트에서 제공하는 기능을 용이하게 사용할 수 있도록 바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의하는 방법 공유된 API가 예이다. 발행된 언어 (Published Language) downstream의 컨텍스트가 upstream 컨텍스트가 제공하는 기능을 사용하게 하기 위한 간단한 사용과 번역을 가능케 하는 문서화된 정보 교환 언어 XML이나 JSON 스키마로 표현될 수 있으며, 주로 공개 호스트 서비스와 짝을 이뤄 사용된다. 컨텍스트 맵 개념적인 컨텍스트 맵 연관관계에 있는 두 컨텍스트 사이에 선을 그려 매핑관계를 표시한 다이어그램으로 매핑을 위한 구체적인 기술 등이 정의되지 않은 상태 구체적인 컨텍스트 맵 매핑을 구현할 방안이 구체화 되어 매피 유형들을 구체적으료 표현한 매핑 다이어그램 이벤트 스토밍을 통한 마이크로서비스 도출 이벤트 중심으로 이해관계자들이 모여 브레인 스토밍하는 워크숍을 이벤트 스토밍이라고 한다. 각 관점을 논의하며, 그 차이점을 이해하고 공유할 수 있다는 점에서 기존 방법론에서 장기간 단절하며 수행했던 요구사항, 프로세스 모델링, 설계를 진행하는 과정을 뛰어넘는 민첩성과 효율성을 보여준다.\n다양한 스티커, 마커 펜, 라인 테이프 등을 이용해 깨끗한 벽이 있는 넓은 공간에서 서로 토론을 통해 의견을 맞춰나가는 것이 중요하다.\n스티커 유형별 의미\n유형 크기/색깔 설명 도메인 이벤트 오렌지색 발생한 사건. 과거시제동사로 표현 커맨드 파란색 도메인 이벤트를 트리거하는 명령 외부 시스템 핑크색 도메인 이벤트가 호출하거나 관계가 있는 레거시 또는 외부 시스템 액터 작은 노란색 개인 또는 조직의 역할 애그리거트 노란색 도메인 이벤트와 커맨드가 처리하는 데이터 / 상태가 변경되는 데이터 정책 라일락 색 이벤트 조건에 따라 진행되는 결정 읽기모델 초록색 도메인 이벤트 액터에게 제공되는 데이터 사용자 인터페이스 흰색 스케치 형태의 화면 레이아웃 핫스폿 자주색 의문, 질문, 미결정 사항 이벤트 스토밍 순서\n도메인 이벤트 찾기 데이터나 데이터의 구조가 아닌 비즈니스 흐름에서 발생한 이벤트에 초점을 두는 것이 중요하다. 이벤트명은 과거형 동사로 작성 비즈니스의 어떤 상태를 생성, 변경, 삭제하는 요소 예) 회원가입됨 / 회원정보 수정됨 / 회원정보 삭제됨 외부 시스템/외부 프로세스 찾기 시스템의 기능 구현을 위해 연계가 필요한 시스템을 모두 도출 시스템 이름을 명사형태로 작성 예) 결제 시스템 / 이메일 시스템 커맨드 찾기 이벤트를 동작하게 하는 커맨드를 도출 도메인 이벤트를 동작하게 하는 것으로 명령형(동사)로 작성 하나의 커맨드에 의해 동시 또는 연속해서 발생하거나 조건에 따라 여러개의 다른 이벤트가 발생할 수 있다. 예) 회원가입됨 -\u0026gt; 회원가입 / 회원정보 수정됨 -\u0026gt; 회원정보 수정 핫스팟 찾기 진행과정 중에 의문사항이나 결정하기 힘든 사항, 다른 부서에 문의할 필요가 있는 사항등을 정의 예) 상품 주문 취소에서 취소 가능 시점과 같은 경우 액터 찾기 추상적으로 식별하지 않고 비즈니스를 수행하는 구체적인 역할을 고려해서 도출 회원/관리자가 아닌 판매자, 구매자, 상품 관리자, 배송 관리자, 시스템 관리자와 같이 명확하게 도출 커맨드의 왼쪽 아래에 붙여 커맨드를 조작한다는 것을 명시적으로 표현 애그리거트 정의하기 커맨드와 도메인 이벤트가 영향을 주는 데이터 요소를 애그리거트라고 한다. 도메인의 실체 개념을 표현하는 객체인 엔티티 액터와 마찬가지로 구체적으로 도출 커맨드와 이벤트 사이의 상단에 겹쳐서 붙인다. 바운디드 컨텍스트 정의하기 같거나 유사한 애그리거트를 완전히 다른 애그리거트와 구분해서 경계를 식별 컨텍스트내에 여러개의 애그리거트 이름이 있는 경우 전체를 아우를 수 있는 대표 이름을 정한다. 예 ) 회원 컨텍스트(회원 애그리거트) / 구매 컨텍스트(주문아이템, 주문, 결제) / 상품 컨텍스트(상품, 재고, 카테고리), 배송 컨텍스트(배송, 발송, 수령) 컨텍스트 매핑하기 식별한 바운디드 컨텍스트간의 관계를 동기/비동기 호출로 나누어 표현 이렇게 도출된 바운디드 컨텍스트가 마이크로 서비스의 후보가 되고 아래와 같은 질문을 통해 최종 확정할 수 있다.\n(비즈니스 측면) 비즈니스 프로세스를 수행하기 위한 하나의 맥락의 단위로 구분될 수 있는가? (데이터 관점) 마이크로서비스별로 분리된 데이터를 정의할 수 있는가? (운영 조직 측면) 하나의 팀이 독립적으로 운영 가능한 단위인가? (배포 측면) 독립적으로 배포 가능한 단위인가? (변경 영향도) 변경시 영향을 받는 마이크로서비스가 존재하는가? (클라우드/MSA 도입 목적 측면) 도입을 통한 기대효과를 충분히 활용할 수 있는가? 3) 상세설계 프런트엔드 모델링 프런트 아키텍처 정의 사용자 요건에 적절한 아키텍처 정의 모바일, 앱, 웹 등을 고려하고 UX 고려 표준 레이아웃 정의 목록, 조회, 수정, 삭제 등의 대표적인 업무 화면 유형을 정의하고 표, 그리드, 입출력 폼, 표준 버튼 등 정의 모바일, 웹, 앱 등 채널에 맞게 별도로 정의할 수도 있다. UI레이아웃 설계 각 기능을 만족할 UI를 정의하고 화면에 입출력될 속성 정보를 식별하고 수행할 버튼등을 정의 UI 디자인 및 UI레이아웃 반영 이벤트 설계 화면의 이벤트 변화에 따라 백엔드 API를 호출하는 방식을 정의 백엔드 모델링 헥사고날 아키텍처를 적용해 외부 영역과 내부 영역으로 구분되어 진행된다.\n이벤트 스토밍의 커맨드는 헥사고날의 인바운드 어댑터의 하나인 REST API가 되고, 애그리거트는 헥사고날의 내부 영역인 도메인 모델이 되며, 도메인 이벤트는 헥사고날 외부 영역의 아웃바운드 메시지 처리 어댑터의 처리 대상이 되고, 외부 시스템은 마찬가지로 아웃바운드 어댑터가 호출해야 할 외부 연계 시스템으로 매핑된다.\n외부 영역 설계는 프런트엔드와 연계되는 API 설계로 내부 영역은 비즈니스 로직을 구현하는 도메인 모델링, 데이터 모델링으로 구체화 되어 진행된다.\nAPI 설계\n프런트엔드의 요구사항을 충족하도록 정의 인바운드 어댑터로써 어떠한 호출 방식도 허용되는 유연한 공간 도메인 모델링\n엔티티\n다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체 식별자는 고유하되 엔티티의 속성 및 상태는 계속 변할 수 있다. 도메인에서 개별성이 있는 개념을 엔티티로 시별하며, 고유 식별자와 변화 가능성이 엔티티와 값 객체를 구분하는 차이점 예) 구매라는 애그리거트에서 구매번호라는 식별자로 구분이 가능하고, 구매품/수취자 등이 개별적으로 변경될 수 있기 때문에 엔티티로 모델링 값 객체(VO)\n각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링\n개념적 완전성? 값 객체를 구성하는 하나 이상의 특성들이 서로 연관되어 전체 의미를 이루는 것. 예를 들어 한국 돈 1000원은 1000이라는 숫자와 한국의 통화기준인 원이라는 특성이 결합되어 의미를 전달\n개별 속성이 별개로 수정되지 않고 전체 객체가 한 번에 생성되거나 삭제되는 객체\n특성\n반 버논은 아래와 같이 값 객체의 특성을 정의\n도메인 내의 어떤 대상을 측정하고, 수량화하고 설명 관련 특징을 모은 필수 단위로 개념적 전체를 모델링 측정이나 설명이 변경될 땐 완벽히 대체 가능하다. 다른 값과 등가성을 사용해 비교할 수 있다. 값 객체는 일단 생성되면 변경 할 수 없다. 표준 타입\n대상의 타입을 나타내는 서술적 객체 엔티티나 값 객체의 속성을 구분하는 용도로 사용 예) 전화번호가 집 전화인지 핸드폰, 회사 전화번호인지 구분하기위한 객체로 JAVA에서는 열거형으로 정의 애그리거트\n엔티티와 값 객체들의 묶음이 애그리거트\n애그리거트 내의 엔티티, 값 객체, 애그리거트는 비즈니스 의존관계를 맺고 있어 비즈니스 정합성을 맞출필요가 있기에 트랜잭션의 기본 단위가 된다.\n애그리거트 내 가장 상위 엔티티를 애그리거트 루트로 정하고 이를 통해서만 애그리거트 내의 엔티티나 값 객체를 변경\n다른 애그리거트를 참조해야 할 필요가 있다면 애그리거트 루트의 식별자를 통해 참조\n다른 애그리거트의 엔티티나 값 객체를 직접참조하게 되면 나중에 별도의 마이크로서비스로 분리하려고 할때 분리가 힘들다.\n도메인 서비스\n도메인의 비즈니스 로직 처리가 특정 엔티티나 값 객체에 속하지 않을 때 단독 객체를 만들어 처리하게 하는데, 이를 도메인 서비스라고 한다. 상태를 관리하지 않고 행위만 존재 도메인 로직을 처리할 때 엔티티나 값 객체와 함께 특정 작업을 처리하고 상태를 본인이 가지고 있지 않고 엔티티나 값 객체에 전달 도메인 이벤트\nDDD및 이벤트 스토밍에서 맗나는 도메인 이벤트의 구현 객체 서비스 간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링 예) 주문 서비스에서 주문 트랜잭션 처리를 통해 주문/주문아이템 엔티티가 생성되어 저장됨과 동시에 구매완료됨이벤트를 발행 -\u0026gt; 구매완료됨이벤트에는 주문됨 상태를 나타내는 주요 주문 정보를 포함 4) 추천하는 추가 도서 UML과 패턴의 적용 (홍릉과학출판사) 도메인 주도 설계 (위키북스) 도메인 주도 설계 핵심 (에이콘) 도메인 주도 설계 철저 입문 (위키북스) Introducing EventStorming (Leanpub) 6. 요약 전체적으로 DDD에대해 얇고 넓게 설명하는 책인 것 같고 내용만 보면 구글링으로 충분히 습득할만한 지식들이다. 하지만, 목차별로 그림들을 삽입하여 이해하기 쉽게 설명해주고 있고 7장부터는 도서 대출 서비스를 예시로 DDD방식의 개발 프로세스를 설명해주고 있어 처음 접하는 개발자라면 읽어볼만한 책인것 같다.\n"},{"section":"Blog","slug":"/blog/java/completeablefuture/","title":"CompletableFuture","description":"java8에 추가된 CompletableFuture에 대해 설명합니다.","date":"2021년 12월 8일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"1. Java에서의 Concurrent Concurrent 소프트웨어란? 동시에 여러 작업을 할 수 있는 소프트웨어\n멀티 프로세싱 ( ProcessBuilder ) 멀티 스레딩 ( Thread/Runnable ) 1) 동시성(Concurrency) vs 병렬성(Parallelism) 동시성? 싱글코어에서 멀티 스레드를 동작시키기 위한 방식으로 멀티 태스킹을 위해 여러개 스레드가 번갈아가면서 실행. 한마디로 동시에 실행되는 것처럼 보이는 것.\n멀티스레드로 동시성을 만족시킬수 있는 거지 동시성이 멀티스레드는 아님. 코틀린의 코루틴은 싱글스레드로 동시성을 만족\n병렬성? 2개이상의 task가 있을때 각 task가 물리적인 시간으로 동시에 실행이 가능. 멀티코어에서 멀티스레드를 동작시키는 방식으로 한개 이상의 스레드를 포함하는 각 작업들이 물리적인 시간으로 완전 동시에 수행하는 것. (이때 동시 작업은 멀티코어가 될수도 네트워크를 이용한 분산컴퓨팅이 될 수 있다.)\n병렬성을 만족하면 동시성도 만족, 동시성을 만족한다고 병렬성 만족x\n2) 자바에서 지원하는 Concurrent 프로그래밍 멀티쓰레드 멀티프로세싱(ProcessBuilder) 버전 사용 방법 Java 5 이전 Runnable과 Thread를 이용하여 구현 Java 5 ExecutorService, Callable, Future Java 7 Fork/Join 그리고 RecursiveTask Java 8 Stream, CompletableFuture Java 9 분산 비동기 프로그래밍은 명시적으로 지원 (발행 구독 프로토콜 지원 Flow API) 3) 자바 멀티쓰레드 프로그래밍 Thread/Runnable\npublic class App { public static void main(String[] args) { // 첫번째 방법 MyThread myThread = new MyThread(); myThread.start(); // Anonymous class Thread runnable = new Thread(new Runnable() { @Override public void run() { System.out.println(\u0026#34;Runnable Thread: \u0026#34; + Thread.currentThread().getName()); } }); // Lambda Expression Thread lambdaThread = new Thread(() -\u0026gt; System.out.println(\u0026#34;Lambda Thread:\u0026#34; + Thread.currentThread().getName())); System.out.println(\u0026#34;Hello: \u0026#34;+Thread.currentThread().getName()); } // Thread 상속 static class MyThread extends Thread { @Override public void run() { System.out.println(\u0026#34;Thread: \u0026#34;+Thread.currentThread().getName()); } } } /* 실행결과 Hello: main Thread: Thread-0 */ 코드의 실행 순서만 봐서는 Thread가 먼저 출력되야 할 것 같지만, 실제로 실행해보면 다르게 출력될 때도 있다. 이를 통해 Thread는 순서를 보장하지 않는다는 것을 알 수 있다. 여기선 로컬클래스를 이용했지만, 익명클래스와 람다표현식을 이용해서도 적용할 수 있다.\n4) 주요기능(method) sleep(mills) 현재 쓰레드 재우기(멈춰두기)\n스레드를 대기상태로 멈춰서 다른 스레드가 처리할 수 있도록 함. 하지만 락을 놔주진 않기에 잘못하면 데드락 상태에 걸릴 수 있다. public static void main(String[] args) throws InterruptedException { // Lambda Expression Thread lambdaThread = new Thread(() -\u0026gt; { try { Thread.sleep(1000L); } catch(InterruptedException e){ System.out.println(\u0026#34;interrupted!\u0026#34;); return; } System.out.println(\u0026#34;Thread: \u0026#34;+Thread.currentThread().getName()); }); lambdaThread.start(); System.out.println(\u0026#34;Hello: \u0026#34;+Thread.currentThread().getName()); } Thread.sleep(1000L) : Thread를 start하면 1초(1000L)동안 멈춰있고 그 동안 다른 쓰레드를 수행하기 때문에 Hello가 항상 우선 출력된다.\ninterrupt() 다른 쓰레드를 깨우기\nInterruptException 을 발생 이 에러에 대한 핸들링은 구현 가능 public static void main(String[] args) throws InterruptedException { // Lambda Expression Thread lambdaThread = new Thread(() -\u0026gt; { try { Thread.sleep(3000L); } catch(InterruptedException e){ System.out.println(\u0026#34;interrupted!\u0026#34;); return; } System.out.println(\u0026#34;Thread: \u0026#34;+Thread.currentThread().getName()); }); lambdaThread.start(); lambdaThread.interrupt(); System.out.println(\u0026#34;Hello: \u0026#34;+Thread.currentThread().getName()); } lambdaThread.interrupt(); : lambdaThread에 interrupt()메소드를 호출해 lambdaThread내에 InterruptedException 을 발생시킨다.\noin() 다른 쓰레드가 끝날 때까지 기다린다.\npublic static void main(String[] args) throws InterruptedException { //Lambda Expression Thread lambdaThread = new Thread(() -\u0026gt; { try { Thread.sleep(3000L); } catch(InterruptedException e){ System.out.println(\u0026#34;interrupted!\u0026#34;); return; } System.out.println(\u0026#34;Thread: \u0026#34;+Thread.currentThread().getName()); }); lambdaThread.start(); lambdaThread.join(); System.out.println(\u0026#34;Hello: \u0026#34;+Thread.currentThread().getName()); } lambdaThread.join(); : lambdaThread에 join()메소드를 호출하여 lambdaThread가 종료될 때까지 기다린다.\n2. Executors Runnable이나 Thread와 같은 Low-level이 아닌 고 수준(High-Level) Concurrency 프로그래밍\n우리가 Runnable만 정의해서 제공해주면 스레드를 만들고, 불필요해지면 종료하고 관리해주는 작업들을 대신 해주는 클래스\n고수준의 Concurrency 프로그래밍을 지원하는 라이브러리로 위와 같은 스레드 풀 라이브러리 들을 이용하여 구현되어있다.\n스레드를 만들고 관리하는 작업을 애플리케이션에서 분리하여 Executors에 위임한 형태이다.\n1) Executors가 하는 일 쓰레드 만들기: 애플리케이션이 사용할 쓰레드 풀을 만들어관리한다. 쓰레드 관리: 쓰레드 생명 주기를 관리한다. 작업 처리 및 실행: 쓰레드로 실행할 작업을 제공할 수 있는 API를 제공한다. 2) 주요 인터페이스 Executor: execute(Runnable) ExecutorService: Executor를 상속 받은 인터페이스로, Callable도 실행 가능하며 Executor를 종료 시키거나 여러 Callable을 동시에 실행하는 등의 기능을 제공한다. ScheduledExecutorService: ExecutorService를 상속 받은 인터페이스로 특정 시간 이후에 또는 주기적으로 작업 실행할 수 있다. 3) 예제 기본 사용 예제 public static void main(String[] args) throws InterruptedException { // ExecutorService 생성 ExecutorService executorService = Executors.newSingleThreadExecutor(); // Legacy case executorService.execute(new Runnable() { @Override public void run() { System.out.println(\u0026#34;Thread: \u0026#34;+Thread.currentThread().getName()); } }); // Lambda Expression executorService.submit(()-\u0026gt;{ System.out.println(\u0026#34;Lambda Expression Thread: \u0026#34;+Thread.currentThread().getName()); }); executorService.shutdown(); // graceful shutdown // executorService.shutdownNow(); //즉시 종료 } 2개의 Thread를 이용하여 실행 public class App { private static Runnable getRunnable(String message) { return () -\u0026gt; System.out.println(message + Thread.currentThread().getName()); } public static void main(String[] args) throws InterruptedException { ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.submit(getRunnable(\u0026#34;Hello\u0026#34;)); executorService.submit(getRunnable(\u0026#34;World\u0026#34;)); executorService.submit(getRunnable(\u0026#34;The\u0026#34;)); executorService.submit(getRunnable(\u0026#34;Java\u0026#34;)); executorService.submit(getRunnable(\u0026#34;Lecture\u0026#34;)); executorService.submit(getRunnable(\u0026#34;Concurrent\u0026#34;)); executorService.submit(getRunnable(\u0026#34;Part\u0026#34;)); executorService.shutdown(); //graceful shutdown } } /* 실행결과 Hellopool-1-thread-1 Worldpool-1-thread-2 Javapool-1-thread-2 Thepool-1-thread-1 Lecturepool-1-thread-2 Concurrentpool-1-thread-1 Partpool-1-thread-2 */ Executors.newFixedThreadPool(2)\n해당 메소드를 호출하면 해당 영역에는 인자값으로 넘겨준 숫자만큼 Thread를 관리한다. 위 코드에서는 2를 인자값으로 넘겨줬기 때문에 2개의 2개의 쓰레드를 관리하는 Thread Pool이 도는 동안 Blocking Queue에 등록된 작업들이 차례대로 동작한다. ExecutorService.newSingleThreadScheduledExcutor();\nScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor(); executorService.scheduleAtFixedRate(getRunnable(\u0026#34;hello\u0026#34;), 3, 1, TimeUnit.SECONDS); scheduleAtFixedRate(실행 Runnable, 시작 지연 시간, 딜레이, 파라미터 시간 단위) 위 코드는 Runnable타입을 반환하는 getRunnable() 메소드를 프로그램이 시작 후 3초 뒤부터 1초마다 수행하는 코드 4) Executor 정리 supplyAsync 등의 메소드 호출시 쓰레드 풀을 명시하지 않으면 Java ForkJoinPool 의 commonPool() 이 사용된다. 개발자가 쓰레드 풀을 제어할 수 없다는 것은 나중에 문제가 될 수 있다. 따라서, 항상 Java ExecutorService 를 명시적으로 사용하여 쓰레드 풀을 지정하도록 한다. 3. Callable과 Future 1) Callable Runnable과 거의 유사하지만 반환 값을 가질 수 있다.\n2) Future 비동기적인 작업의 현재 상태를 조회하거나 결과를 가져올 수 있다.\n3) 메소드 살펴보기 작업 요청 (execute/submit) execute : 리턴타입이 void로 작업처리 결과를 리턴받지 못하고 작업처리 도중에 예외가 발생하면 스레드가 종료되고 해당 스레드는 스레드풀에서 제거\npublic void execute(Runnable command) { if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) \u0026lt; corePoolSize) { //현재 생성된 스레드갯수가 코어 개수보다 작다면 if (addWorker(command, true)) //새로 스레드를 만들어 task를 처리하고 리턴 return; c = ctl.get(); } //더이상 처리할 스레드가 없을 경우 워커큐에 task를 넣어주고 리턴 //스레드 풀이 죽었거나 thread가 없는지 check if (isRunning(c) \u0026amp;\u0026amp; workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) \u0026amp;\u0026amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); } else if (!addWorker(command, false)) reject(command); } +) ctl : 스레드풀의 상태 , 조금이라도 더 빠른 계산을 위해 비트로 값을 저장하고 비트 연산을 통해 동작\nworkerCount : 현재 스레드 개수 Integer.SiZE - 3 만큼의 갯수가 최대 갯수로 약 5억개 runState : 스레드풀의 상태 RUNNING : 새로운 TASK를 받고 큐에 집어 넣은 일을 하는 상태 SHUTDOWN : 새로운 TASK를 받지말고 큐에있는 TASK를 처리 RUNNING -\u0026gt; SHUTDOWN : shutdown() 호출시 STOP : 새로운 TASK를 받지 않고 큐에있는 TASK도 처리하지 않은 상태로 현재 진행중인 TASK에 INTERRUPT를 건다. (RUNNING or SHUTDOWM) -\u0026gt; STOP : shutdownNow() 호출시 TIDYING : 모든 TASK는 소멸 되었고, WORKER COUNT는 0. 이 상태로 전이되는 스레드는 terminated() 메서드를 실행시켜 종료할 예정인 상태 STOP -\u0026gt; TIDYING : 스레드 풀이 비었을때 TERMINATED : 모든 스레드가 terminated()된 상태 submit : Future타입을 반환하고 작업처리 도중에 예외가 발생해도 스레드는 종료되지 않고 다음 작업을 위해 재사용되기 때문에 스레드의 생성 오버헤더를 줄일 수 있다.\npublic Future\u0026lt;?\u0026gt; submit(Runnable task) { if (task == null) throw new NullPointerException(); RunnableFuture\u0026lt;Void\u0026gt; ftask = newTaskFor(task, null); execute(ftask); return ftask; } 결과 반환 : get() 해당 메소드는 블록킹 콜이기에 메소드 호출시점부터 코드실행 완료까지 기다린다. 타임아웃을 설정할 수 있다. ExecutorService executorService = Executors.newSingleThreadExecutor(); Callable\u0026lt;String\u0026gt; hello = () -\u0026gt;{ Thread.sleep(2000L); return \u0026#34;Hello\u0026#34;; }; Future\u0026lt;String\u0026gt; submit = executorService.submit(hello); System.out.println(\u0026#34;Started!\u0026#34;); submit.get();// blocking System.out.println(\u0026#34;End\u0026#34;); executorService.shutdown(); /* Started! (2초 뒤) End */ 작업 상태 확인 - isDone() ExecutorService executorService = Executors.newSingleThreadExecutor(); Callable\u0026lt;String\u0026gt; hello = () -\u0026gt;{ Thread.sleep(2000L); return \u0026#34;Hello\u0026#34;; }; Future\u0026lt;String\u0026gt; helloFuture = executorService.submit(hello); System.out.println(helloFuture.isDone()); System.out.println(\u0026#34;Started!\u0026#34;); helloFuture.get(); // blocking System.out.println(helloFuture.isDone()); System.out.println(\u0026#34;End\u0026#34;); executorService.shutdown(); /* 실행 결과 false Started! true End */ 작업 취소 : cancel() 인자 값으로 현재 진행중인 쓰레드 interrupt 여부를 결정한다. true 이면 현재 진행중인 쓰레드를 interrupt하고 그렇지 않으면 현재 진행중인 작업이 끝날때까지 기다린다. ExecutorService executorService = Executors.newSingleThreadExecutor(); Callable\u0026lt;String\u0026gt; hello = () -\u0026gt;{ Thread.sleep(2000L); return \u0026#34;Hello\u0026#34;; }; Future\u0026lt;String\u0026gt; helloFuture = executorService.submit(hello); System.out.println(helloFuture.isDone()); System.out.println(\u0026#34;Started!\u0026#34;); helloFuture.cancel(false); System.out.println(helloFuture.isDone()); System.out.println(\u0026#34;End\u0026#34;); helloFuture.get(); executorService.shutdown(); /* 실행 결과 false Started! true End Exception in thread \u0026#34;main\u0026#34; java.util.concurrent.CancellationException... */ helloFuture.cancel(false)\n현재 진행중인 작업을 기다린 뒤 작업을 취소한다. 작업이 취소되어 종료되었기 때문에 아래에 helloFuture.isDone() 은 true가 반환되며, 이미 취소한 작업을 get() 호출하는 시점에는 CancellationException 예외가 발생 여러 작업 동시 실행 : invokeAll() ExecutorService executorService = Executors.newSingleThreadExecutor(); LocalDateTime start = LocalDateTime.now(); Callable\u0026lt;String\u0026gt; hello = () -\u0026gt;{ Thread.sleep(2000L); return \u0026#34;Hello\u0026#34;; }; Callable\u0026lt;String\u0026gt; java = () -\u0026gt;{ Thread.sleep(3000L); return \u0026#34;java\u0026#34;; }; Callable\u0026lt;String\u0026gt; youngjun = () -\u0026gt;{ Thread.sleep(1000L); return \u0026#34;youngjun\u0026#34;; }; List\u0026lt;Future\u0026lt;String\u0026gt;\u0026gt; futures = executorService.invokeAll(Arrays.asList(hello, java, youngjun)); for (Future\u0026lt;String\u0026gt; future : futures) { System.out.println(future.get()); } LocalDateTime end = LocalDateTime.now(); Duration between = Duration.between(start, end); System.out.println(between.getSeconds()); /* Hello java youngjun 6 */ invokeAll() 메소드는 태스크가 모두 끝날때까지 기다렸다가 값들을 반환\n싱글 쓰레드이기 때문에 6초가 소요된다. future list를 반환하고 전부 끝날때까지 holding된다. 넘겨준 Callable list가 정상 처리되든 exception이 발생하든 완료된 것으로 본다. 동작중에 전달받은 list가 변경되면 결과를 보장하지 않는다 넘겨준 list 순서대로 결과 future를 담아서 넘겨준다. 발생할 수 있는 Exception\nInterruptedException : 동작이 종료되지 않은(동작중인) task가 취소 되었을 때 NullPointerException : 함수의 param중 null이 있을 때 RejectedExecutionException : task를 pool에 넣을수 없을 때. 따라서 가장 먼저 완료된 작업만 반환해도 괜찮다면 invokeAll을 쓰기에는 성능이 떨어진다.\n그럴 때 사용 할 수 있는 메소드가 invokeAny 이다. 여러 작업 동시 실행 : invokeAny() 동시에 실행한 작업 중에 제일 짧게 걸리는 작업 만큼 시간이 걸린다. 블록킹 콜이다. String result = executorService.invokeAny(Arrays.asList(hello, java, youngjun)); System.out.println(\u0026#34;result = \u0026#34; + result); /* 실행 결과 result = youngjun */ Warning\n주의할 점은, 싱글 쓰레드로 할 경우 먼저 들어간 순서대로 나오게 된다는 점이다.\npublic static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newSingleThreadExecutor(); Callable\u0026lt;String\u0026gt; hello = () -\u0026gt; { Thread.sleep(2000L); return \u0026#34;Hello\u0026#34;; }; Callable\u0026lt;String\u0026gt; java = () -\u0026gt; { Thread.sleep(3000L); return \u0026#34;java\u0026#34;; }; Callable\u0026lt;String\u0026gt; youngjun = () -\u0026gt; { Thread.sleep(1000L); return \u0026#34;youngjun\u0026#34;; }; String s = executorService.invokeAny(Arrays.asList(hello, java, youngjun)); System.out.println(s); executorService.shutdown(); } /* 실행 결과 Hello */ 4. CompletableFuture 1) 개요 자바에서 비동기(Asynchronous)프로그래밍을 가능하게하는 인터페이스.\nFuture의 제약사항들을 해결한다.\n2) Future 제약 예외 처리용 API를 제공하지 않는다.\n여러 Future를 조합할 수 없다. (ex: Event정보를 받아 다음 Event에 참석할 회원목록조회)\nFuture를 외부에서 완료시킬 수 없다. 취소하거나, get()에 타임아웃을 설정할 수는 있다.\nget()을 호출하기 전까지는 future를 다룰 수 없다.\nExecutorService executorService = Executors.newFixedThreadPool(4); Future\u0026lt;String\u0026gt; future = executorService.submit(() -\u0026gt; \u0026#34;hello\u0026#34;); ...//TODO future.get(); ...//TODO 여기서 future는 blocking call\nfuture를 get()으로 가져오는 동안에는 다른 작업들의 수행이 안된다는 의미이고 그 기간이 길어질수록 성능은 떨어질수 밖에 없다.\n3) CompletableFuture Future와 CompletionStage를 구현하는 구현체\n예외처리를 지원하는 메서드\n순서의 의존관계를 맞는 스레드 프로그래밍\n콜백을 지원하기도 하며 여러 스레드를 하나로 묶어 처리하기에도 용이\npublic class CompletableFuture implements Future, CompletionStage{\u0026hellip;}\nCompletableFuture\u0026lt;String\u0026gt; future = new CompletableFuture\u0026lt;\u0026gt;(); future.complete(\u0026#34;youngjun\u0026#34;); System.out.println(\u0026#34;future = \u0026#34; + future.get()); //-------------OR -------------- CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.completedFuture(\u0026#34;youngjun\u0026#34;); System.out.println(\u0026#34;future = \u0026#34; + future.get()); 4) 비동기로 작업 실행하기 리턴값이 없는 경우: runAsync()\nCompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture.runAsync(() -\u0026gt; { System.out.println(\u0026#34;Hello\u0026#34; + Thread.currentThread().getName()); }); future.get(); 리턴값이 있는 경우: supplyAsync()\nCompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;Hello\u0026#34; + Thread.currentThread().getName()); return \u0026#34;Hello\u0026#34;; }); future.get(); 원하는 Executor(쓰레드풀)를 사용해서 실행할 수도 있다. (기본은 ForkJoinPool.commonPool())\n5) 콜백 제공하기 thenApply(Function) : 리턴값을 받아서 다른 값으로 바꾸는 콜백\nCompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;Hello\u0026#34; + Thread.currentThread().getName()); return \u0026#34;Hello\u0026#34;; }).thenApply((s)-\u0026gt;{ System.out.println(\u0026#34;content: \u0026#34;+s); System.out.println(Thread.currentThread().getName()); return \u0026#34;HelloAsync\u0026#34;; }); System.out.println(future.get()); Javascript의 Promise 와 유사한 형태 supplyAsync의 람다표현식에서 반환된 Hello라는 값은 체이닝된 메소드 thenApply의 인자값으로 들어가고 사용 가능 그리고 더 이상 체이닝된 메소드가 없기 때문에 return값인 HelloAsync는 반환되어 future로 들어가고 get()을통해 받을 수 있다. thenAccept(Consumer) : 리턴값을 받아 또 다른 작업을 수행하는데 반환값은 없는 콜백 (리턴 x)\nCompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;Hello\u0026#34; + Thread.currentThread().getName()); return \u0026#34;Hello\u0026#34;; }).thenAccept((s)-\u0026gt;{ System.out.println(\u0026#34;content: \u0026#34;+s); System.out.println(Thread.currentThread().getName()); // return 없다. }); future.get(); thenRun(Runnable) : 리턴값을 받지 않고 다른 작업을 수행하는 콜백\nCompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;Hello\u0026#34; + Thread.currentThread().getName()); return \u0026#34;hello\u0026#34;; }).thenRun(()-\u0026gt;{ System.out.println(Thread.currentThread().getName()); }); future.get(); ParallelStream vs. CompletableFuture Java 8 in Action 에 설명이 되어있다.\nParallelStream : I/O가 포함되지 않은 계산 중심의 동작을 실행할 때는 스트림 인터페이스가 가장 구현하기 간다하며 효율적일 수 있다(모든 스레드가 계산 작업을 수행하는 상황에서는 프로세서 코어 수 이상의 쓰레드를 가질 필요가 없다).\nCompletableFuture : 반면 작업이 I/O를 기다리는 작업을 병렬로 실행할 때는 CompletableFuture가 더 많은 유연성을 제공하며 대기/계산(W/C)의 비율에 적합한 스레드 수를 설정할 수 있다. 특히 스트림의 게으른 특성 때문에 스트림에서 I/O를 실제로 언제 처리할 지 예측하기 어려운 문제도 있다. fahd.blog: Java 8: CompletableFuture vs Parallel Stream 6) CompletableFuture 조합 메소드 thenCompose() 두 작업이 서로 이어서 실행하도록 조합하며 연관된 future간에 많이 사용\npublic class App { public static void main(String[] args) throws InterruptedException, ExecutionException { CompletableFuture\u0026lt;String\u0026gt; helloFuture = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;Hello \u0026#34; + Thread.currentThread().getName()); return \u0026#34;Hello\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; future = helloFuture.thenCompose(App::getWorldFuture); System.out.println(future.get()); } private static CompletableFuture\u0026lt;String\u0026gt; getWorldFuture(String message) { return CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;World \u0026#34; + Thread.currentThread().getName()); return message + \u0026#34; World\u0026#34;; }); } } /* Hello ForkJoinPool.commonPool-worker-3 World ForkJoinPool.commonPool-worker-5 Hello World */ thenCombine() 두 작업을 독립적으로 실행하고 둘 다 종료 했을때 콜백 실행.\npublic static void main(String[] args) throws InterruptedException, ExecutionException { CompletableFuture\u0026lt;String\u0026gt; msFuture = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;MicroSoft \u0026#34; + Thread.currentThread().getName()); return \u0026#34;MicroSoft\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; appleFuture = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;Apple \u0026#34; + Thread.currentThread().getName()); return \u0026#34;Apple\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; resultFuture = msFuture.thenCombine(appleFuture, (i, j) -\u0026gt; i + \u0026#34; \u0026#34; + j); System.out.println(resultFuture.get()); } allOf() 여러 작업을 모두 실행하고 모든 작업 결과에 콜백 실행\npublic static void main(String[] args) throws InterruptedException, ExecutionException { CompletableFuture\u0026lt;String\u0026gt; msFuture = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;MicroSoft \u0026#34; + Thread.currentThread().getName()); return \u0026#34;MicroSoft\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; appleFuture = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;Apple \u0026#34; + Thread.currentThread().getName()); return \u0026#34;Apple\u0026#34;; }); List\u0026lt;CompletableFuture\u0026lt;String\u0026gt;\u0026gt; futures = Arrays.asList(msFuture, appleFuture); CompletableFuture\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; results = CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()])) .thenApply(v -\u0026gt; futures.stream() .map(CompletableFuture::join) .collect(Collectors.toList())); results.get().forEach(System.out::println); } anyOf() 여러 작업 중 가장 끝난 하나의 결과를 콜백에 넘겨 실행\nCompletableFuture\u0026lt;String\u0026gt; msFuture = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;MicroSoft \u0026#34; + Thread.currentThread().getName()); return \u0026#34;MicroSoft\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; appleFuture = CompletableFuture.supplyAsync(() -\u0026gt; { System.out.println(\u0026#34;Apple \u0026#34; + Thread.currentThread().getName()); return \u0026#34;Apple\u0026#34;; }); CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture.anyOf(msFuture, appleFuture).thenAccept(System.out::println); future.get(); 7) 예외 처리 메소드 exeptionally(Function) boolean throwError = true; CompletableFuture\u0026lt;String\u0026gt; msFuture = CompletableFuture.supplyAsync(() -\u0026gt; { if (throwError) { throw new IllegalArgumentException(); } System.out.println(\u0026#34;MicroSoft \u0026#34; + Thread.currentThread().getName()); return \u0026#34;MicroSoft\u0026#34;; }).exceptionally(ex-\u0026gt;{ System.out.println(ex); return \u0026#34;Error\u0026#34;; }); System.out.println(msFuture.get()); handle(BiFunction) boolean throwError = false; CompletableFuture\u0026lt;String\u0026gt; msFuture = CompletableFuture.supplyAsync(() -\u0026gt; { if (throwError) { throw new IllegalArgumentException(); } System.out.println(\u0026#34;MicroSoft \u0026#34; + Thread.currentThread().getName()); return \u0026#34;MicroSoft\u0026#34;; }).handle((result, ex)-\u0026gt;{ if (Objects.nonNull(ex)) { System.out.println(ex); return \u0026#34;ERROR\u0026#34;; } return result; }); System.out.println(msFuture.get()); 8) CompletableFuture 를 언제 쓸 수 있을까 아래는 microservices.io 사이트에서 가져온 예제이다.\nCompletableFuture 를 사용할 만한 부분은 API GATEWAY, Storefront WebApp 라고 할 수 있다. 이유는 Account, Inventory, Shipping Service 는 DATA BASE 와 연동하고 있기 때문이다. java 환경에서 RDBMS 연동시에 아직 Async 한 인터페이스 방식을 제공하고 있지 않기 때문에 Async 개발을 해서 큰 효과를 얻기 부족하다.\n하지만, GATEWAY 등은 REST Service 와 연동하기 때문에 Async 를 통한 성능 효과를 볼 수 있다. (Blocking Thread 문제 해결 등)\nReference https://www.hungrydiver.co.kr/bbs/detail/develop?id=2 https://kwonnam.pe.kr/wiki/java/8/completable_future https://huisam.tistory.com/entry/completableFuture https://tourspace.tistory.com/137 https://bbubbush.tistory.com/23 "},{"section":"Blog","slug":"/blog/java/date-time/","title":"Date/Time","description":"java8에 추가된 Date/Time 타입에 대해 설명합니다.","date":"2021년 12월 8일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"1. 등장 배경 1) 명확하지 않은 클래스 이름 날짜 클래스중 Date 는 시간과 TimeStamp 모두 표현할 수 있다. (사실상 TimeStamp) 시간 값이 에폭타임 이라 하여 세계 표준시(UTC)로 1970년 1월 1일 00시 00분 00초를 기준으로 현재까지 흐른 모든 시간을 초(sec)단위로 표현 하여 사람이 알아보기 어렵다. 2) Thread safe하지 않은 mutable한 속성 public static void main(String[] args) throws InterruptedException { Date date = new Date(); long time = date.getTime(); System.out.println(\u0026#34;date = \u0026#34; + date); Thread.sleep(1000 * 3); Date after3Seconds = new Date(); System.out.println(\u0026#34;after3Seconds = \u0026#34; + after3Seconds); after3Seconds.setTime(time); System.out.println(\u0026#34;after3Seconds = \u0026#34; + after3Seconds); } /* [실행 결과] date = Thu Oct 28 20:22:24 KST 2021 after3Seconds = Thu Oct 28 20:22:27 KST 2021 after3Seconds = Thu Oct 28 20:22:24 KST 2021 */ 새로 생성한 after3Sceconds 라는 객체가 setter를 통해 다른 시간으로 변경이 된 것을 볼 수 있는데, 이는 Date 클래스가 mutable 하다는 것을 의미한다. mutable하기 때문에 thread unsafe 하다.\nthread unsafe? Date 인스턴스의 값을 각각 다른 Thread에서 접근해서 변경이 가능하면 기존에 사용하던 Thread에서 변경 되어 잘못된 Date 정보를 가져와서 버그가 발생할 위험이 있다는 뜻.\n3) 버그 발생할 여지가 많다. 사용법 자체에서도 사용법에 대해 오해할 수 있어 버그가 발생할 여지가 있다.\nCalendar birthDay = new GregorianCalendar(1988, 6, 10); 위 코드를 보면 생일이 1988년 6월 10일임을 표현하고 싶지만, GregorianCalendar에서 month는 0부터시작하기 때문에 6을 넣으면 7월이라는 의미가 된다. 그래서 혼동하지 않기 위해서 상수 값을 쓰곤 했다. (ex: Calendar.JUNE)\n하지만 이도 임시 방편이었고 암묵적으로 Java 8 이전에는 Joda-Time 을 사용했었다.\n2. 디자인 철학 1) Clear API 메소드는 명확해야한다. 예를들어 클래스명이 Date지만 날짜 뿐 아니라 시간(Time)까지 다루게되면 명확하지 않다. 시간(Time)역시 사람에게 익숙한 일반 시간이 아닌 에폭타임인 것은 Clear하지 않다. 2) Fluent 메소드가 null을 반환하는 경우가 없기 때문에 메소드 체이닝이 가능하기에 코드가 유려해진다.\n3) Immutable 기존 날짜 인스턴스의 내용이 변하지 않으며 변경메소드 호출시 값이 변경되는게 아니라 새로운 날짜 인스턴스를 생성해 반환해야한다.\nLocalDate today = LocalDate.of(2021, Month.OCTOBER, 28); LocalDate nextMonth = today.plusMonths(1); //LocalDateTime의 plusDays() 메서드 public LocalDateTime plusDays(long days) { LocalDate newDate = date.plusDays(days); return with(newDate, time); } private LocalDateTime with(LocalDate newDate, LocalTime newTime) { if (date == newDate \u0026amp;\u0026amp; time == newTime) { return this; } return new LocalDateTime(newDate, newTime); } Date/Time의 모든 객체는 mutable한 속성의 단점을 해결하고자 Immutable한 속성을 갖고 설계가 되었는데 이 때문에 메서드를 이용해 날짜,시간을 변경하면 위에 정의된 with()함수를 사용하게 되고 with()함수는 새로운 객체를 만들어 반환하고 있는 것을 볼 수 있다.\n4) Extensible 확장 가능해야 한다. 달력에는 윤달, 음력, 양력, 불교달력 등 다양한 종류의 달력의 확장이 가능해야 한다. 3. 기존 API와 추가된 API 1) 기존 API java.util.Date java.util.Calendar java.text.SimpleDateFormat 2) 추가된 API java.time.Instant : 기계시간 java.time.LocalDate : 날짜(시간x), 타임존x java.time.LocalTime : 시간(날짜x), 타임존x java.time.LocalDateTime : 날짜/시간, 타임존x java.time.ZonedDateTime : 날짜/시간, 타임존o java.time.DateTimeFormatter java.time.Duration java.time.Period java.time.TemporalAdjuster 4. API 사용 예 1) Instant Instant instant = Instant.now(); System.out.println(instant); //2021-11-02T14:07:19.218304100Z (기준시 UTC 기준) ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault()); System.out.println(instant); //2021-11-02T23:08:45.188601700+09:00[Asia/Seoul] (현재 KTC 기준) Instant.now(): 현재 UTC(GMT)를 반환 (Universal Time Coordinated == Greenwich Mean Time) ZoneId.systemDefault() : 현재 시스템상의 zone 정보를 반환 (ex: Asia/Seoul) instant.atZone(zone) : UTC 기준이아닌 zone 의 위치 기반의 시간을 반환 2) LocalDate / LocalTime / LocalDateTime / ZonedDateTime LocalDateTime now = LocalDateTime.now(); //서버의 시스템 zone 기준 System.out.println(now); LocalDateTime of = LocalDateTime.of(1982, Month.JULU, 15,0,0,0); ZonedDateTime nowInKorea = ZonedDateTime.now(ZoneId.of(\u0026#34;Asia/Seoul\u0026#34;)); System.out.println(nowInKorea); 보통 사람이 읽고 쓰기 편한 시간 표현방식으로 표현해주는 API\nLocalDateTime.now() : 현재 시스템 Zone에 해당하는(로컬) 일시를 반환 LocalDateTime.of(1988, Month.JUNE, 10, 0, 0, 0); : 로컬의 특정 일시를 반환 ZonedDateTime.now(ZoneId.of(\u0026ldquo;UTC\u0026rdquo;)) : 특정 Zone의 현재 시간을 반환합니다. ZonedDateTime.of(1988, Month.JUNE.getValue(),10,0,0,0,0, ZoneId.of(\u0026ldquo;UTC\u0026rdquo;)) : 특정 Zone의 특정 일시를 반환합니다. 3) Duration / Period //Period LocalDate today = LocalDate.now(); LocalDate thisYearBirthDay = LocalDate.of(2022, Month.FEBRUARY,7); Period period = Period.between(today, thisYearBirthDay); System.out.println(\u0026#34;생일까지 남은 기간 : \u0026#34; + period.getYears() + \u0026#34; 년 \u0026#34; + period.getMonths() + \u0026#34;월 \u0026#34; + period.getDays() + \u0026#34;일\u0026#34; ); //생일까지 남은 기간 : 0 년 3월 5일 Period p = today.until(thisYearBirthDay); System.out.println(\u0026#34;생일까지 남은 기간 : \u0026#34; + p.getYears() + \u0026#34; 년 \u0026#34; + p.getMonths() + \u0026#34;월 \u0026#34; + p.getDays() + \u0026#34;일\u0026#34; ); //생일까지 남은 기간 : 0 년 3월 5일 //Duration Instant now = Instant.now(); Instant plus = now.plus(10,ChronoUnit.SECONDS); Duration between = Duration.between(now,plus); System.out.println(between.getSeconds()); //10 Period는 사람이 사용하는 날짜/시간의 기간을 측정, Duration은 초단위(나노,밀리)로 반환을 하기 때문에 주로 기계용 시간간의 기간을 측정하는데 사용할 수 있다.\n시간 비교시 유용한 방식 위의 방식은 대부분 시간 메소드를 어떤식으로 사용해야하는 지에 대해서 이야기하는게 대부분인데, 실제로 제일 필요한 건 시간 비교가 제일 유용할 것 같아서 좀 더 정리해본다.\nLocalDateTime time1 = LocalDateTime.of(2021, 11, 3, 10, 18, 0); LocalDateTime time2 = LocalDateTime.of(2021, 11, 3, 10, 19, 0); public boolean isAfter(ChronoLocalDate other) //주어진날짜가 other보다 크면.. True System.out.println(time1.isAfter(time2)); //false System.out.println(time2.isAfter(time1)); //true public boolean isBefore(ChronoLocalDate other) //주어진날짜가 other보다 작으면.. True System.out.println(time1.isBefore(time2)); //true System.out.println(time2.isBefore(time1)); //false public boolean isEqual(ChronoLocalDate other) //주어진날짜가 other보다 같으면.. True public int compareTo(ChronoLocalDate other) //주어진날짜가 other보다 같으면 0, 크면 + 작으면 - System.out.println(time1.compareTo(time2)); //-1 System.out.println(time2.compareTo(time1)); // 1 //날짜를 하루정도로 바꿔서 변환해보자 11/3 11/4 시간은 동일하게 System.out.println(time1.compareTo(time2)); //-1 System.out.println(time2.compareTo(time1)); // 1 public LocalDateTime truncatedTo(TemporalUnit unit) isAfter,isBefore과 같은 메서드를 통해 비교를 수행할수 있다.\n이때 truncatedTo() 메서드를 이용해서 시간을 잘라 내고 날짜만으로 비교가 가능한데 trucatedTo()메서드는 파라미터로 지정된 단위 이후의 값들을 버린 후, 복사한 LocalDateTime 객체를 리턴하는 메서드이다. 파라미터로 전달되는 단위는 ChronoUnit 클래스에 지정된 상수를 사용하며, DAYS보다 큰 단위인 YEARS, MONTHS 등의 값은 허용되지 않는다.\nLocalDateTime time1 = LocalDateTime.of(2021, 11, 3, 10, 18, 3); System.out.println(time1.truncatedTo(ChronoUnit.SECONDS)); //2021-11-03T10:18:03 System.out.println(time1.truncatedTo(ChronoUnit.MINUTES)); //2021-11-03T10:18 System.out.println(time1.truncatedTo(ChronoUnit.HOURS)); //2021-11-03T10:00 System.out.println(time1.truncatedTo(ChronoUnit.DAYS)); //2021-11-03T00:00 현 기준 날짜로 절삭 해서 사용가능히고 현 시간을 시점으로 + -도 ChronoUnit으로 더 효율적으로 할 수 있다.\nLocalDateTime time1 = LocalDateTime.of(2021, 11, 3, 10, 18, 3); LocalDateTime time2 = LocalDateTime.of(2021, 11, 4, 10, 18, 0); //3일이 더해짐. System.out.println(time1.plus(3, ChronoUnit.DAYS)); //2021-11-06T10:18:03 //3일이 빠짐. System.out.println(time1.minus(3, ChronoUnit.DAYS)); //2021-11-06T10:18:03 //구체적으로 3년이 이런식으로 추가도 가능하다. System.out.println(time1.plusYears(3));//2024-11-03T10:18:03 //빼는것도 ㅆㄱㄴ System.out.println(time1.minusYears(3)); //2018-11-03T10:18:03 //아니면 이런식으로 사용할수도 있다. ChronoUnit.HOURS.between(time1, time2); //23 (23.x 분 차이이기 때문에) truncatedTo가 날짜부터는 자를 수 없는 이유 일수부터는 생략한다는 개념이 모호하다.예를 들어, day에 0이 오는것도 말이 안되며 1이 온다고 해도 일수를 잘라내 정확히 년,월을 뜻하는게 아니라 년,월,1일을 뜻하는 것이기 때문에 매개변수로 올 수 가 없는 것이다.\n하지만 해당해의 1일을 만약에 표시하고 싶을경우에는 TemporalAdjusters(시간 조정기) 를 이용할 수 있다.\ndate.with(TemporalAdjusters.firstDayOfMonth()).truncatedTo(ChronoUnit.DAYS); //2021-11-01T00:00 date.with(TemporalAdjusters.firstDayOfYear()) : 해당 년도의 1월 1일 //2021-01-01T17:02:22.973160900 date.with(TemporalAdjusters.firstDayOfMonth()) : 해당 월의 1일 //2021-11-01T17:03:05.777745100 date.with(TemporalAdjusters.lastDayOfYear()) : 해당 년도의 마지막 날짜 //2021-12-31T17:03:34.531656400 date.with(TemporalAdjusters.lastDayOfMonth()) : 해당 월의 마지막 날짜 //2021-11-30T17:04:03.837483400 ChronoUnit 4) DateTimeFormatter //formatting LocalDateTime now = LocalDateTime.now(); DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME; System.out.println(now.format(formatter)); //2021-11-02T23:28:51.388655 formatter = DateTimeFormatter.ofPattern(\u0026#34;MM.dd.yyyy\u0026#34;); System.out.println(now.format(formatter)); //11.02.2021 DateTimeFormatter은 ofPattern()을 이용해 특정 패턴을 지정할 수 있고 미리 정의된 포맷터들이 존재하는데 이 형식을 이용하고자하면 굳이 새로 정의해줄 필요가 없다. 정의된 포맷터들은 여기 를 참고하자.\n이때, Formatter에 사용되는 형식은 다음처럼 사용 가능하다.\nSymbol Meaning Presentation Examples ------ ------- ------------ ------- G era text AD; Anno Domini; A u year year 2004; 04 y year-of-era year 2004; 04 D day-of-year number 189 M/L month-of-year number/text 7; 07; Jul; July; J d day-of-month number 10 Q/q quarter-of-year number/text 3; 03; Q3; 3rd quarter Y week-based-year year 1996; 96 w week-of-week-based-year number 27 W week-of-month number 4 E day-of-week text Tue; Tuesday; T e/c localized day-of-week number/text 2; 02; Tue; Tuesday; T F week-of-month number 3 a am-pm-of-day text PM h clock-hour-of-am-pm (1-12) number 12 K hour-of-am-pm (0-11) number 0 k clock-hour-of-am-pm (1-24) number 0 H hour-of-day (0-23) number 0 m minute-of-hour number 30 s second-of-minute number 55 S fraction-of-second fraction 978 A milli-of-day number 1234 n nano-of-second number 987654321 N nano-of-day number 1234000000 V time-zone ID zone-id America/Los_Angeles; Z; -08:30 z time-zone name zone-name Pacific Standard Time; PST O localized zone-offset offset-O GMT+8; GMT+08:00; UTC-08:00; X zone-offset \u0026#39;Z\u0026#39; for zero offset-X Z; -08; -0830; -08:30; -083015; -08:30:15; x zone-offset offset-x +0000; -08; -0830; -08:30; -083015; -08:30:15; Z zone-offset offset-Z +0000; -0800; -08:00; p pad next pad modifier 1 \u0026#39; escape for text delimiter \u0026#39;\u0026#39; single quote literal \u0026#39; [ optional section start ] optional section end # reserved for future use { reserved for future use } reserved for future use LocalDateTime now = LocalDateTime.now(); formatter = DateTimeFormatter.ofPattern(\u0026#34;MM.dd.yyyy\u0026#34;); System.out.println(now.format(formatter)); //11.02.2021 //parsing LocalDate parse = LocalDate.parse(\u0026#34;08.12.2021\u0026#34;,formatter); System.out.println(parse); 또한, Date/Time타입의 parse()메서드를 통해서 특정 문자열을 ofPattern에서 선언한 패턴 방식으로 파싱하여 LocalDate 타입의 인스턴스를 생성해 반환할 수도 있다.\n5) 레거시 API 지원 예전에 구현 및 사용하던 날짜와 시간(Date) API와 현재 추가된 LocalDate, LocalDateTime, Instant는 서로 호환 된다!\npublic static void main(String[] args) { Date date = new Date(); Instant instant = date.toInstant(); Date newDate = Date.from(instant); GregorianCalendar gregorianCalendar = new GregorianCalendar(); LocalDateTime dateTime = gregorianCalendar.toInstant() .atZone(ZoneId.systemDefault()) .toLocalDateTime(); ZonedDateTime zonedDateTime = ZonedDateTime.from(dateTime); GregorianCalendar from = GregorianCalendar.from(zonedDateTime); ZoneId zoneId = TimeZone.getTimeZone(\u0026#34;PST\u0026#34;).toZoneId(); TimeZone timeZone = TimeZone.getTimeZone(zoneId); } GregorianCalendar와 Date 타입의 인스턴스를 Instant나 ZonedDateTime으로 변환 java.util.TimeZone에서 java.time.ZoneId로 상호 변환 가능 Reference 백기선 인프런 강의 : 더 자바, Java8 (Java) 날짜 비교하기 ( LocalDate, LocalDateTime, Date, Calendar) (Java8 Time API) Duration과 Period 사용법 (+ChronoUnit) https://codeblog.jonskeet.uk/2017/04/23/all-about-java-util-date/ "},{"section":"Blog","slug":"/blog/java/optional/","title":"Optional","description":"java8에 추가된 Optional에 대해 설명합니다.","date":"2021년 12월 8일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"Java 8에 새로 생긴 인터페이스로 라이브러리 메서드가 반환할 결과값이 없음을 명백하게 표현할 필요가 있는 곳에서 제한적으로 사용할 수 있는 메커니즘을 제공하기 위해 새로 생겨났다.\nJava api doc의 API 노트를 보면 다음과 같이 설명하고 있다. Optional은 주로 결과 없음을 나타낼 필요성이 명확하고 null을 사용하면 오류가 발생할 수 있는 메소드 반환 유형으로 사용하도록 고안되었다.\n한마디로 비어있을 수도 있고, 어떠한 값 하나만 담고 있을수도 있는 인스턴스의 타입\n등장 배경 1. 참조형 멤버변수 와 NPE 런타임에 NPE(NullPointerException)라는 예외를 발생시킬 수 있다. NPE 방어를 위해서 들어간 null 체크 로직 때문에 코드 가독성과 유지 보수성이 떨어진다. /* OnlineClass.java */ public Progress progress; public Progress getProgress() { return progress; } public void setProgress(Progress progress) { this.progress = progress; } } /* OptionalTestApp.java */ OnlineClass spring_boot = new OnlineClass(1, \u0026#34;spring boot\u0026#34;, true); // 이슈상황 → 참조형 멤버 변수 사용 시 초기화 되지 않아 null 값을 참조 할 수 있다. Duration studyDuration = spring_boot.getProgress().getStudyDuration(); // NullPointExecption 발생 System.out.println(studyDuration); 모든 객체타입은 null을 갖을 수 있기 때문에 해당 값이 null인지 아닌지는 run time에 정확히 알지 못할 수가 있어 NPE를 발생시킬 여지가 있다.\nOptional 등장 이전 해결방법 사전에 null 체크\npublic Progress getProgress() { if (progress == null) { throw new IllegalStateException(); } return progress; } 이는 에러에 대한 스택트레이스를 뽑게 되고 이또한 리소스 낭비가 될 수 있다.\n클라이언트 코드에서 null 체크\nProgress progress = spring_boot.getProgress(); if (progress != null) { System.out.println(progress.getStudyDuration()); } } 사용하는 시점에 null을 체크하는 방법도 존재하는데 이러면 get 메서드마다 null을 체크하는 코드를 작성해줘야 하고, 비즈니스로직보다 null 체크 코드가 더 길어져 가독성이 떨어질 수 있다.\n이러한 문제들을 스칼라나 하스켈과 같은 함수형 언어들은 존재할지 안 할지 모르는 값을 표현할 수 있는 타입을 가지고 있고 자바도 처음 만들어졌을떄 존재하지 않는 값을 표현하기 위해 null을 만들었다면 이번에는 위 언어들의 컨셉을 모티브로 Optional API를 만들고 null 처리를 Optional에게 위임하는 방법으로 해결하고자 추가되었다.\n장점 NPE를 유발할 수 있는 null을 직접 다루지 않아도 된다. 수고롭게 null 체크를 직접 하지 않아도 된다. 명시적으로 해당 변수가 null일 수도 있다는 가능성을 표현할 수 있다. (따라서 불필요한 방어 로직을 줄일 수 있다!) 주의사항 (sub. Optional 올바르게 사용하는 법) 1. Optional 변수에 null 대신 Optional.empty() 사용 Optional\u0026lt;Car\u0026gt; optionalCar = null; Optional\u0026lt;Car\u0026gt; optionalCar = Optional.empty(); Optional도 결국 객체이기 때문에 null이 들어갈 수 있는데 이는 또다른 NPE를 유발하는 코드이기 때문에 emtpy()메서드로 비어있는 값을 정의하자.\n2. Optional 값을 꺼내쓰기 전에 값이 있는지 확인하기 Optional\u0026lt;Car\u0026gt; optionalCar = Optional.empty(); Car car = optionalCar.get(); //NoSuchElementException 발생 Optional은 값이 비어있을 수도 있기 때문에 사용하기전에 존재한다는 것을 증명해야 하는데 일반적으로는 isPresent()후에 get()을 사용할 수 있지만 코드도 길어지고 한번에 사용할 수 있는 API를 제공하기 때문에 이를 사용하는 것이 바람직하다.\n//isPresent - get if(optionalCar.isPresent()){ return optionalCar.get(); }else { return null; } //orElse return optionalCar.orElse(null); //orElseGet return optionalCar.orElseGet(() -\u0026gt; null); 이때 orElseGet()은 Supplier를 인자로 받으며, 값이 없을때에 해당 supplier가 수행된다. 하지만 orElse()는 Optional로 감싸고 있는 객체타입을 인자로 받으며 값이 있더라도 내부가 수행되고 사용되지 않는 경우 해당 객체를 지우게 되어 필요없는 오버헤드가 발생한다.\n//source code Optional\u0026lt;String\u0026gt; optStr = Optional.of(\u0026#34;Hi\u0026#34;); optStr.orElse(new String(\u0026#34;hi1\u0026#34;)); optStr.orElseGet(() -\u0026gt; new String(\u0026#34;hi1\u0026#34;)); //bytecode L1 LINENUMBER 9 L1 ALOAD 1 NEW java/lang/String DUP LDC \u0026#34;hi\u0026#34; INVOKESPECIAL java/lang/String.\u0026lt;init\u0026gt; (Ljava/lang/String;)V INVOKEVIRTUAL java/util/Optional.orElse (Ljava/lang/Object;)Ljava/lang/Object; POP L2 LINENUMBER 11 L2 ALOAD 1 INVOKEDYNAMIC get()Ljava/util/function/Supplier; [ // handle kind 0x6 : INVOKESTATIC java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; // arguments: ()Ljava/lang/Object;, // handle kind 0x6 : INVOKESTATIC study/OptionalEx.lambda$main$0()Ljava/lang/String;, ()Ljava/lang/String; ] INVOKEVIRTUAL java/util/Optional.orElseGet (Ljava/util/function/Supplier;)Ljava/lang/Object; POP ... private static synthetic lambda$main$0()Ljava/lang/String; L0 LINENUMBER 11 L0 NEW java/lang/String DUP LDC \u0026#34;hi\u0026#34; INVOKESPECIAL java/lang/String.\u0026lt;init\u0026gt; (Ljava/lang/String;)V ARETURN MAXSTACK = 3 MAXLOCALS = 0 } 예를 들어 위와 같은 코드를 작성했을때 optStr은 null이 아니라 new String(\u0026ldquo;hi1\u0026rdquo;)가 실행되지 않을 것 같지만 바이트코드를 보면 새로 문자열을 생성했다가 POP하는 것을 볼 수 있고, orElseGet()은 우리가 lambda에서 봤던것처럼 static 메서드로 생성하여 호출되는 타이밍에 이를 실행해 객체를 생성하는 것을 볼수있어 orElse는 필요없는 오버헤드에 주의해야한다. 하지만 반드시 이미 생성되어있는 객체를 반환하는 것이라면 orElse()를 사용하는 것이 좋을 수도 있다.\n//before if(optionalCar.isPresent()){ return optionalCar.get(); }else { throw new NoSuchElementException(); } //after optionalCar.orElseThrow(); 예외처리를 하는 경우에도 isPresent()를 통한 예외처리보다는 orElseThrow()를 이용하여 예외처리를 하는 것이 바람직하다. 인자로 Supplier를 통해 특정 Exception을 던질 수 있는데 아무것도 주지 않으면 기본적으로 NoSuchElementException을 던진다.\n3. Optional이 있을때만 이를 소비하여 무언가를 할때는 isPresent()가 아닌 ifPresent()를 활용 //before if(optionalCar.isPresent()){ System.out.println(optionalCar.get()); } //after optionalCar.ifPresent(System.out::println); 이도 orElse()와 같은 메서드들과 같은 이유로 별도로 API를 제공하기 때문에 필요없는 조건절을 추가하지 말고 API를 활용해보자.\n4. 컬렉션은 Optional대신 비어있는 컬렉션을 사용하자. //before List\u0026lt;Car\u0026gt; cars = carFactory.getCars(); return Optional.ofNullable(cars); //after List\u0026lt;Car\u0026gt; cars = carFactory.getCars(); return cars != null ? cars : Collections.emptyList(); 컬렉션들은 자체적으로 비어있는 값을 표현할 수 있는 자료구조이다. 때문에 Optional을 사용할 필요가 없다.\n5. 컬렉션은 Optional로 감싸지말자. 컬렉션 자체가 데이터를 감싼 형태의 객체이고 이도 충분한 API를 제공하기 때문에 한번더 Optional로 감싸면 필요없는 오버헤드가 발생한다. JPA의 메서드를 생성할때도 JPA자체적으로 비어있는 컬렉션을 반환해주므로 Optional로 감쌀 필요가 없다.\n//bad Optional\u0026lt;List\u0026lt;Car\u0026gt;\u0026gt; findAllByCompanyName(String name); //good List\u0026lt;Car\u0026gt; findAllByCompanyName(String name); 6. 컬렉션,Map의 원소로 Optional을 사용하지 말자. 컬렉션이나 Map에 들어가는 값들은 애초에 null이 아님을 전제조건으로 만들어진 자료구조이기 때문에 Optional을 사용할 필요가 없다.\n7. 단일 값을 얻기 위한 목적으로 메서드 체이닝을 하지말자. //bad String status = \u0026#34;on\u0026#34;; return Optional.ofNullable(status).orElse(\u0026#34;PENDING\u0026#34;); //good status == null ? \u0026#34;PENDING\u0026#34; : status; Optional을 사용하는 것은 결국 또하나의 래퍼객체를 사용하는 것이므로 단순한 로직이라면 그냥 코딩하자. 구관이 명관이라했다.\n8. Optional을 필드로 사용하지말자. public class Car { private Optional\u0026lt;Navigation\u0026gt; navigation = Optional.empty(); //bad } Optional은 애초에 필드로 사용할 목적으로 만들어지지 않아 Serializable도 구현하지 않았기 때문에 사용을 지양해야 한다.\n9. Optional을 메서드,생성자 인자로 사용하지말자. //bad public void render(Optional\u0026lt;Renderer\u0026gt; renderer){ renderer.orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;null 일 수 없습니다.\u0026#34;)); //... } //good public void render(Renderer renderer){ if(renderer == null){ throw new IllegalArgumentException(\u0026#34;null 일 수 없습니다.\u0026#34;); } //... } 이러한 방법은 불필요하게 코드를 복잡하게 할 뿐아니라 이를 호출하는 쪽에서도 Optional 생성을 강제하게 하는 것이다. 또한, Optional은 하나의 객체로 이를 호출하는 것이 결코 비용이 저렴하지 않다.\n10. null이 확실하면 ofNullable()이 아닌 of()를 사용하자. //bad Optional.ofNullable(\u0026#34;NULL일 수 없지!\u0026#34;); //good Optional.of(\u0026#34;NULL일 수 없지!\u0026#34;); //ofNullable public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; ofNullable(T value) { return value == null ? empty() : of(value); } ofNullable은 내부적으로 보면 삼항연산자를 통해 비어있지 않는 경우 of를 호출하는 것을 볼 수있다. 그렇기 때문에 이러한 연산을 조금이라도 줄일 수 있기 때문에 of를 사용하자.\n11. Optional의 타입이 Primitive타입이면 OptionalInt,OptionalLong, OptionalDouble을 사용하자 //bad Optional\u0026lt;Integer\u0026gt; max = Optional.of(10); for(int i=0; i \u0026lt; max.get(); i++) //good OptionalInt max = OptionalInt.of(10); for(int i=0; i \u0026lt; max.getAsInt(); i++) //byte code L0 LINENUMBER 10 L0 BIPUSH 10 INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; INVOKESTATIC java/util/Optional.of (Ljava/lang/Object;)Ljava/util/Optional; ASTORE 0 L1 LINENUMBER 12 L1 BIPUSH 10 INVOKESTATIC java/util/OptionalInt.of (I)Ljava/util/OptionalInt; ASTORE 1 내부적으로 Integer.valueOf()를 통해 한번 boxing이 일어나는 것을 볼 수 있고 또 이를 사용할때 unboxing이 일어나기 때문에 OptionalInt를 사용하는 것이 좋다.\n12. Optional을 리턴하는 메서드에서 null을 리턴하지 말자. public static Optional\u0026lt;String\u0026gt; hi(){ return null; } 당연한거지만 Optional도 객체이기 때문에 null을 리턴이 가능한데 이렇게 리턴하게 되면 Optional을 사용하는 것이 의미가 없기 때문에 null을 리턴하지 말자.\nOptional API 1. Optional 생성 선언하기\n제네릭을 제공하기 때문에, 변수를 선언할 때 명기한 타입 파라미터에 따라서 감쌀 수 있는 객체의 타입이 결정된다.\nOptional\u0026lt;Order\u0026gt; maybeOrder; // Order 타입의 객체를 감쌀 수 있는 Optional 타입의 변수 Optional\u0026lt;Member\u0026gt; optMember; // Member 타입의 객체를 감쌀 수 있는 Optional 타입의 변수 Optional\u0026lt;Address\u0026gt; address; // Address 타입의 객체를 감쌀 수 있는 Optional 타입의 변수 변수명은 그냥 클래스 이름을 사용하기도 하지만 maybe나 opt와 같은 접두어를 붙여서 Optional 타입의 변수라는 것을 좀 더 명확히 나타내기도 한다.\n객체 생성하기\nOptional.empty() : null을 담고 있는, 한 마디로 비어있는 Optional 객체를 얻어온다.\nOptional\u0026lt;Member\u0026gt; maybeMember = Optional.empty(); 이 비어있는 객체는 Optional 내부적으로 미리 생성해놓은 싱글턴 인스턴스이다.\nOptional.of() : null이 아닌 객체를 담고 있는 Optional 객체를 생성\nOptional\u0026lt;Member\u0026gt; maybeMember = Optional.of(aMember); null이 넘어올 경우, NPE를 던지기 때문에 주의해서 사용하자!\nOptional.ofNullable() : null인지 아닌지 확신할 수 없는 객체를 담고 있는 Optional 객체를 생성\nOptional\u0026lt;Member\u0026gt; maybeMember = Optional.ofNullable(aMember); Optional\u0026lt;Member\u0026gt; maybeNotMember = Optional.ofNullable(null); Optional.empty()와 Optional.ofNullable(value)를 합쳐놓은 메소드로 이해하면 편하다. null이 넘어올 경우, NPE를 던지지 않고 Optional.empty()와 동일하게 비어 있는 Optional 객체를 얻어온다.\n해당 객체가 null인지 아닌지 자신이 없는 상황에서는 이 메소드를 사용하자.\n2. Optional 값 여부 확인 isPresent() : 값이 있으면 true, 없으면 false isEmpty() : Java11부터 제공하며 값이 없으면 true, 값이 있으면 false 3. Optional 값 가져오기 아래 메소드들은 모두 Optional이 담고 있는 객체가 존재할 경우 동일하게 해당 값을 반환하지만, Optional이 비어있는 경우(null을 담고 있는 경우), 다르게 작동한다.\nget() : null일 경우 NoSuchElementException 발생히고 가급적 사용을 하지 않는 것을 권장한다.\norElse(T other) : null일 경우 넘어온 인자(T) 를 반환한다.\norElseGet(Supplier\u0026lt;? extends X\u0026gt;) : null일 경우 넘어온 함수형 인자를 통해 생성된 객체를 반환한다.\norElse(T other)의 게으른 버전으로 비어있는 경우에만 함수가 호출되기 때문에 orElse(T other) 대비 성능상 이점을 기대할 수 있다.\norElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier) : null일 경우 넘어온 함수형 인자를 통해 생성된 예외(를 던진다. (default : NoSuchElementException)\nifPresent(Consumer) : 값이 있는 경우 값을 가지고 Consumer 함수 동작한다.\n// 1. get() OnlineClass onlineClass = optional.get(); // NoSuchElementException 발생 // 2. isPresent() + get() = 먼저 확인후 꺼낸다 번거롭다 if (optional.isPresent()) { OnlineClass onlineClass = optional.get(); System.out.println(onlineClass.getTitle()); } // 3. ifPresent(Consumer) = 값이 있는 경우만 함수가 동작한다! optional.ifPresent(oc -\u0026gt; System.out.println(oc.getTitle())); 4. Optional 필터/변환 Optional map(Function)\n// AS-WAS //주문을 한 회원이 살고 있는 도시를 반환하는 메소드다. (기본값은 Seoul 이다.) public String getCityOfMemberFromOrder(Order order) { if (order == null) { return \u0026#34;Seoul\u0026#34;; } Member member = order.getMember(); if (member == null) { return \u0026#34;Seoul\u0026#34;; } Address address = member.getAddress(); if (address == null) { return \u0026#34;Seoul\u0026#34;; } String city = address.getCity(); if (city == null) { return \u0026#34;Seoul\u0026#34;; } return city; } // TO-BE public String getCityOfMemberFromOrder(Order order) { return Optional.ofNullable(order) .map(Order::getMember) .map(Member::getAddress) .map(Address::getCity) .orElse(\u0026#34;Seoul\u0026#34;); } 기존의 방식으로 null check를 하면서 코드를 작성하면 사방에서 return 해줘야 하여 가독성이 떨어지고, 유지보수가 좋지 않은 코드가 있다.\n하지만 Optional과 map을 이용하면 전통적인 NPE 방어 패턴에 비해 훨씬 간결하고 명확해진다!\n우선 기존에 존재하던 조건문들이 모두 사라지고 Optional의 수려한(fluent) API에 의해서 단순한 메소드 체이닝으로 모두 대체된다.\n메소드 체이닝 설명 ofNullable() 정적 팩토리 메소드를 호출하여 Order 객체를 Optional로 감싸고 혹시 Order 객체가 null인 경우를 대비하여 of() 대신에 ofNullable()을 사용하는 것이다. 3번의 map() 메소드의 연쇄 호출을 통해서 Optional 객체를 3번 변환한다. 매 번 다른 메소드 레퍼런스를 인자로 넘겨서 Optional에 담긴 객체의 타입을 바꿔준다. 마무리 작업으로 orElse() 메소드를 호출하여 이 전 과정을 통해 얻은 Optional이 비어있을 경우, 디폴트로 사용할 도시 이름을 세팅해주면 된다. Optional filter(Predicate)\nif (obj != null \u0026amp;\u0026amp; obj.do() ...) Java8 이 전에 NPE 방지를 위해서 위와 같이 null 체크로 시작하는 if 조건문 패턴을 많이 사용해왔고 이러한 패턴을 이용해서 주어진 시간(분) 내에 생성된 주문을 한 경우에만 해당 회원 정보를 구하는 메소드를 작성해보면 아래와 같다.\npublic Member getMemberIfOrderWithin(Order order, int min) { if (order != null \u0026amp;\u0026amp; order.getDate().getTime() \u0026gt; System.currentTimeMillis() - min * 1000) { return order.getMember(); } } 위 코드의 문제점은 두가지가 존재하게 된다. 첫번째로 if 조건문 내에 null 체크와 비지니스 로직이 혼재되어 있어서 가독성이 떨어진다는 점이다. 두번째로는 null을 리턴할 수 있기 때문에 메소드 호출부에 NPE 위험을 전파하고 있다는 것이다.\n이런 문제점 해결하고자 filter를 적용하면 아래와 같이 코드를 작성 할 수 있다.\npublic Optional\u0026lt;Member\u0026gt; getMemberIfOrderWithin(Order order, int min) { return Optional.ofNullable(order) .filter(o -\u0026gt; o.getDate().getTime() \u0026gt; System.currentTimeMillis() - min * 1000) .map(Order::getMember); } Optional과 filter를 이용하면 if 조건문 없이 메소드 연쇄 호출만으로도 좀 더 읽기 편한 코드를 작성할 수 있을 뿐만 아니라, 메소드의 리턴 타입을 Optional로 사용함으로써 호출자에게 해당 메소드가 null을 담고 있는 Optional을 반환할 수도 있다는 것을 명시적으로 알려준다.\nOptional flatMap(Function) : Optional 안의 인스턴스가 Optional인 경우 사용하면 편리하며 Stream에서 사용하는 경우와 비슷하게 Optional을 한번 분리해서 쪼개주는 걸 뜻한다.\nReference 백기선 인프런 강의 : 더 자바, Java8 https://dzone.com/articles/using-optional-correctly-is-not-optional "},{"section":"Blog","slug":"/blog/java/interface/","title":"인터페이스","description":"java의 인터페이스와 java8,9에 추가된 기능을 설명합니다.","date":"2021년 12월 8일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"1. 인터페이스란? 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 유지보수를 용이하게 하기 위함\n다형성? 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력\n1) 추상클래스와 인터페이스 차이 추상메서드를 가짐으로써 다형성을 극대화하면서 어떤 역할을 구현하는 방법(객체들이 따라야 하는 책임의 집합을 서술한 것)이라는 공통점이 있다.\n하지만 추상 클래스는 is-a관계로 -는 -이다. 의 개념이며 책임의 일부를 구현해놓은 것이고 인터페이스는 has-a의 관계로 -는 -를 할 수 있다 의 개념으로 책임의 집합들을 나열해 놓은 것.\n이때 이러한 관계가 객체지향에 있어 중요한 것은 객체의 속성이 아니라 객체의 행동간의 관계라는 것.\n한마디로 닭은 새다, 맥은 os이다 와 같은 문장이 있을때 이 문장들 앞에 클라이언트 입장에서 라는 말이 빠져있는 것이다. 실제 세계의 관점으로 바라보며 객체간의 관계를 정의하는 것이 아닌 이 객체들을 사용하는 클라이언트 입장에서 바라보며 특정 객체의 행동을 통해 관계를 맺어야 한다.\n서브 클래싱과 서브 타이핑\n서브 클래싱 : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우. 자식과 부모클래스간의 행동이 호환되지 않아 자식인스턴스가 부모인스턴스를 대체할 수없고 이를 구현 상속 / 클래스 상속이라고 부른다. 서브 타이핑 : 타입 계층을 구성하기 위해 상속을 사용하는 경우. 자식과 부모클래스간의 행동이 호환되어 인스턴스를 대체할 수 있다. 조영호님의 오브젝트 서적 이미지\r2) 인터페이스의 장점 개발 기간 단축 팀내에서 서로 다른 부분을 개발할 때 인터페이스만 잘 정의해두어도 서로의 개발이 끝나지 않아도 따로 코드를 작성할 수 있다. 클래스간의 낮은 결합도 코드의 종속을 줄이고 유지보수성을 높일 수 있다. 표준화 가능 협업 시에도 일정한 틀의 형태로 개발을 할 수 있게 한다. 3) 인터페이스 특징 필드로는 상수만 가능 (변수는 불가능 하다.) : 무조건 public static final로 선언 되며 생략 가능 추상 메서드 존재 : 무조건 public abstract으로 선언되며 생략 가능 4) 추상클래스의 한계 추상클래스는 단일 상속을 원칙으로 한다.\n상속의 가장 큰 문제점은 캡슐화를 위반한다는 것과 설계가 유연하지 않다는 것.\n코드의 재사용을 위해서는 상속이 아니라 합성을 사용하는 것이 바람직하고 상속은 타입계층을 구조화하기 위해 사용해야 한다.\n의존성에 의한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것이 좋은 설계 습관이다.\n메소드 오버라이딩 문제 해결했지만.. 예를 들어, Person 인터페이스에서 메서드 a(), b(), c(), d() 를 제공한다고 하자.\n이를 구현하는 Jun, Hong, Chang 클래스가 존재하고 각각 필요한 메서드는 하나씩 밖에 없는 상황이다.\n필요한 메서드가 아니라도 인터페이스 특성상, 모든 메서드를 오버라이딩 해야만 하는 이슈가 있다.\nJava8 이전에는 추상클래스를 활용하여 이 문제를 해결하였다.\n해결하지 못한 문제 매번 Adapter 추상클래스를 만들어야한다. 다중 상속이 불가능하다. 이러한 문제를 해결하기 위해 Java8 인터페이스에는 어떤 변화가 있었는지 알아보자.\n2. Java8 변화: 인터페이스의 기본 메소드와 스태틱 메소드 Java 8 부터는 인터페이스에도 메소드 선언뿐만 아니라 default method 와 static method를 통해 구현이 가능해졌다.\n1) Default method (기본 메소드) 추상 메서드가 아니라 구현이 된 메서드를 제공하는 방법으로 코드의 중복을 피하고 기능을 추가할 때 사용\n하위 호환성 이 가장 큰 목적으로 어떤 인터페이스에 기능을 추가했을때 이를 상속, 구현한 클래스들이 깨지지 않게 하기위한 목적으로 default 메서드를 사용할 수 있다. 대표적으로 Collection의 of나 forEach 등이 있다. 람다를 활용할 수 있는 기술 중 하나로 일종의 무한한 데이터의 흐름. 배열 또는 컬렉션, Map과 같은 자료구조들을 하나의 데이터 흐름으로 만듦으로서 함수 여러개를 chaning하여 코드의 양을 줄이고 간결하게 표현할 수 있게 해준다. public interface Foo { void printName(); } public class DefaultFoo implements Foo{ @Override public void printName() { System.out.println(\u0026#34;DefaultFoo\u0026#34;); } } Foo 인터페이스를 구현하는 클래스가 많아지면, 새로운 기능의 메소드를 선언했이 추가됐을 때 구현체 모두 컴파일 에러가 발생.\n이를 해결하기 위해, Default Method 등장!\npublic interface Foo { void printName(); // 기본 메소드(Default Method) default void printNameUpperCase(){ System.out.println(\u0026#34;FOO\u0026#34;); } } public static void main(String[] args){ Foo foo = new DefaultFoo(); foo.printName(); foo.printNameUpperCase(); } 장점 : 해당 인터페이스를 구현한 클래스를 깨트리지 않고 새 기능을 추가할 수 있음. 주의할 점 : 기본 메소드는 구현체가 모르게 추가된 기능이기 때문에, 문제가 생길 수 있음. public interface Foo { void printName(); default void printNameUpperCase() { System.out.println(getName().toUpperCase()); } String getName(); // Name 값이 항상 있다고 보장할 수 없다. // name = null -\u0026gt; NullPointException } 컴파일 에러는 아니지만 구현체에 따라 런타임 에러 발생 가능 반드시 문서화 (@ImplSpec 자바독 태그 사용) /** * @ImplSpec * 이 구현체는 getName()으로 가져온 문자열을 대문자로 변환 후 출력한다. */ default void printNameUpperCase() { // null 방지 하여 구현 if(getName() == null) System.out.println(\u0026#34;\u0026#34;); System.out.println(getName().toUpperCase()); } 이래도 문제가 발생하는 경우는 구현 클래스에서 Overriding 을 이용해 재정의 할 수 있다.\n주의할 점 Object가 제공하는 기능은 default 메소드로 제공할 수 없다. equals, hashCode, toString 등 구현체가 재정의 해야한다! 인터페이스에서 추상 메서드로 선언하는 것은 괜찮다. 모두 공통으로 제공하기 때문에 추상 메서드로 분류하지 않는다. 본인이 수정할 수 있는 인터페이스만 수정 가능하다. 인터페이스를 상속받는 인터페이스에서 다시 추상 메소드로 변경할 수 있다. Diamond Problem\n구현체가 상속받는 두 인터페이스 모두 동일한 기본 메소드가 있는 경우? public interface Foo { default void getNameUpperCase() { ... } } public interface Bar extends Foo { void getNameUpperCase(); // 추상 메서드로 선언한 경우 구현 클래스에서 재정의 필수 // 추상 메서드로 선언 하지 않은 경우 상위 인터페이스 그대로 사용 가능 } public interface Foo { default void getNameUpperCase() { System.out.println(\u0026#34;Foo\u0026#34;); } } public interface Bar { default void getNameUpperCase() { System.out.println(\u0026#34;Bar\u0026#34;); } } public class Test implements Foo, Bar { ... // @Override // public void printNameUpperCase() { // ... // } } Error: DefaultFoo inherits unrelated defaults for printNameUpperCase() from types Foo and Bar\nBar, Foo 중 무엇을 사용할지 모르기 때문에 컴파일 에러 발생 충돌하는 default method 직접 override 해야한다. 2) Static method (정적 메소드) 인스턴스 없이 수행할 수 있는 행동을 정의 한 것\n해당 인터페이스를 구현한 모든 인스턴스나 해당 타입에 관련된 헬퍼 또는 유틸리티 메소드를 제공할 때 인터페이스에 static method 제공 가능\npublic interface Foo { void printName(); default void hello(){ System.out.println(\u0026#34;Foo\u0026#34;); } static void helloAll(){ System.out.println(\u0026#34;인삿말\u0026#34;); } } public class App { public static void main(String[] args) { Foo foo = new DefaultFoo(); foo.hello(); Foo.helloAll(); // static 메소드 사용 } } ✅ 바이트 코드\npublic interface ExInterface { static String staticMethod(){ return \u0026#34;스태틱 메서드입니다\u0026#34;; } } // byte code public static method()I L0 LINENUMBER 5 L0 ICONST_1 IRETURN MAXSTACK = 1 MAXLOCALS = 0 } 접근지정자를 생략하면 기본적으로 public이 붙게되고 java8에서는 static method가 public만 가능하지만 java9 이상부터는 private도 가능하다. 당연히 private이기 때문에 외부에서는 접근이 불가능하다.\nprivate 메서드의 조건\n구현부가 존재해야 한다. 해당 인터페이스 내부에서만 사용이 가능하다. 3. 자바8 API의 기본 메소드와 스태틱 메소드 JAVA8 에서 추가된 기본 메소드로 인해 API 에 변화에 대해 알아보자\n1) Iterable 공식 문서 순회를 편하게 할 수 있다!\n대부분 혼자서 사용하는 경우는 거의 없고 Collection에 포함되어서 사용한다.\nforEach() public static void main(String[] args) { List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;yj\u0026#34;); names.add(\u0026#34;youngjun\u0026#34;); names.add(\u0026#34;spring\u0026#34;); names.add(\u0026#34;java8\u0026#34;); names.forEach(System.out::println); // for (String name : names) { // System.out.println(name); // } } names.forEach(System.out::println) forEach 는 내부 엘리먼트를 순회하며 각각의 요소들을 파라미터로 전달된 일급함수에 Functional Interface인 Consumer가 들어오고 처리. 단순 출력만 하기 때문에 메소드 레퍼런스 기능을 이용해 간결하게 작성! for-of{\u0026hellip;} 기존에는 for-of 문을 사용해 출력이 가능하다고 함. 하지만 조금이나마 더 간결한 forEach를 사용하는 것이 좋아 보임. 2) Collection Iterable 을 상속받는 인터페이스다!\n공식 문서 Spliterator iterator 와 비슷한 개념이지만 Collection 을 분할한다는 점에서 차이가 있음.\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;yj\u0026#34;); names.add(\u0026#34;youngjun\u0026#34;); names.add(\u0026#34;spring\u0026#34;); names.add(\u0026#34;java8\u0026#34;); Spliterator\u0026lt;String\u0026gt; spliterator = names.spliterator(); while(spliterator.tryAdvance(System.out::println)); } Spliterator spliterator = names.spliterator(); iterator와 비슷하지만 분할할 수 있는 기능을 가진 Iterator 를 만들어 반환 spliterator.tryAdvance(System.out::println) iterator의 hasNext()메소드와 유사 다만 내부 메소드에 파라미터로 forEach()와 동일하게 Functional Interface인 Consumer가 들어오고 더 이상 들어올게 없을 경우 false를 반환 이 예제에서는 들어온 값을 단순 출력하는 메소드 레퍼런스를 사용 여기까지는 iterator와 차이가 없다. trySplit을 사용해보자.\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;yj\u0026#34;); names.add(\u0026#34;youngjun\u0026#34;); names.add(\u0026#34;spring\u0026#34;); names.add(\u0026#34;java8\u0026#34;); Spliterator\u0026lt;String\u0026gt; spliterator = names.spliterator(); Spliterator\u0026lt;String\u0026gt; trySplit = spliterator.trySplit(); while(spliterator.tryAdvance(System.out::println)); System.out.println(\u0026#34;=========================\u0026#34;); while(trySplit.tryAdvance(System.out::println)); } /* [실행 결과] spring java8 ========================= yj youngjun */ Spliterator trySplit = spliterator.trySplit();\nspliterator에서 trySplit()메소드를 호출하게되면 해당 spliterator에서 앞에서부터 절반의 요소를 꺼내 새로운 spliterator를 만들어 반환 trySplit() 실행 결과\rwhile(spliterator.tryAdvance(System.out::println));\ntrySplit()을 통해 앞의 두 String(yj, youngjun)이 분할되어 빠져나갔기 때문에 뒤의 두 값만 출력 while(trySplit.tryAdvance(System.out::println));\nspliterator 에서 가져온 앞 두 값(yj, youngjun)을 출력 removeIf Collection 요소를 순회하며 인자로 넘겨주는 함수를 Functional Interface인 Predicate에 넘겨줘서 true 이면 삭제\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;yj\u0026#34;); names.add(\u0026#34;youngjun\u0026#34;); names.add(\u0026#34;spring\u0026#34;); names.add(\u0026#34;java8\u0026#34;); names.removeIf(s -\u0026gt; s.startsWith(\u0026#34;y\u0026#34;)); names.forEach(System.out::println); } names.removeIf(s -\u0026gt; s.startsWith(\u0026ldquo;y\u0026rdquo;)); names를 순회하며 각 요소들 중 단어가 \u0026lsquo;y\u0026rsquo;로 시작하는 단어를 찾아 삭제 etc 이후에 자세히 다룰 예정이다.\nStream() parallelStream() 3) Comparator 공식문서 정렬에 사용되는 인터페이스\nreversed 정렬을 역순으로!\npublic static void main(String[] args) { List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); names.add(\u0026#34;yj\u0026#34;); names.add(\u0026#34;youngjun\u0026#34;); names.add(\u0026#34;spring\u0026#34;); names.add(\u0026#34;java8\u0026#34;); Comparator\u0026lt;String\u0026gt; compareToIgnoreCase = String::compareToIgnoreCase; names.sort(compareToIgnoreCase.reversed()); names.forEach(System.out::println); } Comparator compareToIgnoreCase = String::compareToIgnoreCase 메소드 레퍼런스를 메소드 체이닝 방식으로 사용할수는 없기에 분리하여 Comparator 타입의 Functional Interface인 compareToIgnoreCase 를 만들어준다. names.sort(compareToIgnoreCase.reversed()); 미리 선언해놓은 String 의 정렬 기준 메소드 레퍼런스에 reversed() 메소드를 호출해 역순으로 정렬 ❓ 만약, 여기서 다음 정렬조건을 사용하여 정렬을 이어가고싶다면 thenComparing() 메소드를 이용하여 추가적인 정렬을 할 수 있다.\nstatic reverseOrder() / naturalOrder() 특정 타입의 Comparable이 지정되어있으면 일단 그 기준으로 역순이든 자연순이든 세팅해서 정렬함. etc static nullIsFirst() / nullIsLast() static comparing() Reference\n백기선 인프런 강의 : 더 자바, Java8 Catsbi\u0026rsquo;s DLog : 인터페이스의 변화 https://github.com/gowoonsori/my-tech/blob/master/java/java8/interface.md https://github.com/gowoonsori/my-tech/blob/master/java/java8/stream.md https://dev-milk.tistory.com/5 https://futurecreator.github.io/2018/08/26/java-8-streams-advanced/ https://mangkyu.tistory.com/115 "},{"section":"Blog","slug":"/blog/books/object/","title":"오브젝트: 코드로 이해하는 객체지향 설계","description":"오브젝트: 코드로 이해하는 객체지향 설계를 읽고 정리한 글","date":"2021년 11월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/object/preview_hu6e816ae32794499d251c67053c418573_54386_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"526\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/object\\/preview_hu6e816ae32794499d251c67053c418573_54386_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/object/preview_hu6e816ae32794499d251c67053c418573_54386_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/object\\/preview_hu6e816ae32794499d251c67053c418573_54386_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"1. 객체지향 설계 설계란 코드를 배치하는 것이다. 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계 요구사항은 항상 변하기 마련이다. 2. 객체지향 프로그래밍 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD 패턴 이라고 한다. 자식 클래스가 부모 클래스를 대신 하는 것이 업캐스팅 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다. 대부분의 사람들은 코드 재사용을 상속의 주된 목적이라고 생각하지만 이것은 오해다. 인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다. 상속의 가장 큰 문제점은 캡슐화를 위반한다는 것. 상속의 두번째 단점은 설계가 유연하지 않다는 것 3. 역할, 책임, 협력 코드를 재사용하는 경우에는 상속보다 합성을 선호하는 것이 옳지만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을 함께 조합해서 사용할 수 밖에 없다. 객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력이다. 객체지향 설계에서 가장 중요한 것은 책임이다. 객체에게 얼마나 적절한 책임을 할당하느냐가 설계의 전체적인 품질을 결정한다. 역할을 구현하는 가장 일반적인 방법은 추상 클래스와 인터페이스를 사용하는 것 협력의 관점에서 추상 클래스와 인터페이스는 구체 클래스들이 따라야 하는 책임의 집합을 서술한 것이다. 추상 클래스는 책임의 일부를 구현해 놓은 것이고 인터페이스는 일체의 구현 없이 책임의 집합만을 나열해 놓았다는 차이가 있지만 협력의 관점에서는 둘 모두 역할을 정의할 수 있는 구현 방법이라는 공통점을 공유한다. 4. 메시지와 인터페이스 강조하고 싶은 것은 소프트웨어 설계에 법칙이란 존재하지 않는다 라는 것이다. 원칙을 맹신하지 마라. 원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 길러라. 설계는 트레이드오프의 산물이다. 소프트웨어 설계에 존재하는 몇 안되는 법칙 중 하나는 경우에 따라 다르다 라는 사실을 명심해라. 프로시저는 부수효과를 발생시킬 수 있지만 반환할 수 없다. 함수는 값을 반환할 수 있지만 부수효과는 발생시킬 수 없다. 5. 객체 분해 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다. 그러나 하향식은 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다. 이것은 수학과 아주 유사하다. 수학 교과서는 계산의 과정을 논리적인 순서로 서술한다. 공인되고 증명된 이론이 뒤이은 이론을 증명하기 위해 사용된다.\n그러나 이론은 그런 방식이나 순서로 개발되거나 발견된 것이 아니다. 시스템이나 프로그램 개발자가 이미 완료한 결과에 대한 명확한 아이디어를 가지고 있다면 머리속에 있는 것을 종이에 서술하기 위해 하향식을 사용할 수 있다. 이것은 사람들이 하향식 설계나 개발을 할 수 있고, 그렇게 함으로써 성공할 수 있다고 믿게 만드는 이유다. 하향식 단계가 시작될 때는 문제는 이미 해결됐고, 오직 해결돼야만 하는 세부사항만이 존재할 뿐이다.\n클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다는 점\n6. 의존성 관리하기 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술 의존성에 의한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계 습관이다. 7. 유연한 설계 표현적 분해는 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것이다. 표현적 분해는 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다. 유연한 설계는 유연성이 필요할 때만 옳다. 8. 상속과 코드 재사용 역할, 책임 협력에 먼저 집중하라. 3가지의 모습이 선명하게 그려지지 않는다면 의존성을 관리하는 데 들이는 모든 노력이 물거품이 될 수도 있다는 사실을 명심하라. 코드 중복을 제거하기 위해 상속을 도입할때 따르는 두가지 원칙이 있다. 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다. 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다. 상속으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다. 상속은 어떤 방식으로든 부모 클래스와 자식 클래스를 결합시킨다. 메서드 구현에 대한 결합은 추상 메서드를 추가함으로써 어느정도 완화할 수 있지만 인스턴스 변수에 대한 잠재적인 결합을 제거 할 수 있는 방법은 없다. 9. 합성과 유연한 설계 상속이 코드 재사용이라는 측면에서 강력한 도구인 것은 사실이지만 강력한 만큼 잘못 사용할 경우에 돌아오는 피해 역시 크다는 사실을 뼈저리게 경험한 것이다.\n상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다. 정말로 필요한 경우에만 상속을 사용하라. 상속은 코드 재상용과 관련된 대부분의 경우에 우아한 해결방법이 아니다.\n객체지향에 능숙한 개발자들은 상속의 단점을 피하면서도 코드를 재사용할 수 있는 더 좋은 방법이 있다는 사실을 알고 있다. 바로 합성이다.\n상속은 합성과 재사용의 대상이 다르다. 상속은 부모 클래스 안에 구현된 코드자체를 재사용하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다. 따라서 상속 대신 합성을 사용하면 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경할 수 있다. 다시 말해서 클래스 사이의 높은 결합도를 객체 사이의 낮은 결합도로 대체할 수 있는 것이다.\n몽키 패치란 현재 실행중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 것을 가리킨다. 코드를 수정할 권한이 없거나 소스코드가 존재하지 않든다고 가정하더라도 몽키패치가 지원되는 환경이라면 특정 객체에 특정 메서드를 추가흔 것이 가능하다.\n객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법은 상속이다. 하지만 상속은 코드 재사용을 위한 우아한 해결책은 아니다. 상속은 부모 클래스의 세부적인 구현에 자식 클래스를 강하게 결합시키기 때문에 코드의 진화를 방해한다.\n합성이 상속과 같은 문제점을 초래하지 않는 이유는 클래스의 구체적인 구현이 아니라 객체의 추상적인 인터페이스에 의존하기 대문이다.\n합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.\n10. 다형성 상속의 목적은 코드 재사용이 아니다. 상속은 타입 계층을 구조화 하기 위해 사용해야 한다.\n다형성은 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법\n데이터 관점의 상속이 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 개념이라면 행동 관점의 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다.\n부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것을 업캐스팅이라고 부른다. 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다.\n이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다. 이를 동적 바인딩이라고 부른다.\n11. 서브클래싱과 서브타이핑 상속의 첫번째 용도는 타입 계층을 구현하는 것\n상속의 두번재 용도는 코드 재사용\n재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되어 변경하기 어려운 코드가 될 확률이 높다.\n상속관계가 IS-A 관계를 모델링하는가? 자식 클래스는 부모클래스다라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.\n클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방하고 둘의 차이점을 클라이언트 입장에서는 몰라야 한다. 이를 자식 클래스와 부모클래스 사이의 행동 호환성이라고 부른다.\n서브타입에 더 약한 사후조건을 정의할 수 없다.\n12. 디자인 패턴과 프레임워크 알고리즘을 캡슐화 하기 위해 합성 관계가 아닌 상속 관계를 사용하는 것을 TEMPLATE METHOD 패턴이라고 한다.\n알고리즘 교체와 같은 요구사항이 없다면 상대적으로 STRATEGY 패턴보다 TEMPALTE MEHTOD패턴이 복잡도를 낮출 수 있다는 점에서 장점이다.\nDECORATOR 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로서 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다. 이 패턴은 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화할 수 있다.\n디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다.\n디자인 패턴에서 중요한 것은 디자인 패턴의 구현 방법이나 구조가 아니다. 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는 것이 중요하다. 그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지를 이해하는 것이 더 중요하다.\nCOMPOSITE 패턴은 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화하는 것이 목적이다.\n패턴 입문자가 빠지기 쉬운 함정은 패턴을 적용하는 컨텍스트의 적절성은 무시한 채 패턴의 구조에만 초점을 맞추는 것이다.\n패턴을 가장 효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링을 하는 것이라고 이야기 한다. 그는 패턴이 적용된 최종결과를 이해하는 것보다는 패턴을 목표로 리팩토링 하는 이유를 이해하는 것이 훨씬 가치있고 훌륭한 설계 자체를 공부하는 것보다 훨씬 중요하다고 한다.\n13. 타입계층의 구현 클래스와 타입간의 차이를 이해하는 것은 중요한 일이다.\n객체의 클래스는 객체의 구현을 정의한다. 클래스는 객체의 내부상태와 오퍼레이션 구현 방법을 정의**하는 것이고, 객체의 타입은 인터페이스만을 정의하는 것으로 객체가 반응할 수 있는 **오퍼레이션의 집합**을 정의한다.\n하나의 객체가 여러 타입을 가질 수 있고 서로다른 클래스의 객체들이 동일한 타입을 가질 수 있다. 즉, 객체의 구현은 다를지라도 인터페이스는 같을 수 있다는 의미이다. 클래스와 타입간에는 밀접한 관련이 있다. 클래스도 객체가 만족 할 수 있는 오퍼레이션을 정의하고 있으므로 타입을 정의하는 것이기도 하다. 그래서 객체가 클래스의 인터페이스라고 말할 때 객체는 클래스가 정의하고 있는 인터페이스를 지원한 다는 뜻을 내포한다.\n14. 도메인 모델 도메인이란 사용자가 프로그램을 사용하는 대상 영역을 가리킨다. 모델이란 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다. 자가 프로그램을 사용하는 대상 영역에 대한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다. 어떤 인스턴스가 다른 인스턴스의 타입을 표현하는 방법을 TYPE OBJECT 패턴이라고 부른다. "},{"section":"Blog","slug":"/blog/spring/architecture/","title":"Spring 요청처리 내부구조","description":"Spring에 요청이 들어왔을때 내부적인 처리 과정 정리","date":"2021년 11월 11일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/spring/preview_hu740a35c095c653155a0595aa38be9f22_18108_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"200\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/spring\\/preview_hu740a35c095c653155a0595aa38be9f22_18108_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/spring/preview_hu740a35c095c653155a0595aa38be9f22_18108_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/spring\\/preview_hu740a35c095c653155a0595aa38be9f22_18108_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Spring","tags":"Spring, Architecture","content":"내가 이해하고 나중에 보기 위해서 정리하는 스프링 요청 처리 구조\n내부 구조 요약\r1. Tomcat (Servlet Container) 톰캣은 WAS로써 미들웨어역할을 하지만 아파치의 일부분 기능을 서비스(httpd(웹서비스 데몬) native 모듈 포함)하고있어 Web Server역할도 수행할 수 있다.\n톰캣의 메인 기능으로 서블릿 컨테이너역할인데 이는 서블릿의 라이플 사이클을 관리하며 DispatcherServlet도 해당 컨테이너에서 수행된다.\n또한, 응답을 위한 소켓을 만드는 역할과 요청마다 쓰레드를 생성해 요청을 처리하기 위한 스레드풀을 관리한다.\n해당 Tomcat도 결국 자바프로그램이기 때문에 별도의 JVM이 동작한다.\n2. Servlet 요청에 대한 웹페이지나 결과값을 동적으로 생성 해주기 위한 역할을 수행하는 자바 프로그램\n생명주기? init-\u0026gt;service-\u0026gt;destroy\nSpringMVC에서는 DispatcherServlet이라는 FrontController 역할을 수행하는 Servlet이 존재하여 요청을 다른 컨트롤러에게 위임하는 방식으로 처리\nservice()를 실행하고 해당 메서드에서 dispatch.doService() -\u0026gt; doDispatch()를 실행한다. (doDispatch는 HandlerMapping에서 핸들러를 가져오는 역할)\n1) DispatcherServlet 클래스 내부에 핸들러, 어댑터, 리졸버 등을 가지고 있어 요청에대한 응답이 가능하다. 이들을 인터페이스로 가지고 있으며 생성되는 시점에 ApplicationContext에서 빈들을 주입받아 생성된다. Spring이 생성하는 Servlet이다.\nHandlerMapping : 요청을 분석하여 맵핑된 Controller확인 HandlerAdapter : Controller 에게 요청을 보내는 역할 ViewResolver : Controller 에서 view를 return시 해당 view를 찾아 리턴해주는 역할 3. Spring Container DispatcherServlet 는 Servlet WebApplicationContext와 Root WebApplicationContext가 존재한다.\nRoot WebApplicationContext는 Service, datasource,repositories 들을 포함하고 있는 Context이고 Servlet WebApplicationContext는 RootWebApplicationContext를 상속받아 구현된 Context로 주로 Controller, Intercepter, ViewResolver, HandlerMapping 등 과 같은 빈들이 존재한다.\nServlet을 구현할때 위처럼 상속관계로 나누어 Servlet WebApplicationContext를 구현한 이유는 서블릿 컨테이너 내부에 여러개의 서블릿이 올 수도 있는데 Service, datasource들은 공통적으로 사용될 수 있기 때문이다. Container가 Bean 생성 시, Service-Locator 패턴으로 의존성을 주입하며 생성한다.\n서블릿의 생명주기를 관리한게 서블릿 컨테이너였다면 스프링 컨테이너는 빈의 라이플 사이클을 관리하며 IOC/DI를 제공해주는 역할을 수행한다.\n1) Application Context BeanFactory를 상속받고 있는 Context로 서로 다른 Servlet 끼리 공유해서 사용할 수 있는 Bean을 정의하고 해당 빈에서는 Servlet Context를 사용할 수가 없다.\n2) Servlet Context Servlet WebApplicationContext로 서블릿 단위로 생성되는 컨텍스트이다.\nApplication Context와 해당 컨텍스트와 같은 id로 빈이 등록되는 경우 Servlet Context에 선언된 빈을 사용하며, 빈을 찾을 때에는 Servlet Context-\u0026gt; Application Context 순서로 찾기 때문에 해당 컨텍스트에 정의된 빈에서는 Application Context의 빈을 사용할 수 있다.\n4. 서버 시작과 요청까지의 단계 Web server init Root WebApplicationContext 로딩 Web server start Client가 Web server로 Request Web Server가 Servlet Container로 전달 Servlet 스레드 생성 서블릿이 생성안되어있다면 DispatcherServlet init 생성된 스레드에서 DisapatcherServlet의 service() 메서드 호출 HandlerMapping을 통해 컨트롤러 조회 HandlerAdapter를 통해 컨트롤러에게 전달 Contrller -\u0026gt; Service-\u0026gt; 동작 후 응답 5. Spring과 Spring boot의 차이점 기존 Spring은 Apache Tomcat(Servlet Container)에의해 ContextLoaderListener로 ApplicationContext를 생성하고 요청이 들어온다면 이 정보를 가지고 DispatcherServlet을 만드는 것.\nSpring boot는 Application이 먼저 띄워져 TomcatStarter의 onStartup()메서드로 톰캣이 실행되고 다음 DispatcherServlet 순으로 생성이된다. 한마디로 Tomcat보다 Application이 먼저 실행된다.\n6. Controller 1개가 어떻게 많은 요청을 처리하는가 Tomcat 내부적으로 스레드풀을 만들어 하나의 요청에 하나의 스레드를 할당하여 응답을 처리한다. 이때 Controller는 스프링 빈이고 빈은 싱글톤패턴으로 1개만 생성이되는데 어떻게 여러 스레드에서 객체를 공유하여 사용이 가능할까?\nController 객체 하나를 생성하면 객체 자체는 Heap에 생성되지만 Class 정보는 Method Area에 저장되고 Controller는 내부적으로 상태가 존재하지 않고 메서드에 대한 정보만 공유해서 사용하면 되기 때문에 동기화에 대한 걱정이 없다. 한마디로 처리로직만 공유되어 사용하는 것이기 때문에 몇개의 요청이 들어오든 상관이 없다.\n7. 커넥션당 쓰레드를 만드는 것보다 요청당 쓰레드를 만드는것을 사용하는 이유 결론부터 말하면 확장성에 유리하다. 자바 쓰레드의 비용은 비싼데 요청이 오지 않는 connection을 계속 유지하여 스레드를 낭비하고 새로운 스레드를 생성하는 것보다 요청마다 스레드를 할당하고 반환하는 것이 더 비용이 저렴하다. 물론, keep-alive를 통해 connection 별로 스레드를 유지할 수 도 있다.\n8. JVM이 Servlet을 실행하는 것과, 일반 자바 클래스를 실행하는 것의 차이 호출 방식은 같으나 서블릿은 main()함수로 호출되지 않고 Container에 의해 실행되는 것.\nReference https://medium.com/@jypthemiracle/servletcontainer%EC%99%80-springcontainer%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80-626d27a80fe5 "},{"section":"Blog","slug":"/blog/golang/slice/","title":"Slice","description":"go lang의 slice에 대해 정리한 글","date":"2021년 7월 5일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"컴파일타임에 데이터 크기가 고정되어 런타임에 변경이 되지 않는 일반 배열과 달리 변경이 가능한 동적 배열 타입을 slice라고 한다. 정확하게 얘기하면 go에서 제공하는 배열을 가리키는 포인터 타입이다.\n1. 선언 방법 var a []int //길이가 0인 slice fmt.Println(len(a)) //0 b := []int{1,2,3} //길이가 3인 slice fmt.Println(len(b)) //3 var c = []int{1, 5:2, 9:3} //길이가 10인 slice fmt.Println(c) //[1 0 0 0 0 2 0 0 0 3] 배열선언방식과 비슷하지만 [] 안에 배열크기를 지정하지 않으면 slice로 선언이 된다.\n1) make()이용한 초기화 var a = make([]int,3) //길이가 3인 slice a[1] = 1 fmt.Println(a) //[0 3 0] 2. 순회 slice := []int{1,2,3} for i :=0; i \u0026lt; len(slice); i++ { fmt.Print(slice[i],\u0026#34; \u0026#34;) //1 2 3 } fmt.Println() for _,v := range slice{ fmt.Print(v,\u0026#34; \u0026#34;) //1 2 3 } 3. 슬라이스 요소 추가 배열과 달리 동적배열인 slice는 append()함수를 이용하여 배열에 값을 추가해줄 수 있다.\nslice := int[]{1,2,3} slice2 := append(slice,4) fmt.Println(slice) //[1 2 3] fmt.Println(slice2) //[1 2 3 4] //기존의 변수에 값을 추가해주고 싶다면 아래와 같이 이용 slice = append(slice,4) fmt.Println(slice) //[1 2 3 4] append() 함수는 기존의 slice에 값을 추가해주는 것이 아니라 값을 추가한 slice를 반환해주는 함수라는 점을 명심해야한다.\nappend()는 빈공간이 충분하다면 빈공간에 요소가 추가되고 충분하지 않다면, 새로운 배열을 생성해서 반환하게 되고 이때 빈공간은 cap-len이다.\n4. 동작원리 실제 값을 가르키는 pointer와 len으로 구성되어있다고 앞서 설명한 string처럼 slice도 실제 배열을 가르키는 포인터와 len으로 구성되어 있으며 cap이라고 capacity의 약자이며 최대 배열의 크기를 가르키는 변수가 한개가 더 존재하는 구조체로 구성되어 있다.\ntype SliceHeader struct{ Data uintptr Len int Cap int } 위 구조체가 slice의 구조로 실제 data는 배열포인터로 표현하는 것을 볼 수 있다. 그래서 *[10]int 와는 엄연히 다른 데이터형태이다.\nvar slice = make([]int,3) // len | cap이 3인 slice var slice2 = make([]int,3,5) //len이 3, cap이 5인 slice make를 이용해 slice를 초기화하면 위와 같이 len과 cap을 별도로 정의해줄 수 있다.\nfunc changeArray(array [5]int){ array[2] = 200 } func changeSlice(slice []int){ slice[2] = 200 } func main(){ arr := [5]int{1,2,3,4,5} slice := []int{1,2,3,4,5} changeArray(arr) changeSlice(slice) fmt.Println(arr) //[1 2 3 4 5] fmt.Println(slice) //[1 2 200 4 5] } 기본적으로 array타입을 함수의 매개변수로 주어지면 배열그대로를 복사해서 이용하는 call by value형태라서 값이 변하지 않지만, slice는 내부 구조를 이해하면 값이 변하는 이유를 이해할 수 있다.\nslice는 내부에 배열을 직접 가지고 있는 것이 아니라 포인터형태로 값을 가르키고 있기 때문에 slice내부의 값이 변경되는 것이다. 따라서 실제 배열의 크기가 1024byte이더라고 slice변수의 데이터 크기는 24byte로 1024보다 현저히 적은 데이터 크기를 갖는다.\n5. 슬라이싱 슬라이싱은 배열의 일부를 가리키는 기능으로 슬라이싱의 결과는 슬라이스이다. [:] 으로 표현할 수 있으며, :앞에는 시작 index가 오고 :이후에는 끝나는 index를 주는데 끝index는 포함하지 않는다.\narray := [5]int{1,2,3,4,5} slice := array[1:2] fmt.Println(array) //[1 2 3 4 5] fmt.Println(slice, len(slice), cap(slice)) //[2] 1 4 slice[0] = 0 slice = array[1:2] fmt.Println(array) //[1 0 3 4 5] fmt.Println(slice, len(slice), cap(slice)) //[0] 1 4 슬라이스는 특정 구간을 잘라낸 슬라이스를 반환하는 것이 아니기 때문에 slice의 값을 바꾸면 array의 값도 바뀌는 것을 볼 수 있다.\nslice하게 되면 len은 요소 개수로 바뀌고 cap은 원본 배열의 len에서 시작 인덱스만큼 뺀 값으로 바뀌게 된다.\n슬라이스도 배열과 마찬가지로 슬라이스를 수행할 수 있다.\n1) 특정위치부터 끝까지 슬라이스 array := [5]int{1,2,3,4,5} slice1 := array[1:len(array)] slice2 := array[1:] 끝까지 슬라이스 하고 싶을때는 배열길이를 주면 되지만 이는 위 예시처럼 생략이 가능하다.\n2) 전체 슬라이싱 array := [5]int{1,2,3,4,5} slice := array[:] 배열을 슬라이스로 바꾸고 싶을때 사용할 수 있다.\n3) 캡사이즈 조절 슬라이싱 slice[시작인덱스:끝 인덱스: 최대 인덱스]\n위처럼 세번째 인자로 최대 인덱스를 입력하면 cap사이즈가 최대인덱스-시작인덱스로 조절이 된다.\n6. 슬라이스 깊은 복사 1) for slice1 := []int{1,2,3,4,5} slice2 := make([]int{}, len(slice1)) for i,v := range slice1{ slice2[i] = v } 2) append() slice1 := []int{1,2,3,4,5} slice2 := append([]int{}, slice1...) append가 슬라이스를 반환하는 점을 이용해서 빈 슬라이스에 기존의 slice를 append하면 깊은 복사를 수행할 수 있다.\n3) copy() slice1 := []int{1,2,3,4,5} slice2 := make([]int, len(slice1)) copy(slice2,slice1) go 내장 함수중에 copy()메서드를 이용하는 방법도 있다. 이때 copy() 리턴값은 복사한 개수이다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\n"},{"section":"Blog","slug":"/blog/golang/module-package/","title":"모듈과 패키지","description":"go lang의 모듈과 패키지에 대해 정리한 글","date":"2021년 6월 9일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"1. 모듈의 변천과정 Go 1.11 이전 : 모듈 존재 X Go 1.11 : 모듈이 소개되었지만 미완성 Go 1.13 : 모듈 완성 Go 1.16 : 모듈이 이제 기본이 되었다. 1) 모듈 모듈은 패키지의 모음\n2) 패키지 패키지는 코드를 묶는 단위로 모든 코드는 반드시 패키지로 묶여야 한다.\n우리가 흔히 부르는 프로그램은 다양한 관점에서 의미를 해석할수 있을 텐데 실핼파일 관점에서보면 실행시작 지점을 포함한 패키지. 즉, main함수를 포함한 main패키지이다.\n그외의 패키지들은 실행시점을 포함하지 않은 패키지로 프로그램의 보조패키지로 동작한다.\n2. 패키지 import //case 1 import \u0026#34;fmt\u0026#34; //case2 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) fmt.Println(rand.Int()) //case3 import ( \u0026#34;text/template\u0026#34; htemplate \u0026#34;html/template\u0026#34; ) ◾ 사용하지 않는 package import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; _ \u0026#34;strings\u0026#34; ) 별칭으로 _를 주면 import하되 사용하지 않아도 import가 가능\n패키지 초기화에 따른 부가효과를 위해서 import해야만 하는 경우가 존재한다.\n3. 패키지 외부 공개 함수나 구조체, 구조체 필드들은 대문자로 시작해야 외부에서 접근이 가능하다. 소문자로 시작한다면 같은 패키지내부에서만 접근이 가능하다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\n"},{"section":"Blog","slug":"/blog/golang/string/","title":"문자열","description":"Go Lang의 문자열(String)에 대해 정리한 글","date":"2021년 6월 7일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"문자의 집합(배열)이라는 의미이다.\n기존의 문자는 ASCII코드로 1byte를 갖기 때문에 0~255로 총 255개의 문자를 표현할 수 있었는데 이 수로는 현재 존재하는 언어(문자)들을 모두 표시할 수 없기 때문에 더 큰 byte의 문자가 필요해졌다. 대표적으로 UTF-8이 있는데 이는 한 문자당 1~4byte를 갖고 UTF-16은 2byte를 갖는다.\n1. UTF-8과 UTF-16 UTF-16이 공간을 더 적게 차지하기 때문에 UTF-16이 더 좋아보일 수 있다. 하지만, UTF-8은 파레토의 법칙으로 데이터를 잘 봐보니 영어/숫자의 데이터가 대부분(80%)를 차지하더라 라는 개념으로 필요한 데이터크기에 맞게 크기를 할당하는 개념으로 크기가 동적으로 변한다.\nUTF-16은 2byte로 고정길이기 때문에 UTF-8이 더 효율적일 수도 있고 ASCII로 표현되는 데이터들을 2byte로 표현을 하다보니까 ASCII와 상호간에 호환이 잘 안되는 문제점이 있다.\n2. 문자열 리터럴 표현 방식 1) Double Quote (\u0026quot;\u0026quot;) str := \u0026#34;\\\u0026#34;\u0026#34; fmt.Println(str) //\u0026#34; str1 := \u0026#34;Hello\\nWorld\u0026#34; fmt.Println(str1) //Hello //World str2 := \u0026#34;Hello World\u0026#34; //error \u0026quot;\u0026quot; 은 한 줄로 표현할 때 사용하며 개행을 하기 위해선 개행문자 \\n 을 이용해서 해야하고 예제처럼 한줄 띄어서 작성할 수 없다.\nGo에서 쌍따옴표로 열리고 닫힌 string을 Interprected string이라고 한다. 이 문자열은 escape 문자()를 이용해서 특수기호를 표시할 수 있다.\n2) Back Tick (``) str := `\u0026#34;` fmt.Println(str) //\u0026#34; str1 := `Hello\\nWorld` fmt.Println(str1) //Hello\\nWorld str2 := `Hello World` fmt.Println(str2) //Hello //World 여러줄로 표현 가능하고 이를 이용한 string을 Raw string이라고 하고 이는 내부 특수기호를 그대로 표현해준다.\n3. 문자열 순회 str := \u0026#34;Hello 월드\u0026#34; ftm.Println(len(str)) //case 1 for i:=0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026#34;타입: %T, 값: %d, 문자값: %c\\n\u0026#34;,str[i],str[i],str[i]) } fmt.Printf(\u0026#34;%c\u0026#34;,str[8]) // 위에서 case1의 출력결과는 무엇일까?\n우리 예상은 8일 것 같지만 len()은 문자열의 바이트 길이를 반환하기 때문에 한글은 3byte씩 해서 총 12가 출력된다. 그렇기 때문에 위의 for문을 실행해보면 한글이 나오는 부분부터 깨지는 것을 볼 수 있다.\n[]를 이용해 문자열을 접근하는 것은 len과 같이 메모리의 index에 접근하는 것이기 때문에 3byte로 저장된 한글 한문자중에서 1byte만 접근해 쓰레기값이 나오는 것이다.\n1) []rune str := \u0026#34;Hello 월드\u0026#34; arr := []rune(str) for i:=0; i \u0026lt; len(arr); i++ { fmt.Printf(\u0026#34;타입: %T, 값: %d, 문자값: %c\\n\u0026#34;,arr[i],arr[i],arr[i]) } ftm.Println(len(arr)) //8 rune은 int32의 별칭타입이기 때문에 4byte를 갖는다. 이를 이용해서 문자열을 rune타입 슬라이스로 만들어서 배열을 순회하면 우리가 원하는데로 동작한다.\n2) range str := \u0026#34;Hello 월드\u0026#34; for _,v := range str { fmt.Printf(\u0026#34;타입: %T, 값: %d, 문자값: %c\\n\u0026#34;,v,v,v) } 정확한 길이가 필요한 것이 아니라 단순히 순회가 목적이라면 range를 이용하면 편하게 순회 할 수 있다.\n4. 문자열 합산 str1 := \u0026#34;Hello\u0026#34; str2 := \u0026#34;World\u0026#34; str3 := str1 + \u0026#34; \u0026#34; + str2 fmt.Println(str3) str3 += \u0026#34;Hi \u0026#34; fmt.Println(str3) go는 +를 통해 문자열 합을 지원하고 ptyhon같이 그 외의 연산(*\u0026hellip;)을 지원하지 않는다.\n5. 문자열 비교 1) ==, != str1 := \u0026#34;Hello 월드\u0026#34; str2 := \u0026#34;Hello 월드\u0026#34; fmt.Println(str1 == str2) //true str1 := \u0026#34;Hello 월드\\n\u0026#34; str2 := `Hello 월드 ` fmt.Println(str1 == str2) //true 문자열 두개가 서로 같은지 비교하는 연산을 지원한다.\n2) \u0026lt;, \u0026gt; , \u0026lt;= ,\u0026gt;= str1 := \u0026#34;apple\u0026#34; str2 := \u0026#34;Apple\u0026#34; fmt.Println(str1 \u0026gt; str2) //true go 는 대소 비교도 지원하는데 이때 사전식 비교로 대문자가 더 작다.\nAscii 코드 값 A-Z : 65 - 90\na-z : 97 - 122\n6. 문자열 구조 지금까지 Go를 착실히 공부했다면 여기서 한가지 의문점이 들 것이다.\n분명히 Go는 강타입 언어라서 연산,대입을 할때 데이터타입이 크기까지 똑같아야 했다. int8과 int32 두 타입의 연산을 시도하면 error가 발생한다. 그런데 string은 데이터크기가 다 제각각인데 어떻게 합이나 비교, 대입이 가능할까?\ntype StringHeader struct{ Data uintptr Len int } 문자열은 내부적으로 데이터(문자열 리터럴)의 주소값을 포인터변수로 가지고 있기 때문에 string의 길이가 서로 달라도 연산이 가능하고 대입연산도 가능하다.\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;unsafe\u0026#34; ) func main(){ str1 := \u0026#34;Hello 월드\u0026#34; str2 := str1 stringHeader1 := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str1)) stringHeader2 := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str2)) fmt.Println(stringHeader1) //\u0026amp;{49633883 12} fmt.Println(stringHeader2) //\u0026amp;{49633883 12} } 문자열을 poninter타입으로 변환후 reflect를 이용해 내부를 봐보면, 실제 문자열이 저장된 위치(49633883)와 길이(12)가 들어있는 것을 볼 수 있다.\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; \u0026#34;reflect\u0026#34; ) func main(){ str1 := \u0026#34;Hello\u0026#34; str2 := \u0026#34;Hello\u0026#34; stringHeader1 := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str1)) stringHeader2 := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str2)) fmt.Println(stringHeader1) //\u0026amp;{4989886 5} fmt.Println(stringHeader2) //\u0026amp;{4989886 5} } str2에 str1을 할당하는 것이 아니라 같은 문자 리터럴을 대입해도 같은 공간을 가리키는 것을 볼 수 있는데, 이는 메모리(스택이나 힙) 또는 코드공간에 해당 문자열이 있는지 확인하고 있다면 해당 공간의 주소를 대입시켜주기 때문이다.\n7. 문자열 불변 str1 := \u0026#34;Hello World\u0026#34; slice := []byte(str) str1[2] = \u0026#39;a\u0026#39; //error slice[2] = \u0026#39;a\u0026#39; fmt.Println(str1) //Hello World fmt.Printf(\u0026#34;%s\\n\u0026#34;,slice) //Healo Wolrd 문자열은 Immutable한 속성을 가지고 있어 문자리터럴값은 내부적으로 변경이 불가능하다. 그래서 문자열을 []로 접근해서 일부만 수정하려고 하면 error가 발생한다.\n또한, Slice로 문자열을 복사하게 되면 두개의 문자열은 서로 다른 메모리(공간)으로 복사를 하기 때문에 slice를 수정을 해도 기존의 문자열은 변경이 되지 않는다.\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; \u0026#34;reflect\u0026#34; ) func main(){ str1 := \u0026#34;Hello \u0026#34; str2 := str1 stringHeader1 := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str1)) stringHeader2 := (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str2)) fmt.Println(stringHeader1) //\u0026amp;{4990223 6} fmt.Println(stringHeader2) //\u0026amp;{4990223 6} str2 += \u0026#34;World\u0026#34; fmt.Println(stringHeader1) //\u0026amp;{4990223 6} fmt.Println(stringHeader2) //\u0026amp;{824634237040 11} } 두개의 문자열이 처음에는 같은 메모리를 가리키고 있다가 +연산을 수행하게 되면 기존의 문자열을 바꾸는 것이 아니라 새로운 공간에 합한 문자열을 할당하는 것을 볼 수 있다.\n8. String Builder import ( \u0026#34;strings\u0026#34; \u0026#34;fmt\u0026#34; ) func main(){ str := \u0026#34;hello world\u0026#34; builder := strings.Builder{} for _,c := range str { if c \u0026gt;= 97 \u0026amp;\u0026amp; c \u0026lt;= 122{ builder.WriteRune(\u0026#39;A\u0026#39; + (c - \u0026#39;a\u0026#39;)) }else { builder.WriteRune(c) } } fmt.Println(builder.String()) //HELLO WORLD fmt.Println(strings.ToUpper(str)) //HELLO WORLD } Java의 StringBuilder와 동일한 역할의 string builder이다.\n위에서 본 것처럼 문자열 합산연산시 +은 계속 새로운 공간을 할당해서 연산이 수행되는데 많은 문자열을 처리하는데 있어 이는 매우 비효율적이다. 계속 공간을 할당하고 GC가 지우고를 반복하기 때문이다.\n그런데 strings.Builder를 이용하면 공간할당을 새로하지 않으면서 붙일 수 있다. Builder 구조체 내부에 byte슬라이스([]byte)를 이용해서 문자열을 관리하기 때문에 +연산시 새로 공간이 할당되는 문제를 해결할 수 있다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\nTucker의 Go 강좌 "},{"section":"Blog","slug":"/blog/algorithms/longest-increasing-subsequence/","title":"최장 증가 수열","description":"최장 증가 수열 (Longes Increasing Subsequence)에 대해 정리한 글","date":"2021년 6월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"최장 증가 수열","content":"주어진 수열에서 오름차순으로 정렬된 가장 긴 부분 수열이다.\n예를 들어, 341256784134라는 수열에서 LIS는 345678 or 125678 이 된다.\n1. 찾는 방법 LIS의 크기 구하는 방법은 dp와 이분탐색에 따라 방법이 나뉘며 경로 추적(trace) 방법은 두 방법 모두 인덱스를 가리키는 배열을 하나 추가하여, 탐색하면서 해당 값의 앞의 수열 인덱스를 저장하는 방법으로 구현한다.\n이 배열을 가지고 가장 큰 부분순열을 갖는 값부터 역 추적하며 순열을 구한다.\n2. O(n^2) dp를 이용해 찾는 방법이다.\n현재 위치의 수를 끝으로 하는 최장 증가 수열의 값을 dp에 저장하는 방법으로 수열의 첫번째부터 끝까지 반복하며, 현재 위치보다 앞의 수들을 모두 비교하기 때문에 O(n^2) 만큼 걸린다.\n1) lis 크기 구하기 void lis_dp(string str) { vector\u0026lt;int\u0026gt; dp(str.length(), 0); //해당 index의 값을 끝으로 하는 가장 긴 수열의 값 저장 for (int i = 0; i \u0026lt;= str.length(); i++) { dp[i] = 1; //처음값은 1로 시작 for (int j = 0; j \u0026lt; i; j++) { if (str[i] \u0026gt; str[j] \u0026amp;\u0026amp; dp[j] + 1 \u0026gt; dp[i]) { //현재 위치의 앞의값중 가장 긴 수열의 길이 find dp[i] = dp[j] + 1; } } } cout \u0026lt;\u0026lt; \u0026#34;\\nmax length : \u0026#34; \u0026lt;\u0026lt; max \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Subsequence : \u0026#34;; } 2) lis 원소 구하기 (trace) void lis_dp(string str) { vector\u0026lt;int\u0026gt; dp(str.length(), 0); //해당 index의 값을 끝으로 하는 가장 긴 수열의 값 저장 vector\u0026lt;int\u0026gt; backtrace_idx(str.length(), -1); //수열의 이전 값의 index값, -1이 처음 값 vector\u0026lt;char\u0026gt; lis; //최장 증가 수열 값 trace int max = 0, idx; for (int i = 0; i \u0026lt;= str.length(); i++) { dp[i] = 1; //처음값은 1로 시작 for (int j = 0; j \u0026lt; i; j++) { if (str[i] \u0026gt; str[j] \u0026amp;\u0026amp; dp[j] + 1 \u0026gt; dp[i]) { //현재 위치의 앞의값중 가장 긴 수열의 길이 find dp[i] = dp[j] + 1; backtrace_idx[i] = j; // trace 추적 위해 } } // trace 추적위해 if (dp[i] \u0026gt; max) { max = dp[i]; idx = i; } } cout \u0026lt;\u0026lt; \u0026#34;\\nmax length : \u0026#34; \u0026lt;\u0026lt; max \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Subsequence : \u0026#34;; /*최장 증가 수열 처음 부분까지 역 추적하며 vector에 추가*/ for (int i = idx; i \u0026gt;= 0; i = backtrace_idx[i]) { lis.push_back(str[i]); } reverse(lis.begin(), lis.end()); //큰 값부터 추가했으므로 reverse for_each(lis.begin(), lis.end(), [](char c) { cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); // print } 3. O(nlgn) 이분탐색을 이용하는 방법으로 추가배열에 최장 증가 수열의 값을 저장하는 방법이다.\n배열의 인덱스가 수열의 길이를 나타내고, 인덱스의 값은 인덱스만큼의 길이의 수열을 갖는 값을 나타낸다.\n추가배열에 마지막값보다 탐색한 현재 값이 더 크다면 배열 마지막에 값을 추가해준다. (부분수열의 크기를 1증가 시켜주는 것)\n탐색한 현재 값이 마지막 값보다 작다면, 추가배열에서 현재값보다 작은값들 중 가장 큰 값을 현재값으로 갱신해준다. (이때 나오는 현재값보다 작은값들 중 가장 큰 값을 lower bound라고 한다)\n추가 배열은 항상 오름차순으로 정렬되어있으므로, 이분 탐색으로 탐색이 가능하기 때문에 O(nlgn)이 된다.\n1) lis 크기 구하기 void lis_bs(string str) { /*부분 수열 자리수에 해당하는 value값 담기 위한 배열*/ vector\u0026lt;pair\u0026lt;char, int\u0026gt;\u0026gt; arr; // first = value, for (int i = 0; i \u0026lt; str.length(); i++) { //첫번째 값이거나 현재 값이 arr의 마지막 값보다 크다면 새로 추가 ==\u0026gt; 최장 증가 수열의 크기 1증가 if (arr.empty() || arr.back().first \u0026lt; str[i]) arr.push_back({str[i], i}); //현재 값이 arr 마지막 값보다 작다면, lis의 크기 증가는 안된다. lower bound의 값 갱신 else { auto it = lower_bound(arr.begin(), arr.end(), make_pair(str[i], i), cmp); *it = {str[i], i}; } } cout \u0026lt;\u0026lt; \u0026#34;\\nmax length : \u0026#34; \u0026lt;\u0026lt; arr.size() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Subsequence : \u0026#34;; } 2) lis 원소 구하기 (trace) void lis_bs(string str) { /*부분 수열 자리수에 해당하는 value값 담기 위한 배열*/ vector\u0026lt;pair\u0026lt;char, int\u0026gt;\u0026gt; arr; // first = value, second = idx ==\u0026gt; 배열의 길이가 lis 크기다. vector\u0026lt;int\u0026gt; backtrace_idx(str.length(), -1); //수열의 이전 값의 index값, -1이 처음 값 vector\u0026lt;char\u0026gt; lis; //최장 증가 수열 값 trace for (int i = 0; i \u0026lt; str.length(); i++) { //첫번째 값이거나 현재 값이 arr의 마지막 값보다 크다면 새로 추가 ==\u0026gt; 최장 증가 수열의 크기 1증가 if (arr.empty() || arr.back().first \u0026lt; str[i]) { if (!arr.empty()) backtrace_idx[i] = arr.back().second; //최장 증가 수열값 trace arr.push_back({str[i], i}); } //현재 값이 arr 마지막 값보다 작다면, lis의 크기 증가는 안된다. lower bound의 값 갱신 else { auto it = lower_bound(arr.begin(), arr.end(), make_pair(str[i], i), cmp); if (it != arr.begin()) backtrace_idx[i] = (it - 1)-\u0026gt;second; // lis 값 trace ==\u0026gt; lower bound 위치가 맨 앞이라면 수행 x *it = {str[i], i}; } } cout \u0026lt;\u0026lt; \u0026#34;\\nmax length : \u0026#34; \u0026lt;\u0026lt; arr.size() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Subsequence : \u0026#34;; //*최장 증가 수열 처음 부분까지 역 추적하며 vector에 추가*/ for (int i = arr.back().second; i \u0026gt;= 0; i = backtrace_idx[i]) { lis.push_back(str[i]); } reverse(lis.begin(), lis.end()); //큰 값부터 추가했으므로 reverse for_each(lis.begin(), lis.end(), [](char c) { cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); // print } "},{"section":"Blog","slug":"/blog/datastructure/stack-queue/","title":"Stack Queue","description":"스택과 큐의 개념과 종류들을 c를 이용한 예제 코드와 함께 정리합니다.","date":"2021년 6월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"Stack, Queue","content":"1. 스택 Last In First Out으로 최근에 추가한 항목이 가장 먼저 제거되는 데이터 방식\n1) 함수 pop() : 스택에서 가장 위에 있는 항목을 제거 push() : item하나를 스택의 가장 윗 부분에 추가 peek() : 스택의 가장 위에있는 항목을 제거없이 값만 반환 isEmpty() : 스택이 비었는지 검사 2) 사용 예 재귀 알고리즘 웹 방문기록 실행 취소 연결 list를 이용한 코드 예(C 언어) 2. 큐 First In First Out으로 가장 먼저 추가한 데이터가 먼저 제거되는 데이터 방식\n1) 함수 add(inQueue)() : 큐의 끝 부분에 데이터 추가 remove(deQueue)() :큐의 첫번째 항목을 제거 peek() : 큐의 가장 위에있는 항목을 제거없이 값만 반환 isEmpty() : 큐가 비었는지 검사 2) 사용 예 프로세스 관리 너비 우선 탐색(BFS) 캐시 구현 우선순위 큐 덱 연결 list를 이용한 코드 예(C 언어) 3. 우선순위 큐 ( Priority Queue ) 우선순위의 개념을 큐에 도입한 자료 구조.\n일반적인 큐는 FIFO의 규칙으로 먼저 들어온것이 나가게 되나 우선순위 큐는 우선순위가 높은 순서대로 나가게 된다.\n1) 구현 방법 배열 리스트 힙(Heap) 표현 방법 삽 입 삭 제 순서 없는 배열 / 리스트 O(1) O(n) 정렬된 배열 / 리스트 O(n) O(1) 힙 O(logn) O(logn) 4. 덱 ( Deque ) Double-ended queue의 약자로 양 끝에서만 자료를 넣고 뺄 수 있는 자료구조이다.\n일반 큐와의 차이점은 push,pop 할 수 있는 방향이 양방향이라는 것이 차이점이다.\n"},{"section":"Blog","slug":"/blog/datastructure/heap/","title":"Heap","description":"자료구조 중 힙에 대해 정리한 글","date":"2021년 6월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"Heap","content":"Tree중 하나로 최대,최솟값을 찾아내는 연산을 빠르게 하기 위한 완전 이진 트리이다. (Complete Binary Tree )\n우선 순위를 무엇에 두냐에 따라 순서가 달라지기 때문에 자료가 들어온 시간을 우선순위로 놓는다고 하면 일반적인 큐도 우선순위 큐가 될 수 있다.\n1. 최대 힙(Max Heap) 부모 노드의 key값이 자식 노드의 key값보다 크거나 같은 완전 이진 트리\nc++을 이용한 코드 예 2. 최소 힙(Min Heap) 부모 노드의 key값이 자식 노드의 key값보다 작거나 같은 완전 이진 트리\nc++을 이용한 코드 예 3. 구현 1) 루트 인덱스가 0일 경우 왼쪽 자식의 인덱스 = 부모 인덱스 * 2 + 1 오른쪽 자식의 인덱스 = 부모 인덱스 * 2 + 2 부모 인덱스 = (자식의 인덱스 - 1) / 2 2) 루트 인덱스가 1일 경우 왼쪽 자식의 인덱스 = 부모 인덱스 * 2 오른쪽 자식의 인덱스 = 부모 인덱스 * 2 + 1 부모 인덱스 = 자식의 인덱스 / 2 루트 인덱스를 0 | 1 중에 무엇으로 두냐에 따라 위와같이 구현방법이 조금 달라질 수 있다.\n삽입 가장 끝에 삽입 후 부모 노드와 비교후 교체하면서 더이상 교체가 안될때까지 루트까지 올라가면 된다.\n삭제 첫 번째 노드 값을 꺼낸 후 마지막 노드의 값을 첫 번째로 이동을 한 후,마지막 노드 삭제한다.\n옮긴 첫번째 노드의 값을 아래로 내려가며(child와) 비교후 교체를 수행한다.\n4. 시간 복잡도 ( Big-O ) 자료구조 시간 복잡도 최댓값 찾기 (Find Max) 최댓값 추출 (Extract Max) 키 증가 (Increase Key) 삽입 (Insert) 삭제 (Delete) 합병 (Merge) 이진 힙 (Binary Heap) O(1) O(logn) O(logn) O(logn) O(logn) O(m+n) 페어링 힙 (Pairing Heap) O(1) O(logn) O(logn) O(1) O(logn) O(1) 이항 힙 (Binomial Heap) O(1) O(logn) O(logn) O(1) O(logn) O(logn) 피보나치 힙 (fibonacci Heap) O(1) O(logn) O(1) O(1) O(logn) O(1) 5. 사용 예 1) 허프만 코드 주어진 문자열을 이용하여 문자의 빈도수를 고려하여 2진수로 압축하는 알고리즘 중 하나로 최소 힙을 이용한다.\n2) 우선순위 큐 우선순위의 개념을 큐에 도입한 자료 구조로 일반적인 큐는 FIFO의 규칙으로 먼저 들어온것이 나가게 되나 우선순위 큐는 우선순위가 높은 순서대로 나가게 된다.\n"},{"section":"Blog","slug":"/blog/datastructure/array-list/","title":"Array와 List","description":"배열과 List의 개념과 종류들을 c를 이용한 예제 코드와 함께 정리합니다.","date":"2021년 6월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"Array, List","content":"1. 배열 가장 기본적인 자료구조로써, 논리적 저장 순서와 물리적 저장 순서가 일치하고 인덱스를 통하여 원소에 접근이 가능하다.\n대부분의 언어에서 [] 를 이용해서 배열을 제공한다.\n2. 리스트 배열과 달리 원소들 간의 논리적인 순서로 연결되어 구성있고, 삽입과 삭제를 수행하기 위해서는 첫 원소부터 모두 search해야한다.\n자료구조 Tree에 기본이 되는 자료구조이다.\n1) 단순 연결 리스트 방향이 한쪽으로만 구성된 리스트이다.\n구현 방법 한개의 노드에는 key값과 다음 노드의 주소를 가르킬 포인터 변수로 구성되어 새로 삽입할때 노드를 새로생성해서 리스트의 끝노드의 포인터로 새로운 노드를 가리키면 된다.\n시간 복잡도 노드의 개수가 n개일 경우 탐색/삽입/삭제 모두 O(n)만큼 걸린다.\nc언어를 이용한 코드 예 2) 이중 연결 리스트 리스트 방향이 양쪽으로 구성된 리스트이다.\n구현방법 한개의 노드에는 key값과 이전 노드와 다음 노드의 주소를 가르킬 포인터 변수 2개로 구성 첫 노드 생성시 left/right node pointer는 null로 초기화 노드 생성시 leftNode는 왼쪽 노드를 rightnode는 null로 생성후 원래 있던 끝 자락 노드의 right node*를 생성한 노드에 연결 c언어를 이용한 코드 예 "},{"section":"Blog","slug":"/blog/datastructure/graph/","title":"Graph","description":"그래프의 개념과 종류들을 cpp을 이용한 예제 코드와 함께 정리합니다.","date":"2021년 6월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"Graph","content":"연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조로 Tree도 그래프의 일종인데 그래프 중에서도 사이클이 허용되지 않는 그래프이다.\n1. 개념 정점(vertex) / 노드(node) : 위치 간선(edge) / 링크(link) : 위치간의 관계 인접 정점 : 간선에 의해 직접 연결된 노드 차수 : 하나의 노드에 인접한 노드의 수 경로 길이 : 경로를 구성하는 데 사용된 간선의 수 단순 경로 : 경로 중에서 반복되는 간선이 없을 경우 사이클 : 단순경로의 시작 정점과 종료 정점이 동일한 경로 오일러 경로 : 모든 간선을 한 번만 통과하면서 처음 정점으로 돌아오는 경로 오일러 정리 : 간선이 짝수일 때만 오일러 경로가 존재 부분 그래프 : 원래의 그래프의 일부 정점 및 간선으로 이루어진 그래프 2. 그래프 종류 영 그래프 (null graph) : 비어있는 그래프 완전 그래프 (complete graph) : 모든 노드가 서로 연결되어 있는 그래프 연결 그래프 (connected graph ) : 무방향 그래프에 있는 모든 노드쌍에 대해 항상 경로가 존재한 경우 정규 그래프 (regular graph) : 모든 정점이 동일한 개수의 정점을 갖는 것 ( 모든 정점의 차수가 같은 그래프) 이분 그래프 (bipartite graph) : 인접한 정점끼리 서로 다른 색으로 칠해서 모든 정점을 두 가지 색으로 칠할 수 있는 그래프 ( 모든 정점이 두 그룹으로 나눠지고 같은 그룹끼리는 인접하지 않은 그래프 ) 완전 이분 그래프 (complete bipartite graph) : 이분 그래프 중에서도 서로 다른 그룹이라면 서로 다른 그룹끼리 모두 연결되어 있는 그래프 가중치 그래프 : 간선에 가중치가 주어진 그래프 ( 가중치는 양,음 모두 가질 수 있다. ) 밀집 그래프 : 간선이 많이 존재하는 그래프 희소 그래프 : 간선이 적은 그래프 3. 표현 방법 1) 인접 행렬 (Adjacency Matrix) ( 2차원 배열 ) 정점 사이의 관계를 나타내는 행렬\n해당하는 위치의 값을 통해 vertex간의 연결 관계를 O(1)로 파악할 수 있어 두 정점의 인접 여부를 체크할 때 빠르다.\n배열은 노드를 n개를 갖는다고 한다면 n^2만큼 메모리가 필요하기에 희소 그래프는 메모리 낭비가 될 수 있고 정점 개수가 동적으로 변하는 경우에는 효과적이지 않다.\n간선의 개수가 많은 밀집 그래프 (Dense graph) 가 적합하다.\n2) 인접 리스트 (Adjacency List) ( 연결 리스트 ) 노드의 개수가 n개이고 노드의 개수가 e개인 무방향 그래프를 그리는데 있어 n개의 연결 리스트, n개의 헤드 포인터, 2e개의 노드가 필요하다.\n정점의 개수가 동적으로 변하는 경우 효과적이다.\n간선의 개수가 적은 희소 그래프 (Sparse graph) 가 적합하다.\n3) 근접 행렬 (= 발생 행렬,부속 행렬) (Incidence Matrix) (2차원 배열) 정점과 간선의 관계를 나타내는 행렬로 그래프의 정점을 행으로, 간선을 열로, 두 정점간 연결상태를 2차원 배열로 표시하는 것이다.\n정점보다 간선이 상대적으로 많은 그래프에서 저장공간과 메모리 절약을 위해 사용된다.\n4. 시간 복잡도 ( Big-O) 자료구조 시간 복잡도 저장 (storage) 간선 추가 (Add Vertex) 엣지 추가 (Add Edge) 간선 삭제 (Remove Vertex) 엣지 삭제 (Remove Edge) Query 인접 리스트 (Adjacency list) O(|V|+|E|) O(1) O(1) O(|V|+|E|) O(|E|) O(|V|) 인접 행렬 (Adjacency matrix) O(|V|^2) O(|V|^2) O(1) O(|V|^2) O(1) O(1) 근접 리스트 (Incidence list) O(|V|+|E|) O(1) O(1) O(|E|) O(|E|) O(|E|) 근접 행렬 (Incidence matrix)) O(|V|+|E|) O(|V|+|E|) O(|V|+|E|) O(|V|+|E|) O(|V|+|E|) O(|E|) 5. 탐색 1) 깊이 우선 탐색( DFS ) 시작 노드에서 출발하여 먼저 다음 노드로 향하면서 탐색한 곳은 표시를 해두고 더이상 갈 수 있는 노드가 없다면 이전 노드에서 다른 노드로 향하여 모든 노드를 탐색하는 방식. Stack 을 사용하여 구현.\nPsuedo Code 노드를 방문했다고 표시 해당 노드 출력 for 연결되어 있는 모든 노드 확인 if 방문 하지 않고 연결되어 있는 노드 재귀 함수 c++을 이용한 코드 예 2) 너비 우선 탐색( BFS ) 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법으로, 큐를 이용하여 노드를 삽입하고 방문한 노드는 큐에서 빼내는 방식으로 구현한다.\nPsuedo Code 노드를 방문했다고 표시 queue에 노드번호 삽입 while 큐가 비어있을때까지 queue pop pop값 출력 for 노드에 연결되어있는 모든 노드 탐색 if 방문하지 않은 노드라면 큐에 삽입 노드 방문표시 c++을 이용한 코드 예 6. 신장 트리 (Spanning Tree) 그래프 내의 모든 정점을 포함하는 트리 모든 정점들이 연결되어 있어야 하고 사이클은 포함되지 않는 형태 n개의 노드를 정확이 n-1개의 간선으로 연결된다. 하나의 그래프에는 많은 신장 트리 존재 가능 1) Psuedo Code 노드 방문 표시 for 인접한 노드 탐색 if 방문하지 않은 노드 간선 표시 재귀함수 7. 최소 비용 신장 트리 (MST) 신장 트리 중에서 사용된 간선들의 가중치 합이 최소인 신장 트리 모든 정점들이 연결되어 있어야 하고 사이클은 포함되지 않는 형태 n개의 노드를 정확이 n-1개의 간선으로 연결된다. 한마디로 무방향의 가중치가 있는 연결 그래프이다.\n1) 알고리즘 종류 Krustkal MST 탐욕적인 방법( Greedy Method )\n- 간선 선택 기반 알고리즘 - 희소그래프에 적합 ( V \u0026gt; E ) - 간선 선택 단계에서 사이클을 포함하지 않고 최소 비용 간선을 선택 - 트리집합을 병합하면서 하나의 트리로 확장 과정\n그래프의 가중치를 이용하여 오름차순 정렬 정렬된 리스트에서 사이클 포함하지 않은 간선 선택 선택한 간선을 MST 집합에 추가 edge 정렬이 속도를 결정짓기 때문에 egde 수가 적은 희소 그래프 유리하다.\nKruskal algorithm 설명 보기 Prim MST 탐욕적인 방법( Greedy Method )\n- 정점 선택 기반 - 밀집 그래프에 적합 ( V \u0026lt; E) - 시작 정점부터 출발하여 신장 트리 집합을 단계적으로 확장 과정\n시작 정점 MST에 추가 앞 단계의 MST에 인접한 정점들 중 최소 간선 정점 선택 MST가 n-1개 간선을 가질때 까지 반복 Prim algorithm 설명 보기 8. 그래프 알고리즘 복잡도 알고리즘 시간 복잡도 평균 (Average) 최악 (Worst) Kruskal 알고리즘 Θ( |E| log|E| ) O( |V|^2) 프림 알고리즘 (Prim\u0026rsquo;s algorithm)) Θ( |E| log|V| ) O( |V|^2 ) 다익스트라 알고리즘 (Dijkstra\u0026rsquo;s algorithm) Θ( |E| log|V| ) O( |V|^2 ) 벨먼-포드 알고리즘 (Bellman-Ford algorithm) Θ( |E| * |V| ) Θ( |V|^3 ) 플로이드-워셜 알고리즘 (Floyd-Warshall algorithm) Θ( |V|^3 ) O( |V|^3 ) A* 알고리즘 (A* search algorithm) Θ( |E| ) O( b^d ) 위상 정렬 (Topological sort) Θ( |V| + |E| ) O( |V| + |E| ) "},{"section":"Blog","slug":"/blog/datastructure/splay-tree/","title":"Splay Tree","description":"BBST중에 하나인 Splay Tree의 특징과 구현방법에 대해 정리하고 c++을 이용해 직접 구현해보는 글","date":"2021년 6월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"Tree, Splay Tree","content":"Splaying이라는 기법이 사용되며, 이는 특정 노드에 대해 접근을 하면, 이를 루트로 위치하도록 재배치 하는 기법의 트리\n1. 특징 구현이 단순 많이 접근한 노드에 대해서 빠른 접근이 가능하다 접근 빈도가 불균등하거나 비 랜덤 패턴의 경우 O(lgn)보다 더 유리하다. AVL-Tree와 RB-Tree와 달리 추가 데이터 저장 필요 없다. 최악의 경우 높이가 선형, 즉 O(n)이 나올 수 있다. 세그먼트 트리로 이용이 가능하다. k번째 원소 찾기, 구간 합, lazy Propagation, 구간 뒤집기 모두 쉽게 할 수 있다. x노드를 접근한다면, splay를 통해 root로 올라오면서 x보다 작은 노드들은 Left에, 큰 노드들은 Right에 모이는 특성을 이용 2. 사용 예 캐시, 가비지 컬렉터 알고리즘\n3. 사용 기법 1) Rotate 다른 balance binary search tree들과 같은 rotate 개념이다.\n2) Splay rotate를 기본으로, 탐색/삽입/삭제한 노드를 root에 위치할 때 까지 rotate시켜가는 기법\nZig : 기준 노드 x, z의 부모 노드 y가 root일 때 y를 기준으로 rotate 해주는것을 Zig라고 한다.\nZig-Zig : x의 할아버지 노드(z)에 대해 자식 y의 방향과 y에 대한 x의 방향이 같을 때 한마디로 z-\u0026gt;y 방향 == y-\u0026gt;x 방향\nrotate(y)후, rotate(x) 해주는 것을 Zig-Zig라고 한다.\nZig-Zag: x의 할아버지 노드(z)에 대해 자식 y의 방향과 y에 대한 자식 x의 방향이 다를 때 한마디로 z-\u0026gt;y 방향 != y-\u0026gt;x 방향\nrotate(x)후,rotate(x) 해주는 것을 Zig-Zig라고 한다.\n4. 구현 1) 삽입 일반 BST와 동일하게 삽입한 후, 삽입한 노드 x를 기준으로 splay를 수행해 주면 된다.\n2) 삭제 삭제도 삽입과 마찬가지로 일반 BST 삭제 연산과 방법은 동일하고 splay를 해주면되는데 삭제에는 추가로 여러 방법이 존재하는데, 삭제할 노드를 기준으로 splay를 수행 후, successor를 찾아 successor를 root로 만드는 방법과 삭제를 먼저 수행 후에 그 노드를 대신해서 오는 노드를 기준으로 splay를 수행하면 된다.\n3) 순회 과정 순회는 일반 BST와 동일하게 전위 / 중위 / 후위 순회로 순회가 가능하다.\n4) 탐색 과정 탐색 또한 일반 BST와 동일하게 찾으려는 key가 현재 노드보다 작다면 왼쪽으로, 크다면 오른쪽으로 탐색이 가능하지만, 많이 탐색한 key일수록 상단 부근에 위치하기 때문에 O(lgn)보다 유리하다.\n5. 시간 복잡도 삽입/탐색 시 가장 작은 숫자나 가장 큰 숫자를 접근한다면, 트리는 O(n)으로 선형적인 트리가 생성이 되지만, 무작위 splay를 통해 구조를 바꿔 줄 수도 있고, 자주 접근 하는 노드는 O(lgn)보다 빠르게 접근이 가능하기 때문에 상각 O(lgn)으로 볼 수 있다.\n6. 구현 코드 코드 보기 github에서 보기 /* * C++ 이용하여 Splay Tree 구현하기 * * 목적 : Splay Tree 공부 하기 위해 작성했으며, * C++ 이용하여 작성하시는 분들에게 도움이 되고자 했다. * * 설명 : key 값은 int만 가능 하며 중복 key는 허용 x * 단순 연결 리스트로 구현 * * class SplayTree * * 변수 : root =\u0026gt; root node * * 생성자 : SplayTree =\u0026gt; root 를 null로 초기화 * * 함수 : IsKey =\u0026gt; key값이 있는지 검사하는 함수 * * Insert =\u0026gt; 일반 BST의 삽입함수에 끝에 Splay 추가 (return void) * Delete =\u0026gt; Splay후 successor를 root로 만드는 함수 (return void) * Splay(x) =\u0026gt; x를 root로 재조정 함수 ( return void) * replace(x,y) =\u0026gt; 삭제할 x와 successor 위치를 바꿔주는 함수 (return void) * * RotateRight(x) =\u0026gt; x기준 오른쪽으로 회전 * RotateLeft(x) =\u0026gt; x기준 왼쪽으로 회전 * * Inorder,Preorder,Postorder =\u0026gt; 순회 함수 * tree_minimum(x), tree_maximum(x) =\u0026gt; 노드 x 기준으로 가장 왼쪽, 오른쪽 return 함수 * * DisplayMenu, SelectMenu =\u0026gt; 초기 Menu판 print 함수 * Insert_helper,Delete_helper,order_helper,print_helper =\u0026gt; 각각 이벤트 수행시 입력받고 조건 에러 처리 위한 함수 와 tree print * 해주는 함수 * * * 작성자 : gowoonsori * github : https://github.com/gowoonsori/my-tech/tree/master/dataStructure/Tree */ #include \u0026lt;algorithm\u0026gt; // max() 함수 이용 #include \u0026lt;iostream\u0026gt; struct node { int key; node *left = nullptr; node *right = nullptr; node *parent = nullptr; }; typedef node *NodePtr; class SplayTree { private: NodePtr root; //루트 노드 // key값이 있는지 없는지 검사 있으면 pointer 값, 없으면 nullptr NodePtr IsKey(int item) { NodePtr t = root; /*key값을 찾거나 없다면 break*/ while (t != nullptr \u0026amp;\u0026amp; t-\u0026gt;key != item) { t = (item \u0026lt; t-\u0026gt;key) ? t-\u0026gt;left : t-\u0026gt;right; } return t; } /*새로운 key 삽입함수로 root노드 반환*/ void Insert(int item) { /*새로운 노드 삽입*/ if (this-\u0026gt;root == nullptr) { NodePtr x = new node; x-\u0026gt;key = item; this-\u0026gt;root = x; return; } NodePtr y; //삽입할 x의 부모노드 y NodePtr y_next = this-\u0026gt;root; /*부모노드 y찾기*/ while (y_next) { y = y_next; y_next = (y-\u0026gt;key \u0026gt; item) ? y-\u0026gt;left : y-\u0026gt;right; } /*y의 자식으로 x붙여주기*/ NodePtr x = new node; x-\u0026gt;key = item; x-\u0026gt;parent = y; if (y-\u0026gt;key \u0026gt; item) y-\u0026gt;left = x; else y-\u0026gt;right = x; Splay(x); } /*key 삭제 함수*/ void Delete(int item) { node *z = IsKey(item); Splay(z); //삭제할 노드를 root로 올린 후 resturcture if (!z-\u0026gt;left) // left child가 null replace(z, z-\u0026gt;right); else if (!z-\u0026gt;right) // left child가 null이 아니고 right child가 null일때 replace(z, z-\u0026gt;left); else { //자식이 둘다있을때 node *y = tree_minimum(z-\u0026gt;right); // find successor /*succesoor가 z의 오른쪽 자식일때*/ if (y-\u0026gt;parent != z) { replace(y, y-\u0026gt;right); y-\u0026gt;right = z-\u0026gt;right; y-\u0026gt;right-\u0026gt;parent = y; } replace(z, y); y-\u0026gt;left = z-\u0026gt;left; y-\u0026gt;left-\u0026gt;parent = y; } delete z; } /* x를 기준으로 splay*/ void Splay(NodePtr x) { /*x가 root가 될때까지*/ while (x-\u0026gt;parent) { NodePtr p = x-\u0026gt;parent; NodePtr g = p-\u0026gt;parent; /*x의 부모 노드가 root라면*/ if (!x-\u0026gt;parent-\u0026gt;parent) { if (x-\u0026gt;parent-\u0026gt;left == x) RotateRight(x-\u0026gt;parent); else RotateLeft(x-\u0026gt;parent); } /*zig zig*/ else if (x-\u0026gt;parent-\u0026gt;left == x \u0026amp;\u0026amp; x-\u0026gt;parent-\u0026gt;parent-\u0026gt;left == x-\u0026gt;parent) { RotateRight(x-\u0026gt;parent-\u0026gt;parent); RotateRight(x-\u0026gt;parent); } else if (x-\u0026gt;parent-\u0026gt;right == x \u0026amp;\u0026amp; x-\u0026gt;parent-\u0026gt;parent-\u0026gt;right == x-\u0026gt;parent) { RotateLeft(x-\u0026gt;parent-\u0026gt;parent); RotateLeft(x-\u0026gt;parent); } /*zig zag*/ else if (x-\u0026gt;parent-\u0026gt;left == x \u0026amp;\u0026amp; x-\u0026gt;parent-\u0026gt;parent-\u0026gt;right == x-\u0026gt;parent) { RotateRight(x-\u0026gt;parent); RotateLeft(x-\u0026gt;parent); } else { RotateLeft(x-\u0026gt;parent); RotateRight(x-\u0026gt;parent); } } } /*x를 중심으로 왼쪽으로 회전*/ void RotateLeft(NodePtr x) { NodePtr y = x-\u0026gt;right; x-\u0026gt;right = y-\u0026gt;left; if (y-\u0026gt;left) { y-\u0026gt;left-\u0026gt;parent = x; } y-\u0026gt;parent = x-\u0026gt;parent; if (!x-\u0026gt;parent) { root = y; } else if (x == x-\u0026gt;parent-\u0026gt;left) { x-\u0026gt;parent-\u0026gt;left = y; } else { x-\u0026gt;parent-\u0026gt;right = y; } x-\u0026gt;parent = y; y-\u0026gt;left = x; } /*x를 중심으로 오른쪽으로 회전*/ void RotateRight(NodePtr x) { NodePtr y = x-\u0026gt;left; x-\u0026gt;left = y-\u0026gt;right; if (y-\u0026gt;right) { y-\u0026gt;right-\u0026gt;parent = x; } y-\u0026gt;parent = x-\u0026gt;parent; if (!x-\u0026gt;parent) { root = y; } else if (x == x-\u0026gt;parent-\u0026gt;left) { x-\u0026gt;parent-\u0026gt;left = y; } else { x-\u0026gt;parent-\u0026gt;right = y; } x-\u0026gt;parent = y; y-\u0026gt;right = x; } /* 삭제시 */ void replace(NodePtr u, NodePtr v) { if (!u-\u0026gt;parent) root = v; else if (u == u-\u0026gt;parent-\u0026gt;left) u-\u0026gt;parent-\u0026gt;left = v; else u-\u0026gt;parent-\u0026gt;right = v; if (v) v-\u0026gt;parent = u-\u0026gt;parent; } /*y를 중심으로 오른쪽으로 회전*/ /*show tree*/ void print_helper(NodePtr root, std::string indent, bool last) { // print the tree structure on the screen if (root != nullptr) { std::cout \u0026lt;\u0026lt; indent; if (last) { std::cout \u0026lt;\u0026lt; \u0026#34;R----\u0026#34;; indent += \u0026#34; \u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;L----\u0026#34;; indent += \u0026#34;| \u0026#34;; } std::cout \u0026lt;\u0026lt; root-\u0026gt;key \u0026lt;\u0026lt; std::endl; print_helper(root-\u0026gt;left, indent, false); print_helper(root-\u0026gt;right, indent, true); } } /*중위순회*/ void Inorder(NodePtr target) { if (target == nullptr) return; Inorder(target-\u0026gt;left); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; Inorder(target-\u0026gt;right); } /*후위순회*/ void Postorder(NodePtr target) { if (target == nullptr) return; Postorder(target-\u0026gt;left); Postorder(target-\u0026gt;right); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } /*전위순회*/ void Preorder(NodePtr target) { if (target == nullptr) return; std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; Preorder(target-\u0026gt;left); Preorder(target-\u0026gt;right); } public: SplayTree() { this-\u0026gt;root = nullptr; } //최솟값 찾기 NodePtr tree_minimum(NodePtr x) { while (x-\u0026gt;left != nullptr) { x = x-\u0026gt;left; } return x; } //최댓값 찾기 NodePtr tree_maximum(NodePtr x) { while (x-\u0026gt;right != nullptr) { x = x-\u0026gt;right; } return x; } void DisplayMenuBoard() { std::cout \u0026lt;\u0026lt; \u0026#34; ** Splay Tree ** \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; Menu \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 1. Insert Key \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 2. Delete Key \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 3. Show Tree \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 4. choose order \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 5. show Menu \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 6. clear Display \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 7. exit \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::endl; } void SelectMenu() { DisplayMenuBoard(); int i = -1; while (i != 8) { std::cout \u0026lt;\u0026lt; \u0026#34;(show Menu : 5) --\u0026gt; select : \u0026#34;; std::cin \u0026gt;\u0026gt; i; switch (i) { case 1: Insert_helper(); break; case 2: Delete_helper(); break; case 3: print_helper(root, \u0026#34;\u0026#34;, true); break; case 4: Order_helper(); break; case 5: DisplayMenuBoard(); break; case 6: system(\u0026#34;cls\u0026#34;); DisplayMenuBoard(); break; case 7: return; default: std::cout \u0026lt;\u0026lt; \u0026#34; !!! Wrong entered !!!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; } } } void Insert_helper() { int item; std::cout \u0026lt;\u0026lt; \u0026#34;Key to insert : \u0026#34;; std::cin \u0026gt;\u0026gt; item; if (IsKey(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;!!! \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; is already exists !!!\\n\u0026#34;; return; } Insert(item); return; } void Delete_helper() { int item; std::cout \u0026lt;\u0026lt; \u0026#34;Key to delete : \u0026#34;; std::cin \u0026gt;\u0026gt; item; if (!IsKey(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;!!! \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; is not exists !!!\\n\u0026#34;; return; } Delete(item); return; } void Order_helper() { int i; std::cout \u0026lt;\u0026lt; \u0026#34; == Order Menu ==\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 1. PreOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 2. InOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 3. PostOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 4. exit\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; select : \u0026#34;; std::cin \u0026gt;\u0026gt; i; switch (i) { case 1: Preorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 2: Inorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 3: Postorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 4: return; default: std::cout \u0026lt;\u0026lt; \u0026#34; !!! Wrong enter !!!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; break; } return; } }; int main() { SplayTree tree; tree.SelectMenu(); return 0; } "},{"section":"Blog","slug":"/blog/datastructure/aa-tree/","title":"AA Tree","description":"BBST중에 하나인 AA Tree의 특징과 구현방법에 대해 정리하고 c++을 이용해 직접 구현해보는 글","date":"2021년 6월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"Tree, AA Tree","content":"RB-Tree를 응용한 트리로 RB-Tree의 많은 조건을 일부 제거하여 구현을 더 간단하게 만든 트리로 균형을 맞추기 위해 레벨의 개념을 사용한 트리이다.\n부모와 레벨이 같은 자식 노드의 연결을 수평 링크라고 하며, 이 노드를 구분하기 위해 RED라는 개념을 이용한다.\n1. 특징 왼쪽 자식은 RED가 될 수 없다. 연속으로 RED가 올 수 없다. (이중 RED 불가 == 이중 수평 링크) 루트에서 null가지 leafnode까지의 경로에는 동일한 수의 블랙 노드가 존재한다. (RB Tree의 규칙) 모든 leaf node의 레벨은 1이다. 모든 왼쪽 자식의 레벨은 부모의 레벨보다 1 낮다. 모든 오른쪽 자식의 레벨은 부모와 같거나 1 낮다. 모든 오른쪽 손자의 레벨은 할아버지 노드보다 낮다. 1보다 큰 레벨의 모든 노드들은 2개의 자식을 갖는다. 왼쪽 트리를 얼핏 보면 RB-Tree같지만 왼쪽 자식은 RED를 갖지 않는 AA-Tree이고, 이를 레벨을 기준으로 보면 오른쪽과 같이 그려 볼 수 있다.\n2. 사용 기법 1) Split 이중 수평 링크(이중 red)일 시 해결하기 위한 방법으로 지금까지 다른 BBST와 동일하게 rotate의 개념이다.\n이중 red가 생기는 경우는 위 사진과 같이 무조건 오른쪽 방향으로 생기기 때문에 할아버지 노드(35) 기준으로 left방향으로만 rotate시키고 색을 바꿔 주면 된다.\n특징으로 Split을 수행하면 level이 달라진다.\n2) Skew red가 왼쪽자식으로 위치 한 경우 규칙에 위배되기 때문에 해결하는 방법으로 문제가 되는 노드(40)과 부모 노드(50)을 right rotate 시키고 색을 바꿔 이중 레드로 만드는 방법이다.\nSkew는 회전을 수행해도 기본적으로 동일한 level선상에서 바뀐다.\n3. 구현 위에서 말한 것처럼 실제 구현에 있어, 실제 red / black의 값을 갖는 데이터를 추가하지 않아도 구현이 가능하나 level을 저장할 데이터를 추가해야 한다.\n1) 삽입 BST규칙에 맞게 삽입 후 문제가 되는 노드를 Split과 Skew를 통해 rebalancing하며 root까지 올라가면서 규칙에 위배되지 않을 때 까지 split과 skew를 수행하면 된다.\n2) 삭제 삭제할 노드가 red leafnode 그냥 제거하면 된다.\n삭제할 노드가 하나의 leaf node 자식을 갖는 내부 노드 인 경우 삭제할 노드는 검은색이고, 자식은 레드일 수 밖에 없기 때문에 자식과 값을 교환 후, 삭제하면 된다.\n두개의 자식이 있고 successor가 red일 경우 이는 red가 leafnode일 경우밖에 없기 때문에 값을 교환 후 leafnode를 삭제하면 된다.\n두개의 자식이 있고 successor가 한 개의 leaf node 자식을 갖는 경우 값을 교환 후 2번 규칙 적용하면 된다.\n두개의 자식이 있고, Successor가 black leaf node 이거나 삭제할 노드가 black leaf node 일 경우 black leaf node를 삭제 시 레벨 2이상의 노드는 2개의 자식을 갖는 다는 규칙이 깨지므로 아래와 같은 과정을 수행해주어야 한다.\nLeaf node를 삭제하고 그 부모 노드(15)의 레벨을 한 단계 감소시킨다.\n할아버지 노드(30)의 레벨과 부모 노드의 레벨이 2이상 차이 난다면 할아버지 레벨도 1감소시킨다.\n또, 할아버지 노드의 오른쪽 자식(80)이 red일 경우 오른쪽 자식도 레벨 1감소 시킨다.\n그 후, 할아버지 노드(30)를 기준으로 skew, 할아버지 오른쪽 자식(80)의 노드 기준으로 skew 한다. 할아버지(30) 오른쪽 손자 노드(80)를 기준으로 skew를 수행한다.\n그 후, 할아버지 노드(30)을 기준으로 split을 수행한다.\n마지막으로 할아버지 노드의 오른쪽 자식(60)을 기준으로 split을 수행한다.\n3) 순회 과정 일반 BST와 동일하게 전위 / 중위 /후위 로 순회를 하는 방법이 있다.\n4) 탐색 과정 AA Tree또한, BBST이므로 탐색 방법은 동일하고 O(lgn)의 시간 복잡도를 보장한다.\n4. 시간 복잡도 삽입과 삭제 과정에서 rotate가 일어나는데 이는 O(1)만큼의 시간이 소요되고 이 rotate가 최대 O(lgn) 만큼 일어나기 때문에 O(lgn)의 시간 복잡도를 갖는다.\n5. RB Tree와 비교 RB-Tree와 비교해서 자식의 왼쪽에 있냐 오른쪽에 있냐 대칭이지도 않고 무조건 한쪽방향으로만 회전도 할 수 있고 case 수도 훨씬 적어 구현이 간단하며, red/black은 설명을 쉽게 하기 위해 구분 지어 설명한 것이지 실제 구현에 있어서는 red/black의 값을 갖는 추가 데이터가 필요하지 않다. (자식이지만 같은 레벨에 있는 자식을 red라고 명명했을 뿐)\n6, 구현 코드 코드 보기 github으로 보기 /* * C++ 이용하여 AA Tree 구현하기 * * 목적 : AA Tree 공부 하기 위해 작성했으며, * C++ 이용하여 작성하시는 분들에게 도움이 되고자 했다. * * 설명 : key 값은 int만 가능 하며 중복 key는 허용 x * 단순 연결 리스트로 구현 * * class AA Tree * * 변수 : root =\u0026gt; root node * * 생성자 : AATREE =\u0026gt; root 를 null로 초기화 * * 함수 : IsKey =\u0026gt; key값이 있는지 검사하는 함수 * * Insert =\u0026gt; 재귀를 이용한 삽입 함수 (return void) * Delete =\u0026gt; 재귀를 이용한 삭제 함수 (return void) * * split(x) =\u0026gt; x가 이중 레드를 가지고 있다면 rotate (return void) * skewy(x) =\u0026gt; x의 왼쪽자식이 레드일때 level변화 없이 교환 (return void) * * Inorder,Preorder,Postorder =\u0026gt; 순회 함수 * tree_minimum(x), tree_maximum(x) =\u0026gt; 노드 x 기준으로 가장 왼쪽, 오른쪽 return 함수 * * DisplayMenu, SelectMenu =\u0026gt; 초기 Menu판 print 함수 * Insert_helper,Delete_helper,order_helper,print_helper =\u0026gt; 각각 이벤트 수행시 입력받고 조건 에러 처리 위한 함수 와 tree print * 해주는 함수 * * Balancing에서 각 case에 대한 설명은 github에 적어 놓았다. * * 작성자 : gowoonsori * github : https://github.com/gowoonsori/my-tech/tree/master/dataStructure/Tree */ #include \u0026lt;algorithm\u0026gt; // max() 함수 이용 #include \u0026lt;iostream\u0026gt; struct node { int key; node *left = nullptr; node *right = nullptr; int level = 1; }; typedef node *NodePtr; class AATree { private: NodePtr root; //루트 노드 // key값이 있는지 없는지 검사 있으면 pointer 값, 없으면 nullptr NodePtr IsKey(int item) { NodePtr t = root; /*key값을 찾거나 없다면 break*/ while (t != nullptr \u0026amp;\u0026amp; t-\u0026gt;key != item) { t = (item \u0026lt; t-\u0026gt;key) ? t-\u0026gt;left : t-\u0026gt;right; } return t; } /*새로운 key 삽입함수로 root노드 반환*/ void Insert(int item, NodePtr \u0026amp;x) { /*새로운 노드 삽입*/ if (!x) { NodePtr y = new node; y-\u0026gt;key = item; x = y; return; } else if (x-\u0026gt;key \u0026lt; item) { Insert(item, x-\u0026gt;right); } else { Insert(item, x-\u0026gt;left); } /*재귀적으로 Insert를 수행하기 때문에 삽입 위치부터 루트까지 올라가며 규칙이 위배되는 지 검사하여 skew, split 수행이 가능하다.*/ skew(x); split(x); } /*key 삭제 함수*/ void Delete(int item, NodePtr \u0026amp;x) { static NodePtr y, p; // y : 삭제할 노드가 red leaf인지 판별하기 위한 포인터 // p : 자식이 두개인 경우 successor와 값을 교환후 삭제하기 위한 포인터 if (!x) return; y = x; if (item \u0026lt; x-\u0026gt;key) { Delete(item, x-\u0026gt;left); } else { p = x; Delete(item, x-\u0026gt;right); } /*삭제할 노드가 red leaf이거나 successor가 red leaf일때*/ if (x == y) { p-\u0026gt;key = x-\u0026gt;key; x = x-\u0026gt;right; delete y; } else { /*x의 레벨과 자식의 레벨이 2이상 차이날경우*/ if ((x-\u0026gt;left \u0026amp;\u0026amp; x-\u0026gt;left-\u0026gt;level \u0026lt; x-\u0026gt;level - 1) || (x-\u0026gt;right \u0026amp;\u0026amp; x-\u0026gt;right-\u0026gt;level \u0026lt; x-\u0026gt;level - 1)) { /*x의 레벨을 감소 시키고 x의 오른쪽 자식이 레드 일경우 자식도 레벨 감소*/ if (x-\u0026gt;right-\u0026gt;level \u0026gt; --x-\u0026gt;level) { x-\u0026gt;right-\u0026gt;level = x-\u0026gt;level; } skew(x); skew(x-\u0026gt;right); skew(x-\u0026gt;right); split(x); split(x); } } } void split(NodePtr \u0026amp;x) { /*x의 손자와 x의 레벨이 같을때 == 이중 레드*/ if (x-\u0026gt;right \u0026amp;\u0026amp; x-\u0026gt;right-\u0026gt;right \u0026amp;\u0026amp; x-\u0026gt;right-\u0026gt;right-\u0026gt;level == x-\u0026gt;level) { NodePtr y = x-\u0026gt;right; x-\u0026gt;right = y-\u0026gt;left; y-\u0026gt;left = x; x = y; x-\u0026gt;level++; } } void skew(NodePtr \u0026amp;x) { /*x의 왼쪽자식이 레드일때 레벨의 변화 없이 값 교환*/ if (x-\u0026gt;left \u0026amp;\u0026amp; x-\u0026gt;left-\u0026gt;level == x-\u0026gt;level) { NodePtr y = x-\u0026gt;left; x-\u0026gt;left = y-\u0026gt;right; y-\u0026gt;right = x; x = y; } } /*y를 중심으로 오른쪽으로 회전*/ /*show tree*/ void print_helper(NodePtr root, std::string indent, bool last) { // print the tree structure on the screen if (root != nullptr) { std::cout \u0026lt;\u0026lt; indent; if (last) { std::cout \u0026lt;\u0026lt; \u0026#34;R----\u0026#34;; indent += \u0026#34; \u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;L----\u0026#34;; indent += \u0026#34;| \u0026#34;; } std::cout \u0026lt;\u0026lt; root-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; (\u0026#34; \u0026lt;\u0026lt; root-\u0026gt;level \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; print_helper(root-\u0026gt;left, indent, false); print_helper(root-\u0026gt;right, indent, true); } } /*중위순회*/ void Inorder(NodePtr target) { if (target == nullptr) return; Inorder(target-\u0026gt;left); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; Inorder(target-\u0026gt;right); } /*후위순회*/ void Postorder(NodePtr target) { if (target == nullptr) return; Postorder(target-\u0026gt;left); Postorder(target-\u0026gt;right); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } /*전위순회*/ void Preorder(NodePtr target) { if (target == nullptr) return; std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; Preorder(target-\u0026gt;left); Preorder(target-\u0026gt;right); } public: AATree() { this-\u0026gt;root = nullptr; } //최솟값 찾기 NodePtr tree_minimum(NodePtr x) { while (x-\u0026gt;left != nullptr) { x = x-\u0026gt;left; } return x; } //최댓값 찾기 NodePtr tree_maximum(NodePtr x) { while (x-\u0026gt;right != nullptr) { x = x-\u0026gt;right; } return x; } void DisplayMenuBoard() { std::cout \u0026lt;\u0026lt; \u0026#34; ** AA Tree ** \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; Menu \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 1. Insert Key \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 2. Delete Key \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 3. Show Tree \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 4. choose order \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 5. show Menu \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 6. clear Display \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 7. exit \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::endl; } void SelectMenu() { DisplayMenuBoard(); int i = -1; while (i != 8) { std::cout \u0026lt;\u0026lt; \u0026#34;(show Menu : 5) --\u0026gt; select : \u0026#34;; std::cin \u0026gt;\u0026gt; i; switch (i) { case 1: Insert_helper(); break; case 2: Delete_helper(); break; case 3: print_helper(root, \u0026#34;\u0026#34;, true); break; case 4: Order_helper(); break; case 5: DisplayMenuBoard(); break; case 6: system(\u0026#34;cls\u0026#34;); DisplayMenuBoard(); break; case 7: return; default: std::cout \u0026lt;\u0026lt; \u0026#34; !!! Wrong entered !!!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; } } } void Insert_helper() { int item; std::cout \u0026lt;\u0026lt; \u0026#34;Key to insert : \u0026#34;; std::cin \u0026gt;\u0026gt; item; if (IsKey(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;!!! \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; is already exists !!!\\n\u0026#34;; return; } Insert(item, root); return; } void Delete_helper() { int item; std::cout \u0026lt;\u0026lt; \u0026#34;Key to delete : \u0026#34;; std::cin \u0026gt;\u0026gt; item; if (!IsKey(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;!!! \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; is not exists !!!\\n\u0026#34;; return; } Delete(item, root); return; } void Order_helper() { int i; std::cout \u0026lt;\u0026lt; \u0026#34; == Order Menu ==\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 1. PreOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 2. InOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 3. PostOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 4. exit\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; select : \u0026#34;; std::cin \u0026gt;\u0026gt; i; switch (i) { case 1: Preorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 2: Inorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 3: Postorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 4: return; default: std::cout \u0026lt;\u0026lt; \u0026#34; !!! Wrong enter !!!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; break; } return; } }; int main() { AATree tree; tree.SelectMenu(); return 0; } "},{"section":"Blog","slug":"/blog/golang/pointer/","title":"포인터","description":"Go Lang의 포인터에 대해 정리한 글","date":"2021년 6월 2일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"메모리 주소를 값으로 갖는 데이터 타입\n1. 선언 방법 var a int var p *int p = \u0026amp;a 메모리주소를 가리킬 데이터타입형에 *를 붙이면 해당 타입의 메모리주소를 담는 포인트형을 선언 할 수 있다. \u0026amp; 를 이용해서 변수의 메모리주소 시작값을 할당 할 수 있다.\n메모리 주소 시작값은 하나의 값으로 일종의 숫자 값이다.\n2. 사용 방법 var a int var p *int var b *int var c *int p = \u0026amp;a b = \u0026amp;a c = \u0026amp;a *p = 20 //해당 메모리주소에 값을 할당 p = 20 //error fmt.Println(*b) //20 포인터 변수를 선언할때 말고 사용하는 시점에 변수앞에 *를 붙이면 메모리주소에 들어있는 값을 의미하고 이를 이용해 메모리주소에 값을 할당 할 수 있다.\n만일, 포인터변수에 int값을 할당하려고 하면 포인터타입 != int 이기 때문에 타입에러가 난다.\n3. 특징 1) 여러 변수에서 같은 메모리를 가리킬 수 있다. var a int var b *int var c *int b = \u0026amp;a c = \u0026amp;a a = 20 fmt.Println(*b) //20 fmt.Println(*c) //20 포인터타입 변수도 변수이기 때문에 위 코드의 b,c는 같은 메모리 공간(a의 메모리주소)을 가리킬 수 있다.\n2) 메모리주소는 16진수로 표현한다. a := 1 b := \u0026amp;a fmt.Println(b) //0xc00007e010 fmt.Printf(\u0026#34;%d\u0026#34;, b) //824634236944 보통 메모리주소는 16진수로 표현되는데 이는 10진수로 표현하게 되면 숫자가 너무 커지고 컴퓨터가 관리하기 더 수월하기 때문이다.\n3) ==연산이 가능하다. a := 1 b := \u0026amp;a c := \u0026amp;a d := c fmt.Println(b == c) //true fmt.Println(b == d) //true fmt.Println(\u0026amp;a == d) //true fmt.Println(*d) //1 *int(\u0026amp;a) //error 메모리 주소도 하나의 값으로 표현하고 관리하기 때문에 값 비교가 가능하다. C는 메모리주소를 포인터타입으로 변경이 가능하지만 Go는 다른 데이터타입에서 포인터타입으로의 형변환은 금지하고 있기 때문에 에러가 발생한다.\n4) 기본값은 nil var p *int if p == nil{ fmt.Println(\u0026#34;아무것도 안가리킵니다.\u0026#34;) } null과 같은 의미로 nil이 아니라는 소리는 p가 유효한 메모리 주소를 가리킨다는 뜻이다.\n4. 사용 목적 int변수 하나를 선언해서 함수에서 변수의 값을 증가시키는 프로그램을 만들어보면서 사용목적을 봐보자.\nimport ( \u0026#34;fmt\u0026#34; ) func addCount(count int){ count++; } func main() { count := 0 addCount(count) fmt.Println(count) //0 } 함수의 매개변수로 기본데이터타입을 이용해서 넘겨주어 만들어보면 우리의 예상과는 다르게 값이 증가하지 않는 것을 볼 수 있다. 이는 각 함수마다 별도의 스택공간을 가지고있기 때문인데 이런이유로 서로다른 함수에서 같은 이름의 지역변수를 사용할 수 있는 것이다.\n그런데 매개변수로 기본데이터타입을 넘겨주면 addCount함수에서 count변수를 하나 새로 생성해서 main함수의 count변수의 값을 복사해오는 것이기 때문에 count라는 변수는 서로 엄연히 다른 변수이다. addCount에서 count를 아무리 증가시키고 줄이고 해도 main의 count는 아무런 영향이 없는 것이다.\n한마디로 call by value이기 때문이다. 이를 해결하려면 call by reference로 참조할수 있는 메모리 주소를 넘겨주면 되는데 이때 Go는 포인터를 이용해서 해결한다.\nfunc addCount(count *int){ *count++; } func main() { count := 0 addCount(\u0026amp;count) fmt.Println(count) //1 } 포인터타입을 매개변수로 받고 값을 변경시킬 데이터의 메모리주소를 \u0026amp; 이용해서 넘겨주어 제어하면 값이 변경되는 것을 볼 수 있다. 또한, call by value라면 인자의 메모리크기 그대로 새로 메모리에 할당하지만 포인터만 넘겨주게 되면 포인터 타입 크기(8byte) 만큼만 할당되기 때문에 메모리를 절약할 수 있는 이점도 있다.\n이런 이점도 있지만 데이터가 의도치 않게 손상되지 않도록 조심해야 한다.\n5. 구조체 포인터 초기화 //case 1 var data Data //Data타입 구조체 변수 var p1 *Data = \u0026amp;data //case 2 var p2 *Data = \u0026amp;Data{} Data타입의 구조체변수를 선언해서 이 주소를 할당하는 방식이 기본이며, 구조체를 익명 생성하자마자 그 메모리를 할당하는 방법도 존재한다.\n6. 인스턴스 //1개의 인스턴스 var data Data var p1 := \u0026amp;data var p2 := \u0026amp;data var p3 := \u0026amp;data //4개의 인스턴스 var data1 := data var data2 := data var data3 := data 인스턴스는 실제로 메모리에 할당된 하나의 데이터로 위의 예제에서 p1~p3는 실제로는 data라는 변수의 한개의 데이터만을 가리키고있기 때문에 한개의 인스턴스가 생성된것으로 볼 수 있고 data1~data3는 값을 data의 값을 복사해서 새로운 메모리에 할당(인스턴스 샐성)한 것이기 때문에 각각의 인스턴스를 갖아 총 4개의 인스턴스가 생성된다.\n1) 삭제되는 시점 인스턴스는 어떤 곳에서도 사용하지 않으면 (가리키지 않으면) 사라지는데 이는 가비지 컬렉터가 다음 GC타임에 자동으로 삭제를 해준다. 포인터가 있는 c/c++과 비교해서 Go는 GC가 있어 메모리관리가 조금더 편리한 것 같다.\nGC는 보통 Java에서 많이 들어봤는데 Java의 GC는 가상머신에서 동작하는데 비해 Go는 실행파일 안에 GC가 내장되어 생산성이 높고 Java같이 힙 압축, 세대별 GC등과 같은 기능을 수행하지 않고 CMS(Concurrent Mark \u0026amp; Sweep) 만 수행하기 때문에 가벼운 특징이 있다.\nGo의 GC에 대해 자세히 정리한 글 2) 구조체 포인터를 이용해 객체 생성하기 type User struct{ name string age int } func NewUser(name string, age int) *User { var u = User(name,age) return \u0026amp;u } func main(){ userPointer := NewUser(\u0026#34;AAA\u0026#34;,23) fmt.Println(userPointer) //\u0026amp;{AAA 23} } 지금까지 설명을 잘 들었다면 위의 코드에서 이상한점을 느낄 것이다. 함수내의 변수는 스택영역에 할당된다고 했는데 NewUser()에서 지역변수인 u의 메모리 주소를 return하고 있기 때문이다. 우리 생각대로라면 u의 메모리는 함수가 끝났기 때문에 없어지고 userPointer에는 쓰레기 값이나 error가 발생할 것 같은데 정상적으로 잘 동작한다.\n이는 Go의 특별한 기능인 Escape analyzing(탈출 분석) 때문인데 컴파일 타임에 컴파일러가 메모리타입을 return할때 해당 변수가 지역변수라면 스택영역에서 힙영역으로 데이터를 옮겨주기 때문에 함수가 종료되어도 다른 함수내에서 선언한 변수를 접근할 수 있게 된다.\nGo는 이런 특징을 이용해서 객체를 생성하는 생성자를 선언할 수 있다.\n//case 1 fmt.Println((*userPointer).name) //AAA //case 2 fmt.Println(userPointer.name) //AAA userPointer는 포인터타입기 때문에 값에 접근하기 위해서는 case1과 같이 사용해야하는데 구조체 포인터라면 내부의 필드를 접근할때 *를 생략해서 작성해도 접근할 수 있도록 제공을 하고 있다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\nTucker의 Go 강좌 "},{"section":"Blog","slug":"/blog/java/set/","title":"Set","description":"Java의 Set Interface와 구현체인 HashSet,TreeSet,LinkedHashSet에 대해 정리한 글","date":"2021년 6월 1일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"Set은 자바의 Collection중에 객체를 중복하지 않고 하나만 저장하는 자료구조로 List와 다르게 저장순서(index)를 따로 저장하지 않기 때문에 이를 통해 접근할 수 없다.\nSet interface 제공 메서드 메서드 리턴 값 설명 add(E e) boolean 객체 추가성공하면 true addAll(Collection c) boolean 컬렉션을 추가하면 데이터들을 Set에 맞게 저장 remove(Object o) boolean 객체 삭제 contains(Object o) boolean 객체가 포함되었는지 여부 eqauls(Object o) boolean 같은지 비교 clear() void Set 초기화 iterator() Iterator set 요소 접근하기 위한 Iterator객체 반환 1. HashSet Set을 구현한 구현체중에 하나로 Key를 Hash와 하여 저장하는 Set이다.\n//선언 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); //add System.out.println(set.add(1)); //true System.out.println(set.add(1)); //false System.out.println(set.add(0)); //true System.out.println(set.add(-1)); //true System.out.println(set.add(2)); //true //iterator를 이용한 모든 key 접근 Iterator\u0026lt;Integer\u0026gt; it = set.iterator(); while(it.hasNext()){ System.out.println(it.next()); //0, -1, 1, 2 } //remove System.out.println(set.remove(1)); //true //contains System.out.println(set.contains(1)); //false it = set.iterator(); while(it.hasNext()){ System.out.println(it.next()); //2 } HashSet은 Set에서 제공하는 메서드외에는 별도로 제공하는 메서드가 없고 내부적으로는 HashMap으로 동작하기 때문에 접근속도가 빠르다. 그리고 별도의 index를 가지지 않기 때문에 모든 데이터를 순회하고 싶을때는 Iterator를 이용해서 접근하면 된다.\n//HashSet 내부 private transient HashMap\u0026lt;E,Object\u0026gt; map; private static final Object PRESENT = new Object(); public HashSet() { map = new HashMap\u0026lt;\u0026gt;(); } public boolean add(E e) { return map.put(e, PRESENT)==null; } 위는 HashSet의 내부를 일부 가져온 것인데 살펴보면 내부 필드로 HashMap을 가지고 있어 이를 이용(합성)해서 HashSet을 구현하고 있고 add와 같은 메서드도 Map의 put메서드를 이용해서 데이터를 추가하는 것을 볼 수 있다.\n여기서 한가지 더 유심히 볼 부분이 PRESENT라는 객체인데 Set은 key만을 저장하는 자료구조이기 때문에 value는 어떤 객체가 오든 상관이없다. 그래서 HashSet을 만든 개발자는 어떤 HashSet에서든 모든 데이터는 value값을 동일한 value값을 가르키도록 static으로 PRESENT라는 객체를 생성해 메모리를 절약하는식으로 구성을 하였다.\n2. LinkedHashSet HashSet과 거의 동일하지만 데이터의 입력된 순서대로 저장을하고 관리를 한다. 기본적으로는 HashSet보다는 성능이 조금 뒤쳐지지만, HashMap의 capacity가 커지는 경우에는 HashSet보다는 성능이 좋다.\nSet\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); System.out.println(set.add(1)); //true System.out.println(set.add(0)); //true System.out.println(set.add(-1)); //true System.out.println(set.add(2)); //true Iterator\u0026lt;Integer\u0026gt; it = set.iterator(); while(it.hasNext()){ System.out.println(it.next()); //1, 0, -1, 2 } LinkedHashSet도 Set의 메서드만을 갖고 있고, HashSet과 비교해해보면 데이터를 추가한 순서대로 출력하는 것을 볼 수 있다.\n3. TreeSet TreeSet은 정렬된 상태의 Set을 사용하고 싶을때 사용할 수 있는 구현체로 SortedSet을 상속받은 NavigableSet을 구현한 구현체이다.\n◾ 제공 메서드 메서드 리턴 값 설명 add(E e) boolean 객체 추가성공하면 true addAll(Collection c) boolean 컬렉션을 추가하면 데이터들을 Set에 맞게 저장 remove(Object o) boolean 객체 삭제 contains(Object o) boolean 객체가 포함되었는지 여부 eqauls(Object o) boolean 같은지 비교 clear() void Set 초기화 iterator() Iterator set 요소 접근하기 위한 Iterator객체 반환 descendingIterator() Iterator 현재 정렬 순서의 반대로의 Iterator객체 반환 ceiling(E e) E 객체보다 크거나 같은 객체중 가장 가까운 객체 return higher(E e) E 객체보다 큰 객체중 가장 가까운 객체 return floor(E e) E 객체보다 작거나 같은 객체중 가장 가까운 객체 return lower(E e) E 객체보다 작은 객체중 가장 가까운 객체 return first() E 첫번째 객체 return last() E 마지막 객체 return headSet(E e) SortedSet 객체보다 큰 객체들만 모아 Set return headSet(E,boolean) NavigableSet headSet()에서 객체E를 포함할지 결정해서 return subSet(E from,E to) SorteSet from는 포함하고 to는 포함하지 않고 to까지의 객체 Set return subSet(E from,boolean, E to,boolean) NavigableSet from부터 to 각각 같은거 포함할지 결정해서 Set return tailSet(E e) SortedSet 객체보다 작거나 같은 객체Set return tailSet(E,boolean) NavigableSet 객체를 포함할지 결정해 Set return pollFirst() E 첫번째 객체 삭제하면서 return pollLast() E 마지막 객체 삭제하면서 return ◾ 사용 예 TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(Arrays.asList(4,2,3,-1,0,8,4,2,7,10)); System.out.println(set); //[-1, 0, 2, 3, 4, 7, 8, 10] //근접한 요소 접근 System.out.println(set.ceiling(4)); //4 System.out.println(set.higher(4)); //7 System.out.println(set.floor(2)); //2 System.out.println(set.floor(2)); //0 System.out.println(); //부분집합 추출 System.out.println(set.headSet(3)); //[-1, 0, 2] System.out.println(set.headSet(3,true)); //[-1, 0, 2, 3] System.out.println(set.subSet(3,8)); //[3, 4, 7] System.out.println(set.subSet(3,false,8,true)); //[4, 7, 8] System.out.println(set.tailSet(4)); //[4, 7, 8, 10] System.out.println(set.tailSet(4,false)); //[7, 8, 10] System.out.println(); //Iterator Iterator it = set.iterator(); while(it.hasNext()){ System.out.print(it.next() + \u0026#34; \u0026#34;); //-1 0 2 3 4 7 8 10 } System.out.println(); //역순 Iterator it = set.descendingIterator(); //10 8 7 4 3 2 0 -1 while(it.hasNext()){ System.out.print(it.next() + \u0026#34; \u0026#34;); } System.out.println(); //내림차순 TreeSet 선언 TreeSet\u0026lt;Integer\u0026gt; descSet = new TreeSet\u0026lt;\u0026gt;(Collections.reverseOrder()); descSet.addAll(Arrays.asList(4,2,3,-1,0,8,4,2,7,10)); System.out.println(descSet); //[10, 8, 7, 4, 3, 2, 0, -1] TreeSet은 이름에서 유추할 수 있듯이 내부적으로 Tree로 구성되어있는 Set이다. 그렇기 때문에 특정 원소를 기준으로 다음,이전값이나 부분집합을 구할 수 있는 것인데 Tree는 데이터에따라 잘못하면 편향트리가 되어 접근하는데 O(N)이 소모되기 때문에 Balancing을 해주어야한다. 그래서 TreeSet도 내부를 봐보면 HashSet이 HashMap을 이용해서 합성한 것 처럼 TreeSet도 TreeMap을 이용해서 합성해 구현되어 있다.\n//TreeSet 내부구조 중 일부 private transient NavigableMap\u0026lt;E,Object\u0026gt; m; private static final Object PRESENT = new Object(); public TreeSet() { this(new TreeMap\u0026lt;\u0026gt;()); } public boolean add(E e) { return m.put(e, PRESENT)==null; } TreeMap은 SortedMap의 구현체로 내부적으로 Red Black Tree로 구현되어 있어 balancing을 수행한다. 이런 이유로 HashSet은 O(1)만에 데이터를 접근할 수 있지만 TreeSet은 접근도 O(logN), 삽입/수정도 balancing수행으로 O(logN)만큼의 시간이 소요된다.\n특정한 목적이 있지 않는이상 HashSet을 이용하는 것이 performance에 좋다.\nReference https://docs.oracle.com/javase/8/docs/api/ "},{"section":"Blog","slug":"/blog/golang/control-statement/","title":"제어문","description":"Go Lang에서 제어문(if, switch) 사용하는 방법을 정리한 글","date":"2021년 6월 1일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"1. if문 제어문 중에 하나로 다른 언어들과 사용목적은 동일하며 if~else if~else 를 똑같이 지원한다.\n1) 선언 방법 score := 56 if score \u0026gt; 80 { fmt.Println(\u0026#34;A\u0026#34;) } else if(score \u0026gt; 50) { //소괄호로 감쌌지만 not Error fmt.Println(\u0026#34;B\u0026#34;) } else { fmt.Println(\u0026#34;C\u0026#34;) } if true { fmt.Println(\u0026#34;true\u0026#34;) //조건이 bool이면 success } if 1 { fmt.Println(\u0026#34;true\u0026#34;) //bool이 아니면 error } Java나 c처럼 **()**로 조건문을 감싸지 않고 바로 조건문을 작성하면 되고 Java처럼 조건문은 bool타입을 반환해야 한다. C/C++처럼 0이 false, 1이상이 true로 인식되지 않는다.\n소괄호로 감싸지 않는게 기본 문법이지만 감싼다고 해서 에러가 발생하지는 않는다.\n2) Error 발생하는 경우 //1 if (socre \u0026gt; 80) fmt.Println(\u0026#34;A\u0026#34;) //2 if score \u0026gt; 80 { fmt.Println(\u0026#34;A\u0026#34;) } //3 if score \u0026gt; 80{ fmt.Println(\u0026#34;A\u0026#34;) } else{ fmt.Println(\u0026#34;B\u0026#34;) } Go는 지금까지 설명한것처럼 특정 문법 형식을 강제하는 언어인데 조건문도 그 예외는 아니다.\n첫번째로 대부분의 언어에서 조건문 내부가 한줄이라면 중괄호를 생략해서 표현하기도 하는데 go는 무조건 중괄호로 묶어야 한다. 두번째는 조건문 키워드 옆에 바로 중괄호가 시작되어야 한다. 위의 예제처럼 다음줄에서 시작한다면 error를 발생한다.\n마지막으로는 if~else if~else를 작성할때 else if나 else는 위의 조건이 끝나는 중괄호 바로 옆에 작성해야 하기 때문에 다음 문단에서 시작된다면 에러를 발생시킨다.\n2. switch문 1) 선언 방법 const ( apple = iota banana orange strawberry grape ) var name string var fruit = apple //case 1 switch fruit { case apple: name = \u0026#34;Apple\u0026#34; case banana: name = \u0026#34;Banana\u0026#34; case orange, strawberry: name = \u0026#34;Orange and StrawBerry\u0026#34; default: name = \u0026#34;Other\u0026#34; } fmt.println(name) //case 2. Expression사용 switch x:= fruit-1; x+1 { case apple: name = \u0026#34;Apple\u0026#34; case banana: name = \u0026#34;Banana\u0026#34; case orange, strawberry: name = \u0026#34;Orange and StrawBerry\u0026#34; default: name = \u0026#34;Other\u0026#34; } 기본적으로 switch키워드 뒤에 변수를 선언하고 다른 언어들과 비슷한 문법으로 switch를 사용할 수 있지만 별도의 expression을 사용할경우에는 세미콜론(;)뒤에 case로 사용될 값을 정의해주면 된다.\n1) 특징 switch뒤에 변수가 없어도 된다. score := 67 switch { case score \u0026gt;= 80: fmt.Println(\u0026#34;A\u0026#34;) case score \u0026gt;= 60: fmt.Println(\u0026#34;A\u0026#34;) case score \u0026gt;= 40: fmt.Println(\u0026#34;C\u0026#34;) default: fmt.Println(\u0026#34;F\u0026#34;) } 다른 언어는 switch 키워드 뒤에 변수나 expression을 선언하지만 Go는 선언하지 않아도 되며 선언하지않으면 true로 생각해 첫번째 case문으로 이동을 한다. 이때 case 조건으로는 bool만 올 수 있다.\ncase에 조건문 표현 가능 위의 예시처럼 case에 특정 값(리터럴)을 표현하는 것이 아니라 조건문을 선언할 수 있다. 조건문으로 case를 표시할 경우에는 리터럴값과 혼용해서 사용할 수 없다.\nscore := 50 switch score{ case 67 : fmt.Println(67) case score \u0026gt;= 80: //error fmt.Println(\u0026#34;A\u0026#34;) default: fmt.Println(\u0026#34;F\u0026#34;) } case에 변수 타입 가능 var val interface{} = 15 switch val.(type) { case int: println(\u0026#34;int\u0026#34;) case bool: println(\u0026#34;bool\u0026#34;) case string: println(\u0026#34;string\u0026#34;) default: println(\u0026#34;unknown\u0026#34;) } fmt.Println(val) //int 말그대로 case에 변수타입으로 분기할 수 있다. 이는 .(type) 을 변수로 주어지면 사용할 수 있는데 이는 동적 타입을 갖는 인터페이스의 경우 인터페이스가 가지고 있는 실제 값에 접근하게 해주는 type assertion을 이용한 것이다.\nbreak생략 가능 기존의 다른언어들은 case가 끝날때 break를 생략하게되면 다음 case가 이어서 실행되는데 Go는 break를 사용하지 않아도 한 case를 실행하면 자동으로 종료 된다.\nscore := 67 switch { case score \u0026gt;= 80: fmt.Println(\u0026#34;A\u0026#34;) fallthrough case score \u0026gt;= 60: fmt.Println(\u0026#34;A\u0026#34;) fallthrough case score \u0026gt;= 40: fmt.Println(\u0026#34;C\u0026#34;) fallthrough default: fmt.Println(\u0026#34;F\u0026#34;) } 만약에 다음 case도 이어서 실행을 하고 싶다면 fallthrough을 명시해주면 이어서 실행이 가능하다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\n"},{"section":"Blog","slug":"/blog/golang/structure/","title":"구조체","description":"Go Lang의 구조체에 대해 정리한 글","date":"2021년 5월 31일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"여러 필드를 묶어서 사용하는 타입으로 C의 structure와 비슷하며, go에서는 별도의 클래스를 키워드를 제공하지 않지만 구조체를 이용해서 클래스를 정의할 수 있다.\n1. 선언 /* type 이름 sturct{ ... 필드명 } */ type School struct{ Name string CntTeacher int } type Student struct { school School Name string score float64 } //Student형 변수 선언 var student Student student.Name = \u0026#34;홍길동\u0026#34; student.score = 87.1 struct을 이용해서 구조체를 선언하고 해당 형식의 구조체를 특정 이름이라는 타입으로 부르도록 하겠다라는 의미로 type을 이용해서 선언을 해주면 된다.\n//student라는 패키지에 선언 type Student struct { schoolInfo School Name string score float64 } //main 패키지 import ( \u0026#34;goStudy/student\u0026#34; ) func main() { student := student.Student{} student.score = 98.1 //error } 구조체내부의 필드로 다른 구조체 타입을 포함할 수 도 있다. 이때 go만의 특징으로 go는 특정 문법을 강제하는 강타입 언어인데 구조체 내부의 필드를 패키지 외부에서 접근하기 위해서는 이름은 반드시 대문자로 시작을 해야 한다. 소문자로 시작을 한다면 같은 패키지 내부에서만 접근 할 수 있다.\n2. 초기화 var student Student //zero value를 갖는 구조체 변수 var stdeunt Student = Student{\u0026#34;홍길동\u0026#34;, 12.1} student := Student{\u0026#34;홍길동\u0026#34;, 12.1} //타입 추론 3. 포함된 필드방식(Embedded field) type School struct{ Name string CntTeacher int } type Student struct { School //Embedded field Name string score float64 } 구조체 내부에 변수명 없이 타입만 설정한 field로 다른 기본형 타입은 사용이 불가능하고 구조체타입만 사용이 가능하다. 해당 필드방식으로 사용하면 School 구조체타입의 내부 필드가 Student 필드로 들어가게 되어 변수명으로 접근을 하지 않고 바로 접근을 할 수 있다.\nvar stdeunt Student student.schoolInfo.Name = \u0026#34;길동고등학교\u0026#34; //기존의 방식 student.CntTeacher = 4 //Embedded field사용한 경우 student.School.Name = \u0026#34;길동고등학교\u0026#34; //필드명이 중복이 될 경우에는 구조체 타입을 이용해서 구분해주어야 한다. 4. 구조체 크기 type User struct{ Age int Score float64 } var user User 각 필드 타입의 크기를 모두 더한만큼 변수의 크기가 설정 된기 때문에 user는 8Byte(int) + 8Byte(float64) = 16byte가 된다.\n5. 구조체 복사 type User struct{ Age int Score float64 } var user1 User = User{23, 87.1} var user2 User = user1 대입연산자를 이용해 새로운 변수에 값을 할당 해주면 go는 메모리의 값을 그대로 새로운 메모리에 할당을 해준다. 이는 Java의 class 변수를 =연산자로 할당해주면 reference를 넘겨주는 것과는 다르게 동작하기 때문에 헷갈리지 말자. (자바는 얕은 복사, go는 깊은 복사)\nuser2.Age = 56 fmt.Println(user1) // {23 87.1} fmt.Println(unsafe.Sizeof(user1)) //16 fmt.Println(user2) // {56 87.1} fmt.Println(unsafe.Sizeof(user2)) //16 user3 := \u0026amp;user user3.Age = 1 fmt.Println(user1) // {1 87.1} Reference를 넘겨주고 싶으면 포인터 타입(*)과 메모리주소를 넘겨주기 위한 키워드 \u0026amp;를 사용하면 된다. (C와 비슷하다.)\n추가) go의 표준 패키지로 unsafe라는 패키지가 있는데 이는 이름 그대로 안전하지 않은 함수를 제공한다. 그 중에 SizeOf() 는 변수가 차지하고 있는 메모리 크기(Byte)를 반환하는 함수 이다.\ntype User struct{ Age int32 Score float64 } var user1 User fmt.Println(unsafe.Sizeof(user1)) //16 위에서 설명한대로라면 int32는 4byte, float64는 8byte이기 때문에 user는 12byte를 가져야 하는데 실제로는 16byte의 크기를 갖는다. 이는 컴퓨터(go)가 컴퓨터의 사양(32bit컴퓨터/64bit 컴퓨터)에 따라 관리하기 편한 방법으로 메모리를 정렬하기 때문이다.\n현재에는 대부분 64bit컴퓨터로 8byte단위로 값을 가져오는데 합이 12byte로 4byte가 끊기기 때문에 조금 더 효율적인 관리를 위해 4byte만큼을 추가 메모리를 할당(Memory padding)해서 관리를 한다. 이는 Age가 8Byte를 갖는 것이 아니라 4byte의 빈공간을 만들어 관리하는 것이다.\n한마디로 성능을 위해서 메모리를 희생하게 된다.\ntype User struct{ a int8 b float64 c int8 } var user1 User fmt.Println(unsafe.Sizeof(user1)) //24 이는 위에서 설명한대로 8byte씩 끊어서 관리하기 때문에 24byte만큼 할당이 되었는데 8byte보다 작은 필드라면 앞으로 몰아서 필드를 선언하는 것이 메모리 패딩을 줄여 메모리를 절약할 수 있다.\ntype User struct{ a int8 c int8 b float64 } var user1 User fmt.Println(unsafe.Sizeof(user1)) //16 6. 구조체의 역할 결합도는 낮게 응집도는 높게\n함수는 비슷한 코드를, 배열은 같은 타입의 데이터를 묶어 응집도를 높이는 것이라면 구조체는 관련된 데이터를 묶어 응집도를 높여 재사용성을 증가시키는데 사용한다.\ngo는 처음에 설명한 것처럼 class가 존재하지 않고 structure가 객체로써 사용되기 위한 방법으로 사용된다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\nTucker의 Go 강좌 "},{"section":"Blog","slug":"/blog/golang/operator/","title":"연산자","description":"GO Lang의 연산자에 대해 정리한 글","date":"2021년 5월 28일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"1. 산술 연산자 구분 연산자 연산 피연산자 타입 사칙 연산과 나머지 + 덧셈 정수, 실수, 복소수, 문자열 - 뺄셈 정수, 실수, 복소수 * 곱셈 정수, 실수, 복소수 / 나눗셈 정수, 실수, 복소수 % 나머지 정수, 실수, 복소수 비트 연산 \u0026amp; AND 비트연산 정수 | OR비트 연산 정수 ^ XOR비트 연산 정수 \u0026amp;^ 비트 클리어 정수 시프트 연산 \u0026laquo; 왼쪽 시프트 정수 \u0026laquo; 양의 정수 \u0026raquo; 오른쪽 시프트 정수 \u0026raquo; 양의 정수 산술 연산은 다른 언어의 연산과 별로 다를 것이 없으며 go는 강타입 언어이기 때문에 반드시 피연산자들끼리의 타입이 같아야만 에러가 발생하지 않는다.\n1) ^ a := uint8(1) fmt.Printf(\u0026#34;%08b\u0026#34;,a) //00000001 fmt.Printf(\u0026#34;%08b\u0026#34;,^a) //11111110 비트 연산중에 **^(XOR)**은 혼자쓰이면 비트 반전(1의 보수,NOT)으로 사용될 수 있다.\n2) \u0026amp;^ a := uint8(255) fmt.Printf(\u0026#34;%08b \\n\u0026#34;,a) //11111111 fmt.Printf(\u0026#34;%08b \\n\u0026#34;,a\u0026amp;^2) //11111101 fmt.Printf(\u0026#34;%08b \\n\u0026#34;,a\u0026amp;^8) //11110111 \u0026amp;^ 연산은 비트 클리어연산으로 우측 피연산자를 ^(NOT) 으로 사용된 후 양쪽 피연산자에 대해 \u0026amp; 를 수행한 것으로 왼쪽 피연산자 비트에서 오른족 피연산자의 1의 값을 갖는 위치의 비트를 0으로 바꾸고 싶을 때 사용한다.\n3) 시프트 연산 a := uint8(1) //00000001 b := int8(-1) //11111111 fmt.Printf(\u0026#34;%08b \\n\u0026#34;,a\u0026lt;\u0026lt;4) //00010000 fmt.Printf(\u0026#34;%08b \\n\u0026#34;,uint8(b\u0026lt;\u0026lt;4)) //11110000 fmt.Printf(\u0026#34;%08b \\n\u0026#34;,a\u0026gt;\u0026gt;1) //00000000 fmt.Printf(\u0026#34;%08b \\n\u0026#34;,uint8(b\u0026gt;\u0026gt;4)) //11111111 \u0026laquo; 연산은 비트를 왼쪽으로 밀고 새로 채우는 비트는 무조건 0으로 채운다.\n\u0026raquo; 연산은 왼쪽피연산자의 부호에 따라 새로 채우는 비트의 값이 달라지며, 부호가 없는 정수라면 0, 음수라면 1로 채워진다.\n2. 비교 연산 연산자 설명 == 같다 != 같지 않다 \u0026lt; 작다 \u0026gt; 크다 \u0026lt;= 작거나 같다 \u0026gt;= 크거나 같다 1) 실수 비교 a := 0.1 b := 0.2 c := 0.3 d := a+b fmt.Println(c == d) //false fmt.Println(\u0026#34;c : \u0026#34;+ strconv.FormatFloat(c,\u0026#39;f\u0026#39;,-1,64)) //0.3 fmt.Println(\u0026#34;d : \u0026#34;+ strconv.FormatFloat(d,\u0026#39;f\u0026#39;,-1,64)) //0.30000000000000004 실수 계산시 부동소수점 방식은 오차가 발생할 수 있어 원하는 결과값을 도출해내지 못할 수 있기때문에 특정 범위까지의 오차를 지정해 무시하거나 패키지를 이용해서 정밀하게 연산을 수행하는 방법을 택해야 한다.\n특정 범위 지정 const floatRange = 0.000001 func equal(a,b float64) bool{ if a\u0026gt;b{ if a-b \u0026gt; floatRange{ return false; } return true; }else{ if b-a \u0026gt; floatRange { return false; } return true; } } func main() { a := 0.1 b := 0.2 c := 0.3 d := a+b fmt.Println(equal(c,d)) //true } 오차를 허용할 범위를 상수로 선언을 한 후에 별도의 함수를 만들어 비교하는 방법을 이용할 수 있다.\nFloat객체 import ( \u0026#34;fmt\u0026#34; \u0026#34;math/big\u0026#34; ) func main() { a, _ := new(big.Float).SetString(\u0026#34;0.1\u0026#34;) b,_ := new(big.Float).SetString(\u0026#34;0.2\u0026#34;) c,_ := new(big.Float).SetString(\u0026#34;0.3\u0026#34;) d := new(big.Float).Add(a,b) fmt.Println(c == d) //false fmt.Println(c.Cmp(d)) //0 } big의 Float객체를 이용해서 소수를 표현하고 산술/비교연산을 수행하면 정밀한 오차까지 계산을 수행할 수 있으며, 해당 변수는 객체이기 때문에 == 연산은 false가 되고 값 비교는 Cmp() 메서드를 이용하면 되고 Java의 compareTo와 비슷하게 주체가 크면 1, 작으면 -1, 같으면 0을 반환한다.\n3. 논리 연산 종류 연산자 항 개수 설명 논리 \u0026amp;\u0026amp; 다항 연산자 양변 모두 true면 true | | 다항 연산자 양변 중 하나라도 true면 true ! 단항 연산자 true이면 false, false이면 true func setD(d *int) int{ *d= 3 return *d } func main() { c := 3 d := 0 fmt.Println( true || setD(\u0026amp;d) == c) //true fmt.Println(d) //0 fmt.Println( false || setD(\u0026amp;d) == c) //true fmt.Println(d) //3 } 논리 연산시 단락 회로 평가(쇼트 서킷) 로 왼쪽 피연산자가 true나 false조건이 만족한다면 오른쪽 피연산자를 참조하지 않고 바로 return하게 된다.\n예를 들어 \u0026amp;\u0026amp; 연산을 수행할때 왼쪽 피연산자가 false라면 오른쪽 피연산자의 결과에 상관없이 false를, || 연산은 왼쪽이 true라면 바로 true를 리턴하게 된다.\n4. 대입 연산 var a int var b int a = b = 1 //error /*success*/ a = 1 b = 1 대입 연산은 다른 언어들과 거의 동일하며 복합 대입연산자도 지원을 하지만 특정 문법의 제약이 강해 위와 같은 방법으로 대입은 불가능하다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\n"},{"section":"Blog","slug":"/blog/algorithms/permutation/","title":"Permutation(순열)","description":"순열을 구현하는 여러가지 방법을 정리한 글","date":"2021년 5월 28일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"순열, Permutation","content":"1. next_permutation c++에는 algorithm헤더에 매개변수의 배열/iterator의 다음 순열을 적용시켜 바뀌었다면 true/false를 반환해주는 메서드가 존재해서 이를 do~while문으로 쉽게 순열문제를 해결할 수 있다.\n하지만, 자바는 존재하지 않기 때문에 다음과 같이 구현할 수 있다.\npublic boolean next_permutation(int[] arr){ //뒤에서부터 탐색해서 내림차순이 깨지는 지점(a) 찾기 int a = arr.length-2; while(a\u0026gt;=0 \u0026amp;\u0026amp; arr[a] \u0026gt;= arr[a+1]) a--; if(a \u0026lt; 0) return false; //a가 -1이라면 배열전체가 내림차순정렬된 상태로 순열탐색이 끝난다. //뒤에서부터 탐색하면서 a보다 큰 첫번째 인덱스(b) 찾기 int b = arr.length-1; while(arr[a] \u0026gt;= arr[b])b--; //찾은 a와 b swap swap(arr,a,b); //a+1부터 끝까지 오름차순으로 재정렬 a += 1; b = arr.length-1; while(a\u0026lt; b){ swap(arr,a++,b--); } return true; } private void swap(int[] arr, int src, int target){ int tmp = arr[src]; arr[src] = arr[target]; arr[target] = tmp; } @Test void test(){ int[] arr = new int[]{1,2,3,4}; do{ System.out.println(Arrays.toString(arr)); }while(next_permutation(arr)); } 2. swap 구현하기가 가장 쉬워 보통 알고리즘문제에 순열이 등장할때 많이쓰는 방식중 하나로 재귀함수를 이용한 백트래킹을 이용한 방법이다.\npublic void permutation(int[] arr, int depth, int n,int r){ if(depth == r){ System.out.println(Arrays.toString(arr)); return; } for(int i=depth; i \u0026lt; n; i++){ swap(arr,depth,i); permutation(arr, depth+1,n,r); swap(arr,depth,i); } } private void swap(int[] arr, int src, int target){ int tmp = arr[src]; arr[src] = arr[target]; arr[target] = tmp; } @Test void test(){ int[] arr = new int[]{1,2,3,4}; permutation(arr,0,4,4); } 3. visited swap과 구현코드는 비슷하기 때문에 구현하는 것은 쉽게 할 수 있다. 하지만 swap과 다르게 배열의 앞에서부터 값을 쌓아나가는 방식으로 List를 이용해 값을 쌓아 나갈 수도 있고 depth가 r과 같아질때가 아니더라도 조건처리하기가 훨씬 쉽다.\nif(visited[i]) continue; 부분만 지워주면 중복순열(자기자신을 포함)을 구할수 있다.\npublic void permutation(int arr[],int tmp[],boolean[] visited,int depth, int n, int r){ if(depth == r){ System.out.println(cnt++ + \u0026#34; \u0026#34; + Arrays.toString(tmp)); return; } for(int i=0; i \u0026lt; n; i++){ if(visited[i])continue; visited[i] = true; tmp[depth] = arr[i]; visitedPermutation(arr,tmp,visited,depth+1,n,r); visited[i] =false; } } public void listPermutation(int arr[], List\u0026lt;Integer\u0026gt; tmp, boolean[] visited, int depth, int n, int r){ if(depth == r){ System.out.println(tmp.toString()); return; } for(int i=0; i \u0026lt; n; i++){ if(visited[i])continue; visited[i] = true; tmp.add(arr[i]); listPermutation(arr,tmp,visited,depth+1,n,r); visited[i] =false; tmp.remove(tmp.size()-1); } } public void rePermutation(int arr[],int tmp[],boolean[] visited,int depth, int n, int r){ if(depth == r){ System.out.println(Arrays.toString(tmp)); return; } for(int i=0; i \u0026lt; n; i++){ visited[i] = true; tmp[depth] = arr[i]; visitedPermutation(arr,tmp,visited,depth+1,n,r); visited[i] =false; } } @Test void test(){ int[] arr = new int[]{1,2,3}; int[]tmp = new int[3]; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); boolean[] visited = new boolean[3]; System.out.println(\u0026#34;---Array---\u0026#34;); permutation(arr,tmp,visited,0,3,3); System.out.println(\u0026#34;----List---\u0026#34;); listPermutation(arr,list,visited,0,3,3); System.out.println(\u0026#34;--중복순열--\u0026#34;); rePermutation(arr,tmp,visited,0,3,3); } "},{"section":"Blog","slug":"/blog/java/list-array/","title":"List를 Array로 Array를 List로 변환","description":"List를 Array로 Array를 List로 변환하는 여러가지 방법 정리","date":"2021년 5월 27일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"List와 Array간의 변환은 기본적으로 for문을 이용하여 하나하나 바꾸어주면 변환이 가능하다. 하지만 for이 아닌 stream API를 이용해서 더 간편하게 바꿀 수 있는 방법을 정리한다.\n1. List에서 Array로 변환 1) List -\u0026gt; Object[] List\u0026lt;Integer\u0026gt; integerList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; stringList = new ArrayList\u0026lt;\u0026gt;(); Integer[] integerArr = integerList.toArray(new Integer[integerList.size()]); String[] stringArr = stringList.toArray(new String[stringList.size()]); Object[] objectArr = integerList.toArray(); List에서 Wrapper객체배열로 바꾸는 것은 List의 toArray() 함수를 이용하면 쉽게 바꿀 수 있고 toArray() 의 매개변수로 변환할 객체배열을 넘겨주면 해당 타입의 배열로 바꾸어 반환된다.\n만일 매개변수없이 사용한다면 Object[] 로 바꾸어 반환이 된다.\n2) List -\u0026gt; primitive type[] List\u0026lt;Integer\u0026gt; integerList = new ArrayList\u0026lt;\u0026gt;(); int[] arr1 = integerList.stream().mapToInt(Integer::intValue).toArray(); int[] arr2 = integerList.stream().mapToInt(x-\u0026gt;x).toArray(); //위와 실행결과는 같다. double[] arr3 = integerList.stream().mapToDouble(Integer::intValue).toArray(); int나 double, long과 같이 primitive 타입의 배열로 바꾸고 싶을때는 IntStream,DoubleStream,LongStream의 toArray() 를 이용하면 원시타입배열로 바꿀 수 있다.\nList를 stream으로 바꾼 후 mapToInt() , mapToDouble() \u0026hellip;와 같은 스트림api의 함수를 이용해 해당타입의 Stream으로 변경할 수 있다. 위의 함수는 map 과 동일하지만 결과물이 특정타입의 Stream으로 변환된다는 차이가 있다.\n3) 다중 List -\u0026gt; 다중 primitive값 배열 //2차원 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int[][] arr2 = list.stream() .map(l -\u0026gt; l.stream() .mapToInt(Integer::intValue) .toArray()) .toArray(int[][]::new); //3차원 List\u0026lt;List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int[][][] arr3 = list.stream() .map( l1 -\u0026gt; l1.stream() .map(l2 -\u0026gt; l2.stream() .mapToInt(Integer::intValue) .toArray()) .toArray(int[][]::new)) .toArray(int[][][]::new); 다중 List를 다중 배열로 바꾸기 위해서는 map을 이용해서 계속 한 차원씩 줄이고, 1차원으로 줄여졌을때는 mapToInt를 이용해서 앞에서 설명한것 과 같이 만들어 주면 된다.\n하지만 메서드 chaining이 복잡해져 헷갈릴 수 있기 때문에 for문을 작성하는게 편할 수도 있다.\n2. Array 에서 List로 변환 1) Object[] -\u0026gt; List Integer[] integerArr = new Integer[10]; String[] stringArr = new String[10]; List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(integerArr); List\u0026lt;String\u0026gt; stringList = Arrays.asList(stringArr); Arrays의 asList() 함수를 이용하면 래퍼객체 배열로 쉽게 변경이 가능하다.\n2) primitive[] -\u0026gt; List int[] integerArr = new int[10]; double[] doubleArr = new double[10]; List\u0026lt;Integer\u0026gt; integerList1 = Arrays.stream(integerArr).boxed().collect(Collectors.toList()); List\u0026lt;Integer\u0026gt; integerList2 = IntStream.of(integerArr).boxed().collect(Collectors.toList()); List\u0026lt;Double\u0026gt; doubleList = Arrays.stream(doubleArr).boxed().collect(Collectors.toList()); primitive타입을 Wrapper객체로 바꾸어 주어야 하기 때문에 특정타입의 Stream(ex. IntStream)에 있는 boxed() 메서드를 이용하는데 이함수는 IntStream에서 Stream 로 Wrapper객체로 감싸진 Stream으로 바꾸어주는 메서드이다.\nboxed() 를 사용하기 위해 Arrays.stream()으로 특정타입의 Stream으로 바꾸어주면 되고 boxed()로 바꾸어진 Stream을 collect메서드로 새로 list를 만들어 줄 수 있다.\nIntStream의 boxed()메서드를 이용하기 위해 Arrays의 stream()을 이용해도 되고 IntStream의 of() 를 이용해서 InstStream을 만들 수 있다.\n3) 다중 primitive배열 -\u0026gt; 다중 List //2차원 int[][] arr2 = new int[][]{{1,2},{2,3}}; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list2 = Arrays.stream(arr) .map(tmp -\u0026gt; IntStream.of(tmp) .boxed() .collect(Collectors.toList())) .collect(Collectors.toList()); //3차원 int[][][] arr3 = new int[][][]{{{1,2},{2,3}}}; List\u0026lt;List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;\u0026gt; list3 = Arrays.stream(arr3) .map(tmp -\u0026gt; Arrays.stream(tmp) .map(tmp2 -\u0026gt; IntStream.of(tmp2) .boxed() .collect(Collectors.toList())) .collect(Collectors.toList())) .collect(Collectors.toList()); 다중 배열에서 List로 변환도 위에서 설명한 다중 List -\u0026gt; 다중 배열 과 같이 map을 이용해 1차원이 될때까지 분해후 List로 만들어 주면된다.\n여기서 IntStram.of() 는 매개변수로 1차원 배열밖에 받지 않기 때문에 3차원을 2차원 Stream으로 바꾸기 위해서는 IntStram.of가 아니라 Arrays.stream() 을 이용해야 한다.\n"},{"section":"Blog","slug":"/blog/golang/constant/","title":"상수","description":"Go Lang의 상수에 대해 정리한 글","date":"2021년 5월 26일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"상수는 Immutable(불변)한 특징을 갖으며 한 번 할당된 값을 변경할 수 없는 변수이다.\nconst a int = 1 const b string = \u0026#34;hi\u0026#34; const d = 10 //자료형을 생략가능하다. f := 10 //이는 자동으로 var 형태의 변수로 선언이 되기 때문에 상수가 될 수 없다. var runTimeVar int = 1 const e = runTimeVar * 10 //runTimeVar는 런타임에 값이 할당되기 때문에 컴파일타임에 d의 값을 할당할 수 없어 error가 발생한다. 상수 키워드는 const로 선언방식은 변수 var와 같고 short assginment statement는 var키워드 전용이기 때문에 상수는 짧은 대입문 사용이 불가능 하다. 또한, 반드시 컴파일 타임에 실행이 가능한 표현식이어야만 한다.\nconst a,b,c = 1, true, \u0026#34;hi\u0026#34; const d = [5]int{1,2,3,4,5} //error 상수에는 문자열, 숫자, bool타입만 가능하고, js같이 자료구조(배열,map 등)와 같이 내부적으로 포인터를 이용하는 타입들은 상수로 표현이 불가능하다. go에서 상수는 컴파일타임에 실행이 가능해야하기 때문에 내부의 값이 변할 수 있는 타입들은 상수로 표현이 불가능하다.\nconst a1 int = 1 const b1 float64 = 3 const sum1 = a1 + b1 fmt.Printf(\u0026#34;%d, %T\\n\u0026#34;, sum, sum) //error const a2 = 1 const b2 = 3 const sum = a2 + b2 fmt.Printf(\u0026#34;%d, %T\\n\u0026#34;, sum, sum) //4, int const casting = 1 / 3.0 //암묵적으로 형변환이 일어난다. fmt.Printf(\u0026#34;%g, %T\\n\u0026#34;, sum, sum) // 0.333333.., float64 타입을 생략해서 표현할 수 도 있는데 이렇게 되면 실제로 사용되는 시점(명시적 형변환)전까지는 type이 존재하지 않는다.\n그리고, 상수의 산술연산에서 암묵적 형변환을 지원해서 조금 더 유연하게 표현할 수 있다.\n1. 상수 사용시기 상수는 변수에 비해 매우 큰 표현 범위를 갖을 수 있어 높은 정밀도를 제공하기 때문에 보다 정확한 계산을 위해 사용되거나 열거형(Enum) 을 만드는데 사용할 수 있다.\nfmt ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main(){ const maxInt = math.MaxInt64 //int64의 최대값 const maxConst = 1 \u0026lt;\u0026lt; 100 //int 표현의 범위를 벗어났지만 실제 int로 명시하기 전에는 int타입이 아니기 때문에 표현이 가능하다. fmt.Println(maxInt) //9223372036854775807 fmt.Println(maxConst) //함수로 표현하려고 하면 타입의 명시가 일어나 int범위를 벗어나 overflow가 발생한다. ftm.Println(maxConst * 0.1) //1.2676506002282295e+29 \u0026lt;-- 산술연산 중에 암묵적으로 float로 형변환이 일어나 overflow가 발생하지 않는다. } const i1 = 14345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345 //error 정수형 상수도 저장할 수 있는 한계가 존재하기는 한다.\n2. Enum Go는 Java나 C++ 처럼 enum을 제공하지 않기 때문에 C에서 enum을 비슷하게 만들어 사용하는 것처럼 go도 const를 이용해서 enum을 만들어 사용할 수 있다. 또한, iota라는 상수 생성자를 제공해서 순차적으로 증가하는 상수값을 쉽게 선언 할 수 있다.\nconst ( a = 1 //1으로 시작 b //1 c //1 ) const ( a = iota //0으로 시작 b //1 c //2 ) const ( a = iota + 1 //1으로 시작 b //2 c //3 ) const ( a = 1 \u0026lt;\u0026lt; iota //1 b //2 c //4 d //8 ) 3. 상수와 리터럴 리터럴은 변수의 값이 변하지 않는 데이터로 메모리 안의 존재하는 값 그자체를 의미한다.\nvar a int = 1 변수를 할당하는 데 있어 주로 우측에 오는 값으로 1이라는 값 그 자체는 변경할 수 없는데 이를 리터럴이라고 한다. 1이라는 값이 2가 될 수 없는 것이다.\nvar s string = \u0026#34;ex\u0026#34; string의 \u0026ldquo;ex\u0026rdquo; 도 리터럴인데 ex라는 값이 heap에 한번 할당되고 값이 변경되지 않기 때문이다. 우리가 string변수를 연산자를 이용해서 문자열을 붙이는 것은 기존의 ex라는 값에 붙이는 것이 아니라 heap공간에 ex+새로운 문자열 을 새로 할당하는 방식으로 동작하기 때문에 string의 우측에 오는 값도 리터럴이다.\nNote\n리터럴도 변하지 않는 값이기 때문에 상수와 햇갈릴 수 있지만, 상수는 값을 한번만 저장하고 변경이 불가능한 메모리 공간이고, 리터럴은 값 그자체로 변경이 불가능한 값이다.\nReference https://tramamte.github.io/2018/07/03/deep-inside-constants/ 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\n"},{"section":"Blog","slug":"/blog/golang/array/","title":"배열","description":"Go Lang의 배열에 대해 정리한 글","date":"2021년 5월 26일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"배열은 연속된 메모리에 저장된 자료구조로 다른 자료구조 중 Random Access가 가장빠르고 고정된 길이의 자료구조이다. 배열과 비슷한 자료구조로 go에는 slice가 존재하는데 slice는 동적인 길이의 배열과 같다.\n1. 선언 방식 func main(){ var a [5]int } 배열은 고정된 size의 자료구조이기 때문에 변수를 선언하는 방식에서 타입을 **[]**를 이용해서 size를 선언해주면 된다. 배열안의 값들의 기본값은 제로값(zero value)로 할당된다.\na := [5]int{1,2,3,4,5} b := [5]int{1,2,3} for _,v := range a{ fmt.Print(v,\u0026#34; \u0026#34;) //1,2,3,4,5 } for _,v := range b{ fmt.Print(v,\u0026#34; \u0026#34;) //1,2,3,0,0 } 배열을 선언하면서 바로 초기화를 하고 싶은 경우에는 := 를 이용해서 위와 같이 선언과 초기화를 동시에 할 수 있으며 초기화를 하지 않은 메모리에는 zero value가 들어간다.\n2. 배열의 사용법 a := [5]int{1,2,3,4,5} fmt.Print(a[1]) //2 a[1] = 0; fmt.Print(a[1]) //0 다른 언어의 배열 사용법과 같이 변수뒤에 [] 를 이용하여 특정 index메모리에 접근을 할 수 있으며 조회,수정,삽입이 가능하다.\n3. 배열의 메모리 크기 1차원 배열,2차원 배열, 그 이상의 배열이더라도 총 선언된 길이 * 자료형 메모리 크기의 메모리 size를 갖는다.\n예를 들어 a := [5]int 라면 int가 32bit(4byte)이므로 4byte _ 5의 메모리 size만큼을 갖으며, b := [2][5]int 라면 4byte _ 2 * 5 만큼의 size를 갖는다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\n"},{"section":"Blog","slug":"/blog/golang/function/","title":"함수","description":"GO Lang의 함수에 관해 정리한 글","date":"2021년 5월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"1. 함수 생성 방법 package main func main(){ a := 1 say(a) } func say(a int) { println(a) } func키워드를 이용해서 함수를 선언할 수 있고 가장 기본적으로 만드는 main도 함수 이다.\n2. 매개변수(인자) 1) 전달 방식 Java처럼 primitive자료형은 pass by value, reference자료형은 pass by refernece가 아닌 go는 C처럼 *을 이용해서 value인지 reference인지 정해서 넘겨줄 수 있다.\nfunc main(){ a := 1 increase1(a) println(a)\t//1 increase2(\u0026amp;a) println(a)\t// 2 } func increase1(a int) { a+=1 } func increase2(a *int) { *a+=1 } 포인터를 이용해서 변수의 주소를 넘겨주면 pass by reference로 함수에서도 해당 함수를 호출한 곳의 변수의 값을 변경할 수 있다.\n2) 중복된 자료형 생략 package main import \u0026#34;fmt\u0026#34; func main() { variousVariables(1,2,true, 1.2) } func variousVariables( a, b int, c bool, d float32){ fmt.Println(a,b,c,d) //1 2 true 1.2 } 위처럼 매개변수가 같은 자료형을 갖는다면 변수선언 방식과 비슷하게 자료형을 생략해서 마지막에만 작성을 해주어도 된다.\n3) 가변 인자 함수 매개변수의 개수가 정해지지 않고 여러개를 전달할때 사용할 수 있는 함수 기법으로 \u0026hellip; 을 이용하여 표현할 수 있다.\nfunc main() { say(1,2,3,4) say(10) } func say(nums ...int) { for _, num := range nums { println(num) } } 3. 리턴 값 go는 다른 언어들과는 다르게 리턴값을 void나 하나가 아닌 여러개를 가질 수 있다.\nfunc main() { total1 := sum1(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) println(total1) //55 count, total2 := sum2(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) println(count, total2) //10 55 } func sum1(nums ...int) int { sum := 0 for _, num := range nums { sum += num } return sum } func sum2(nums ...int) (int, int) { s := 0 count := 0 for _, n := range nums { s += n count++ } return count, s } return값이 여러개일 경우에는 () 로 묶어 표시해야 하고 return문을 , 을 이용해서 여러개의 값을 return하도록 작성해주면 된다.\n1) Named Return Parameter return값에 이름을 지정하는 Named Return Parameter도 제공한다.\nfunc main() { count, total2 := sum2(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) println(count, total2) //10 55 } func sum2(nums ...int) ( count int, s int) { for _, n := range nums { s += n count++ } return } 위처럼 return값에 자료형만 작성하는 것이 아니라 변수명을 작성해 줄 수 있는데 이는 매개변수처럼 하나의 변수로써 생성이 되기 때문에 zero value로 처음에 선언이 되고 함수내부에서 변수처럼 사용이 가능하다. 또한 return문을 작성할때 필요로하는 return값들을 모두 작성해줄 필요없이 return만 작성해도 변수에 할당된 값을 그대로 반환해주기 때문에 쉽게 작성이 가능하다.\n4. 익명 함수 JS의 익명함수 처럼 함수의 이름이 없는 함수로써 그자리에서 한번만 바로 실행하는 함수를 작성하거나 변수에 할당하기 위한 방식의 함수 이다.\nfunc main() { sum := func(n ...int) int { s := 0 for _, i := range n { s += i } return s } result := sum(1, 2, 3, 4, 5) //익명함수 호출 println(result) } 함수의 선언 방식은 거의 똑같지만 func키워드 뒤에 함수명이 오지 않고 이렇게 선언한 함수를 바로 변수에 할당하는 것을 볼 수 있다.\n변수에 할당하게 되면 그 변수이름으로 함수를 똑같이 사용이 가능하다.\n5. 일급 함수 go에서 함수는 하나의 데이터 타입으로 취급되기 때문에 다른 함수의 파라미터로 전달하거나 리턴값으로 사용할 수 있다.\npackage main func main() { add := func(a int, b int) int { return a + b } result1 := calc(add, 10, 20) println(result1) result2 := calc(func(a int, b int) int { return a + b }, 10, 20) println(result2) } func calc(f func(int, int) int, a int, b int) int { result := f(a, b) return result } calc() 의 매개변수로 func키워드를 이용해 함수를 매개변수로 받을 수 있으며, 이때 매개변수타입과 reutrn타입을 작성해주어야 한다. 이렇게 함수를 매개변수로 받으면 해당 함수 내에서 인자로받은 함수를 사용할 수 있다.\n함수의 매개변수로 함수를 넘겨줄때는 result1처럼 익명함수를 통해 선언된 함수타입 변수를 넘겨주거나 result2처럼 바로 익명함수를 작성해서 넘겨주는 방식도 가능하다.\n1) 함수 type 정의 함수의 매개변수로 함수타입을 받을 때 매개변수의 타입과 return타입을 매번 작성해주는 것이 번거로울 수 있는데, C/C++의 typedef처럼 go도 type을 이용해 함수 원형을 정의 하여 반복코드를 줄일 수 있다.\npackage main type funcII func(int,int) int func main() { add := func(a int, b int) int { return a + b } result1 := calc(add, 10, 20) println(result1) } func calc(f funcII, a int, b int) int { result := f(a, b) return result } 이렇게 함수원형을 정의하고 함수를 다른 함수에 전달하고 리턴받는 기능을 Delegate라고 부른다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\n"},{"section":"Blog","slug":"/blog/golang/io/","title":"표준 입출력","description":"Go Lang의 배열에 대해 정리한 글","date":"2021년 5월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"GoLang의 표준 입출력은 다른 언어와 같이 터미널이 기본이며, 파일등으로 수정이 가능하고 fmt패키지에서 제공을 한다.\n입출력은 BitStream형태로 되어있다.\n1. 표준 출력 1) 함수 함수 기능 Print() 입력값들을 출력 Println() 마지막에 개행문자를 포함한 입력값들을 출력 Printf() c의 printf와 같이 특정 포맷에 맞게 출력 2) 포맷 서식 포맷형태 설명 %d 정수 %f 실수(소수점 6자리까지 표현) %v 기본형태(자동으로 맞는 값으로 변경) %g 길이에 맞는 실수형태로 변경해서 출력(%v로 사용시 실수의 경우 %g로 바뀜) %3d 3자리 칸에 맞춰 오른쪽 정렬해 출력 %03d 3자리 칸에 맞춰 출력하는데 빈칸을 0으로 채움 %-3d 3자리 칸에 맞춰 왼쪽정렬해 출력 package main import fmt func main(){ a := 1 b := 0.5 c := 123456789 fmt.Println(a+c) fmt.Prnit(b) fmt.Printf(\u0026#34;%3d, %03d, %-3f\\n\u0026#34;,a,b,c) } 2. 표준 입력 1) 함수 함수명 기능 Scan() 표준 입력(키보드)에서 공백과 개행을 기준으로 값을 입력 Scanf() 특정 포맷형태에 맞게 값을 입력 Scanln() 표준 입력에서 공백을 기준으로 값을 입력 Scan()과 Scanln() 차이점 : Scan()은 공백과 개행을 기준으로 값을 나눠 입력받고, Scanln()은 공백을 기준으로 값을 나눠 입력받는다.\npackage main import fmt func main(){ var a int var b int var c int n, err := fmt.Scanln(\u0026amp;a, \u0026amp;b, \u0026amp;c) if err != nil { fmt.Printlnf(err) }else{ fmt.Println(n,a,b,c) } } fmt의 입력함수 인자값으로 C처럼 변수의 메모리 주소를 주어야 하며, 반환 값으로는 두개가 있는데 첫번째가 입력받은 값의 개수이고 두번째는 err메세지이다. 따라서 위처럼 error처리를 해줄 수 있다.\n표준 입력장치(키보드)로부터 입력받아 쌓인 데이터는 버퍼에 저장이 되며 버퍼의 값을 입력함수를 통해 읽어오는 방식으로 동작을 하는데, 중간에 error가 발생했거나 개행문자가 남아있거나 하는등의 문제가 발생하는 경우가 존재한다. 이때 버퍼를 비워주어야 하는데 이는 아래와 같이 bufio 패키지를 추가하여 접근할 수 있다.\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { stdin := bufio.NewReader(os.Stdin) // 표준 입력 var a int var b int var c int n, err := fmt.Scanln(\u0026amp;a, \u0026amp;b, \u0026amp;c) if err != nil { fmt.Println(err) stdin.ReadString(\u0026#39;\\n\u0026#39;) // 표준입력을 통해 개행문자가 올때까지 읽는 것이기 때문에 에러 발생시 버퍼를 비울 수 있다. } else { fmt.Println(n, a, b,c) } } 위와 같이 기본 Scan함수들을 사용하면 문자열은 무조건 공백으로 구분을 하기 때문에 한줄씩 읽을 수가 없는데 개행으로 구분하고 싶다면 위와 비슷하게 구성하면 된다.\n//개행을 구분으로 문자열 입력 import ( \u0026#34;fmt\u0026#34; \u0026#34;bufio\u0026#34; \u0026#34;os\u0026#34; ) func main() { //Reader이용 in := bufio.NewReader(os.Stdin) line, _ := in.ReadString(\u0026#39;\\n\u0026#39;) strings.TrimSuffix(line,\u0026#34;\\n\u0026#34;) fmt.Println(line) //Scanner 이용 sc := bufio.NewScanner(os.Stdin) sc.Scan() //한줄 읽기 str := sc.Text() //읽은 문자열을 변수에 할당 //여러줄의 문자열 읽기 for sc.Scan(){ fmt.Println(sc.Text()) } } ReadString()으로 읽은 string은 구분문자(delimeter) 를 포함하여 반환하기 때문에 마지막에 \\n을 제거하고 싶다면 한줄을 추가해주어야 한다.\nScanner의 Scan()은 delimeter가 제거된 문자열을 반환해주기 때문에 조금더 편하게 사용할 수 있다. NewReader에는 ReadByte,ReadBytes등의 저수준의 데이터를 읽어올 수 있는 함수가 있기 때문에 상황에 맞게 사용하면 된다.\n추가 내용 ◾ go run 실행파일을 만들지 않고 스크립트형태로 그냥 바로 실행시키는 명령어\n◾ go build 컴파일을 통해 실행 파일을 만드는 명령어\n◾ 패키지와 모듈 패키지와 모듈은 다른 개념이다.\n모듈은 데이터,함수,구조체 등이 담겨져있는 파일 하나하나이고 패키지는 연관된 모듈들의 집합이다.\n예를 들어 main이라는 패키지에서도 표준 입출력을 위해 fmt모듈과 bufio, os 모듈을 사용한 것과 같다.\nReference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\n"},{"section":"Blog","slug":"/blog/settings/timezone/","title":"리눅스 Timezone 설정하기","description":"Ubuntu time-zone 설정하기","date":"2021년 5월 11일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Settings","tags":"Linux","content":"1. 현재 서버 시간확인 $ date 리눅스를 설치할 때 timezone을 따로 설정하지 않으면 UTC 타임존으로 설치가 되고, date명령어로 현재 서버의 시간을 확인할 수 있다.\n2. /etc/localtime 심볼릭 링크파일 수정 /usr/share/zoneinfo/에 여러 국가들의 정보가 존재하는데 바꾸고자 하는 지역을 /etc/localtime라는 이름으로 기존의 존재하는 심볼릭링크 파일을 수정해주면 됩니다.\n$ sudo ln -sf /usr/share/zoneinfo/Asia/Seoul /etc/localtime 3. timedatectl $ sudo timedatectl set-timezone \u0026#39;Asia/Seoul\u0026#39; timedatectl명령어를 이용하면 현재 timezone에 대한 정보를 확인할 수 있고 변경도 할 수 있다. 위의 명령어의 실제 동작 방식은 1번과 같이 /etc/localtime 의 심볼릭링크를 수정하는 것과 같다.\n$ timedatectl #실행 모습 Local time: Tue 2021-05-11 16:14:32 KST Universal time: Tue 2021-05-11 07:14:32 UTC RTC time: Tue 2021-05-11 07:14:33 Time zone: Asia/Seoul (KST, +0900) System clock synchronized: yes NTP service: active RTC in local TZ: no 항목 설명 Local time 현재 지역 시간 Universal time 협정 세계시(UTC) RTC time 서버 하드웨어의 시간 Time zone 시간대 System clock synchronized NTP로 동기화 되었는지 여부 NTP service NTP 활성화 여부 RTC in local TZ RTC 시계를 시스템 시계와 동일하게 사용할지 여부 NTP : 네트워크로 연결되어 있는 컴퓨터들끼리 시간을 동기화 시키는데 사용되는 프로토콜 ( 국내에도 여러 타임서버가 존재하고 이를 이용해 시간을 동기화 한다.)\n3. .profile에 time설정 값 추가 $ echo \u0026#34;TZ=\u0026#39;Asia/Seoul\u0026#39;;export TZ\u0026#34; \u0026gt;\u0026gt; .profile $ source ~/.profile Reference https://zetawiki.com/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_KST_%EC%8B%9C%EA%B0%84%EB%8C%80_%EC%84%A4%EC%A0%95 "},{"section":"Blog","slug":"/blog/error/spring-security-cors-error/","title":"Spring Security Cors Mapping Error","description":"Spring Security를 이용해 cors설정 시에 발생한 mapping error","date":"2021년 5월 2일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Error","tags":"Spring Security, CORS, Spring Boot","content":"CORS 란? Cross-Stie HTTP Requests의 약자로 한 도메인이 다른 도메인의 자원을 사용하는 것을 의미하는데, chrome cors 기본정책이 strict-origin-when-cross-origin으로 Same Origin에 대해서만 자원을 사용하도록 제한되어 있다. 여기서 Same-Origin이란 호스트명, 프로토콜, 포트가 같은 도메인을 말한다.\nFront 서버와 Back서버를 나눠 개발을 진행하다 보면 두 주소(포트)가 달라 cors에러가 발생한다. 그래서 서버단에서 특정 origin을 허용할 수 있게 cors설정을 추가로 해주어야 한다.\n1. Config SpringBoot에서 Cors 설정을 위해서는 filter, annotation, config를 이용하는 방법이 존재하는데 그중 하나인 config 설정을 아래와 같이 적용해 줄 수 있다.\n@Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/**\u0026#34;) //패턴 .allowedOrigins(\u0026#34;http://localhost:8080\u0026#34;,\u0026#34;http://localhost:8081\u0026#34;) //특정 URL 설정 //.allowedOrigins(\u0026#34;*\u0026#34;) //All Allow // .allowedOriginPatterns(\u0026#34;*\u0026#34;) //All Allow // .allowedOriginPatterns(\u0026#34;http://localhost:*\u0026#34;) //Pattern 적용 가능 .allowedHeaders(\u0026#34;header1\u0026#34;,\u0026#34;header2\u0026#34;) //header .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;) //method .allowCredentials(true); //false 면 cookie 설정 불가능 } } WebMvcConfigurer 인터페이스를 구현한 Config 클래스를 빈으로 등록함으로써 CORS 정책을 등록해줄 수 있는데, 위와 같은 메서드드들로 특정 URL만 cors를 허용해줄 수 있으며 \u0026ldquo;*\u0026ldquo;와 같이 작성하면 모든 URL에 대해 허용해줄 수 있다.\nallowCredentials 를 true로 설정해주었다면, 보안 정책상 allowedOrigins(\u0026rdquo;*\u0026quot;)는 불가능하다. 그럼에도 모든 요청에 대한 허용을 하고 싶다면 allowedOriginPatterns(\u0026rdquo;*\u0026quot;)를 이용하면 된다.\n2. Spring Security Config @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.httpBasic().disable() .cors() //Cors 옵션 활성화 //...다른 설정들 생략 ; } //Cors 설정 @Bean public CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.addAllowedOrigin(\u0026#34;*\u0026#34;); // configuration.addAllOriginPatterns(\u0026#34;*\u0026#34;); configuration.addAllowedHeader(\u0026#34;*\u0026#34;); configuration.addAllowedMethod(\u0026#34;*\u0026#34;); configuration.setAllowCredentials(true); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026#34;/**\u0026#34;, configuration); return source; } } 적용방식은 1번과 거의 비슷한데, CorsConfigurationSource 빈을 위와 같이 설정하여 등록해주면 된다.\n3. 에러 java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value \u0026#34;*\u0026#34;since that cannot be set on the \u0026#34;Access-Control-Allow-Origin\u0026#34; response header. To allow credentials to a set of origins, list them explicitly or consider using \u0026#34;allowedOriginPatterns\u0026#34; instead. CORS 설정하다보면 위와 같은 에러를 만날 수도 있는데, 해결방법은 간단하다. AllOrigin(\u0026quot;*\u0026quot;) 과 allowCrededentials(true) 를 동시에 사용할 수 없어서 나는 에러로 AllOriginPatterns(\u0026quot;*\u0026quot;) 를 이용하거나 특정 URL만 허용해주면 된다.\n"},{"section":"Blog","slug":"/blog/golang/variable/","title":"변수","description":"GO Lang의 변수와 데이터 타입에 대해 정리한 포스팅","date":"2021년 4월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"1. 변수 선언 1) 기본 방법 var a int var a int = 10 var b,c,d int = 1,2,3 //동시에 여러개 변수 선언도 가능하다. var키워드로 변수를 선언하고 변수명 다음 데이터 타입을 명시해주어야 하고, 선언만 하고 초기화를 해주지 않으면 go는 Zero value를 할당한다.\nNote\nZero Value\n숫자 = 0 bool = false string = \u0026quot;\u0026quot; 2) 타입 추론 var a = 10 var q,w,e = 1, true, \u0026#34;#\u0026#34; //동시에 여러개 변수 선언을 할때 다른 타입이더라도 추론을 통해 선언해준다. 위 처럼 변수 뒤의 타입형태를 제외한 형식의 타입추론도 가능하다.\n3) := (Short Assignment Statement) package main import \u0026#34;fmt\u0026#34; func main(){ a := 10 fmt.Println(a) } 변수선언하면서 초기화를 :=를 이용하면 var을 생략해서 작성이 가능하지만, 함수내에서만 가능하다.\npackage main import \u0026#34;fmt\u0026#34; a := 10 //error var a = 10 //ok func main(){ fmt.Println(a); } 4) 여러개 지정 var ( a = 1 b = 10 c = 20 ) 중괄호 로 묶어 한번에 선언을 할 수도 있고 함수밖에 선언하면 같은 패키지에서 모두 사용할 수 있는 패키지 전역변수로 선언된다.\n2. 데이터 타입 1) bool true와 false만 갖는 bool형으로 기본 값은 false이고 c처럼 0이 false가 되지는 않는다.\n2) 문자열(string) 문자열을 나타내는 데이터 타입으로 Java와 같이 Immutable하기 때문에 한번 생성되면 수정 할 수 없다.\n특정 변수의 문자열을 수정하는 것은 메모리내의 문자열을 수정하는 것이 아닌 다른 메모리에 수정한 문자열을 할당하고 그 메모리를 가르키도록 바꾼 것.\n문자열 리터럴은 백틱(``), 이중인용부호(\u0026quot;\u0026quot;)를 이용해서 표현할 수 있다.\nfunc main(){ str := `ddd ddd ddd` fmt.Println(str) } //output ddd ddd ddd func main(){ str := \u0026#34;ddd ddd ddd\u0026#34; //error str := \u0026#34;ddd\\nddd\\nddd\u0026#34; //success fmt.Println(str) } 기본값은 빈 문자열 (\u0026quot;\u0026quot;)이다.\n3) 정수(int) 뒤의 숫자는 메모리크기(bit)로 int32는 32bit(4byte)의 크기를 갖는 int타입인 것이다.\n기본 값은 0이다.\n부호 있는 정수 int / int8 / int16/ int32/ int64\nint는 컴퓨터의 환경에 따라 바뀌며 32bit컴퓨터는 int32, 64bit컴퓨터는 int64를 의미한다.\n부호 없는 양의 정수 uint / uint8 / uint15/ uint32 / uint64 / uintptr\nuint는 int와 마찬가지로 컴퓨터의 환경에 따라 바뀌며 32bit컴퓨터는 uint32, 64bit컴퓨터는 uint64를 의미한다.\n4) 실수, 복소수 기본 값은 0.0이다.\n실수 float32 / float64\nfloat64는 8byte를 갖으며 다른 언어의 double과 비슷하다\n복소수 complex64 : 진수와 가수 범위는 float32와 같다. complex128 : 진수와 가수 범위는 float64와 같다.\n5) byte byte는 uint8의 aliasing(별칭)타입이다. uint8이 결국 1byte크기의 숫자 데이터이므로 byte와 같다.\nint의 별칭형이기 때문에 기본값은 0이다.\n6) rune 문자 한개를 나타내는 타입으로 rune이 모여 string이 된다.\n문자 1개는 UTF-8로 해당 인코딩 크기는 1~3byte의 가변 크기이므로 최소 3byte이상을 가져야 하는데 이진수를 활용하는 컴퓨터가 계산하기 편하게 4byte크기를 갖는 데이터 타입으로 int32의 aliasing이다.\nfunc main(){ a := \u0026#39;홍\u0026#39; fmt.Println(a) //54861 fmt.Printf(\u0026#34;%c\u0026#34;,a) //홍 } int의 별칭형이기 때문에 기본값은 0이다.\n7) 그 외 타입 기본 값은 nil로 nil은 정의되지 않은 메모리 주소를 나타내는 Go만의 키워드 이다.\ntype type myInt int c++의 typedef와 같이 type키워드를 이용해서 데이터타입에 대한 별칭을 정의 할 수 있다.\n배열 var a [4]int b := [5]int{1,2,3,4,5} var d [2][2]int 슬라이스 배열의 일부로 동적 배열이라고 생각하면 된다.\na := make([]int, 3) var b := []int{1,2,3} var c []int = []int{} 배열과 생성방법은 비슷하나 배열길이를 처음에 명시하지 않으면 slice이며 길이가 0인상태로 생성된다.\n내부에 길이를 뜻하는 len뿐만이 아닌 수용가능한 양을 표현하는 capacity도 있다.\n구조체 type Person struct{ name string } type키워드를 이용해서 구조체를 정의할 수 있고, go는 class키워드가 존재하지 않고 필드의 집합인 struct과 메서드들도 클래스를 구현할 수 있다.\n포인터 메모리를 가르키는 포인터변수이며, C의 포인터와 비슷한 개념이다.\nvar a int = 1 b := \u0026amp;a fmt.Println(b) *b = 3 fmt.Println(*b) Map var a map[string]int = map[string]int b := make(map[string]int) 인터페이스 type Robot interface{ getPrice() int } 인터페이스는 메서드들의 집합으로 type 키워드를 이용해서 인터페이스를 정의할 수 있다.\n채널 스레드의 일종인 고루틴간의 데이터 통신을 위한 데이터 타입이다.\nch := make(chan int) ch \u0026lt;- 123 //채널에 123을 전송 i = \u0026lt;- ch\t//채널로부터 데이터를 받아옴 3. 타입 변환 기본적인 방법으로 데이터타입() 함수를 이용해 데이터 타입을 변환 할 수 있다.\nfunc main(){ a := 10 var b = 3.15 var c = float64(a) * b fmt.Println(c) d := int64(a) e := int32(d) fmt.Println(string(d)) } 하지만 이는 bool이나 실수를 string등으로 형변환 할 수 없어 strconv모듈을 import하여 형변환을 수행할 수 도 있다.\n1) strconv import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34;\t//변수 type을 알아보기 위한 모듈 \u0026#34;strconv\u0026#34; //형변환 ) func main() { fmt.Println(\u0026#34;say hi\u0026#34;) // Itoa : 정수를 문자열로 변환 a := strconv.Itoa(100) fmt.Println(\u0026#34;a: \u0026#34;, a) // a: 100 fmt.Println(\u0026#34;type a: \u0026#34;, reflect.TypeOf(a)) // type a: string // Atoi : 문자열을 정수로 변환 b, _ := strconv.Atoi(\u0026#34;100\u0026#34;) fmt.Println(\u0026#34;b: \u0026#34;, b) // b: 100 fmt.Println(\u0026#34;type b: \u0026#34;, reflect.TypeOf(b)) // type b: int // FormatInt : 특정값(100)을 특정 진수(10진수) 문자열로 변환 aa := strconv.FormatInt(100, 10) fmt.Println(\u0026#34;aa: \u0026#34;, aa) // aa: 100 fmt.Println(\u0026#34;type aa: \u0026#34;, reflect.TypeOf(aa)) // type aa: string // FormatBool : bool을 문자열로 변환 c := strconv.FormatBool(true) fmt.Println(\u0026#34;c: \u0026#34;, c) // c: true fmt.Println(\u0026#34;type c: \u0026#34;, reflect.TypeOf(c)) // type c: string /*FormatFloat : 실수를 문자열로 변환 첫번째 인자 : 변경할 실수 값 두번째 인자 : \u0026#39;f\u0026#39; : ddd.ddd와 같은 포맷 | \u0026#39;e\u0026#39; : d.ddde+dd 포맷 세번째 인자 : 실수의 정밀도로 지수를 제외한 숫자의 자리수 ( -1입력시 자동으로 지정 ) 네번째 인자 : 부동소수점 비트 수로 32,64 지정 */ d := strconv.FormatFloat(1.3, \u0026#39;f\u0026#39;, -1, 32) fmt.Println(\u0026#34;d: \u0026#34;, d) // d: 1.3 fmt.Println(\u0026#34;type d: \u0026#34;, reflect.TypeOf(d)) //type d: string //ParseInt : 문자열 100을 10진수 64bit크기의 정수형으로 변환 bb, _ := strconv.ParseInt(\u0026#34;100\u0026#34;, 10, 64) fmt.Println(\u0026#34;bb: \u0026#34;, bb) // bb: 100 fmt.Println(\u0026#34;type bb: \u0026#34;, reflect.TypeOf(bb)) // type bb: int64 //ParseBool : bool형태의 문자열을 bool로 변환 var b1 bool b1, err = strconv.ParseBool(\u0026#34;true\u0026#34;) fmt.Println(b1, err) // true \u0026lt;nil\u0026gt; //AppendBool : bool값을 문자열로 변환 후 slice뒤에 추가 var s []byte = make([]byte, 0) s = strconv.AppendBool(s, true) fmt.Println(string(s)) // true //AppendFloat : 실수값을 문자열로 변환 후 slice뒤에 추가 s = strconv.AppendFloat(s, 1.3, \u0026#39;f\u0026#39;, -1, 32) fmt.Println(string(s)) // true1.3 //AppendInt : 정수값을 문자열로 변환 후 slice뒤에 추가 s = strconv.AppendInt(s, -10, 10) fmt.Println(string(s)) // true1.3-10 } Reference 『Tucker의 Go 언어 프로그래밍』 스터디 요약 노트\nTucker의 Go 강좌 "},{"section":"Blog","slug":"/blog/golang/feature/","title":"Golang 특징","description":"Golang의 특징에 대해 작성한 글","date":"2021년 4월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"237\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/golang/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/golang\\/golang_hu7dcbd830b732524be4a224c2724aac9f_66561_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Golang","tags":"Golang","content":"1. 특징 1) 정적 컴파일 언어 JVM을 이용하는 Java와 같이 Runtime에 환경에 맞는 기계어로 번역을 하는 동적 컴파일 언어가 아닌 c나 c++와 같이 한번 compile을 통해 특정환경에 맞는 실행파일을 만들어내는 정적 컴파일 언어이다.\n정적 컴파일 언어는 환경(Os, CPU종류)들이 다양해지면서 NxM개의 수만큼 많은 번역기가 존재했어야 하는 단점이 존재해 동적 컴파일 언어가 많은 인기였지만, 정적 컴파일 언어보다는 비교적 속도가 떨어지고 환경이 과거에 비해 비교적 고착화 되어감에 따라 다시 빠른 성능을 보여주는 정적 컴파일언어 형태로 GO가 만들어졌다.\n또한, 환경에 맞게 다른 코드를 짜는 것처럼 번거로웠던 단점을 고쳐 Go는 OS에 맞는 환경변수를 바꿔주기만 하면 쉽게 다른 환경의 프로그램으로 build가 가능하다.\ngo build : 현재 운영체제(GOOS환경변수)에 맞는 실행 파일 build go env : Go의 환경변수목록을 보여주는 명령어 GOOS : build할 운영체제 window -\u0026gt; linux $Env:GOOS = \u0026#34;linux\u0026#34; go build powerShell의 $Env 명령어로 GOOS를 linux로 바꿔주면 linux실행파일로 build가 된다.\nlinux -\u0026gt; window GOOS=\u0026#34;windows\u0026#34; go build 2) 강타입 언어 타입이 다른 연산을 해도 자동으로 형변환을 해서 연산을 수행하는 약타입 언어가 아닌 GO는 무조건 타입이 같아야 하는 최강타입 언어 이다.\n강타입 언어이기 때문에 제네릭도 존재하지 않는데 이것이 현재 뜨거운 논란 주제라고 한다.\n3) GarbageCollector 존재 정적 타입언어임에도 c,c++과 같이 GC가 없는 것이 아닌 Java와 같이 GC가 존재한다.\n메모리를 지우는데 1ms미만의 시간이 걸리는 빠른 GC를 가지고 있다.\n4) 클래스 x, 상속 x, 메서드 o, 인터페이스 o 기본적으로 class가 없고 class가 없기 때문에 상속도 없다. 상속과 클래스가 없다고 GO는 OOP가 안된다라는 말이 있는데 이는 나는 개인적으로 틀린 생각이다.\n클래스가 없는 대신 c와 비슷한 struct를 이용해 클래스와 같이 사용할 수 있고 상속은 오히려 결합도를 높이기도 하고 많은 문제를 갖을 수 있어 상속이 없다고 OOP가 아닌 것은 아니다.\nC처럼 struct은 필드밖에 가지지 못하지만 함수앞에 특별한 인자로 구조체에 함수를 할당하는 식으로 메서드를 갖을 수 있어 이것이 클래스 기능을 수행하고 상속은 없지만 인터페이스는 존재한다.\n5) 익명 함수 js의 익명함수와 같이 go도 익명함수를 제공한다.\n6) 동시성 지원 GoRutine이라고 부르는 go 함수와 같이 go키워드를 통해 쉽게 동시성(스레드)를 지원하고 Native(OS) 스레드에 매칭되는 Java의 스레드와 달리 Go런타임이 스레드를 관리하며 Multiplexing을 이용해 훨씬 적은 os쓰레드를 사용하고 스택의 사이즈도 매우 작으며 필요시에 동적으로 증가한다.\n또한, go채널(chan)을 이용해 go루틴간의 통신을 제공하고, runtime.GOMAXPROCS() 를 이용하면 병렬 처리도 할 수 있게 제공한다. GO는 기본적으로 CPU 1개를 사용하나 이 명령어를 이용하면 다수의 CPU를 이용할 수 있다.\nIn programming, concurrency is the composition of independently executing processes, while parallelism is the simultaneous execution of (possibly related) computations. Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.\n- golang.org -\n이때 동시성을 위한 go루틴과 병렬성을 위한 runtime.GOMAXPROCS() 는 엄연히 개념이 다르고 golang공식 문서에서는 위와 같이 말하고 있다.\n동시성은 독립적으로 실행되는 프로세스 구성이고 병렬성은 한가지나 특정 목적을 위한 계산을 동시에 여러군데에서 실행하는 것. 한마디로, 동시성은 많은 작업들을 동시에 처리하는 것이고 병렬성은 많은 것들을 여러개가 동시에 하는 것\n7) 패키지 관리 npm이나 maven, gradle\u0026hellip;와 같은 패키지 관리를 go에서도 지원하고 있는데 go get이나 go install로 패키지를 설치 할 수 있고 import명령어로 패키지를 사용할 수 있다.\n또한 네임스페이스는 존재하지 않고 모든 코드는 패키지 단위로 분리한다.\nReference Tucker의 Go 강좌 "},{"section":"Blog","slug":"/blog/books/speech/","title":"돈버는 말투, 돈 버리는 말투","description":"가나가와 아키노리 저자의 **돈버는 말투, 돈 버리는 말투** 소감과 평 ","date":"2021년 4월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"저자는 일본인으로 우리 한국과 일부 사회상이 안맞는 부분이 있긴 하지만 전체적으로 공감할 만한 부분들이 많았고 책도 양이 많지 않아 금방 읽힌 책이었으며, 책을 읽다보면 당연한 소리를 하고있는 것 같지만 그 당연한 것들을 지키기가 어려운 것이기에 공감한 부분들을 이곳에 정리해두려고 한다.\n1. 자신의 업무 철학 확립 자신만의 업무 철학을 물었을때는 이것에 대해 깊게 생각해본적이 없어서 대답을 하지 못했는데 이 책에서는 어렵게 생각하지 말고 어떤 점을 가장 신경 써서 일 하는지를 생각해보라고 조언을 했고 나는 그제서야 나만의 업무 철학을 조금씩 세울 수 있었다. (개발에 대한 업무나 일을 해본적이 없기 때문에 이렇다할 철학은 아직 확고하진 않지만 나는 같은 일을 두번 하는 것을 극도로 싫어하기 때문에 한번에 깔끔하고 꼼꼼하게 하는 편이다.)\n2. 감사 인사에도 반드시 한마디를 더한다 단순한 감사합니다로 그치는 것이 아닌 정말 즐거웠습니다, 덕분에 많이 배웠습니다와 같은 말 한마디를 덧붙이면 들이는 노력에 비해 더 많은 효과를 기대할 수 있다.\n역으로 내가 저런 감사인사를 받았다고 생각을 해보니 뒤에 저런 말을 듣는다면 뭔가를 대접하거나 가르켜주기를 잘했다고 생각이들면서 다음에도 뭔가를 해주고 싶게끔 만드는 것을 느꼈다.\n3. 기승전결을 버리고 결결결 Note\n돈 못버는 사람일 수록 친절하게 말하려고 하며, 완벽주의자인 경향이 있다. 하지만 세상에 완벽한 사람은 없고 완벽하려 할 수록 무언가를 행동에 옮기기기까지 너무 많은 생각을 하기 때문에 오히려 다른 이들에게 뒤쳐질 뿐이다.\n앞서 말한 것처럼 나는 일을 꼼꼼하게 하려고 하는 경향이 있고 이것이 장점만 있는 것이 아닌 단점도 있는 것을 느끼고 있다. 책에서 말한 것처럼 행동에 옮기기까지 많은 생각을 하기 때문에 다른이들에게 뒤쳐지는 것 뿐만이 아닌 생각만하고 그칠때도 많기 때문이다.\n이런 업무처리성격이 말투에도 묻어나는 건지 여자친구도 내말을 잘 안듣는다\u0026hellip;\n이 책에는 여러 예제를 들어 어떤식으로 말하는 것이 더 마케팅에 좋은지를 보여주며 방향점을 제시하고 있어 더 도움이 됬던 것 같다.\n4. 숫자를 써서 말해라 업무적인 말을 할때 숫자는 곧 성과이며, 오해도 생기지 않기 때문에 거의 다 됐습니다., 시간이 조금 걸릴 것 같습니다. 가 아닌 80% 정도 진행되었습니다., 3일 후에 마무리될 것 같습니다와 같이 말하자.\n5. 2W1H 5W1H가 아닌 2W1H로 말하자.\n비즈니스에서는 Who는 나, When은 지금, Where은 여기인 경우가 많기 때문에 괜히 말이 길어지고 처리 속도만 늦어질 뿐이다. 앞에서 말한 것처럼 결결결이 더 깔끔하고 설득력이 있다.\n6. 양자택일로 묻자 인생에서의 중요한 선택은 모두 두 갈래이며, 물을때 대안을 제시해주는 것이 상대방이 대답은 물론 생각하기도 편해지기 때문이다. 2가지의 선택지는 상대방에게 생각의 힌트를 제공하기 때문에 2가지가 정답이 아니더라도 상대방에게 더 괜찮은 대답을 이끌어 낼 수 있다.\n"},{"section":"Blog","slug":"/blog/books/5minute-wine/","title":"5분 와인","description":"웅가가 알려주는 5분와인을 읽은 간단한 느낌","date":"2021년 4월 21일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/5minute-wine/russian-jack_hua615104e130e0ba4c72d496ead8a4dc0_31068_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"1448\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/5minute-wine\\/russian-jack_hua615104e130e0ba4c72d496ead8a4dc0_31068_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/books/5minute-wine/russian-jack_hua615104e130e0ba4c72d496ead8a4dc0_31068_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/books\\/5minute-wine\\/russian-jack_hua615104e130e0ba4c72d496ead8a4dc0_31068_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"제목에서 그대로 보이듯이 와인에 대해 깊고 많은 역사를 알려주는 책이 아닌 집에서 보관방법, 와인 구매장소, 마트에서 좋은 와인 고르기, 선물용 와인 등 과 같이 가벼운 내용위주의 책들이라 간단하게 보기 좋고 책에서 언급하는 대로 아는 체,있어보이는 척 하기에 괜찮은 책이다.\n샴페인을 한번 먹어본 이후로 화이트와인과 스파클링 와인에 빠져서 화이트와인을 만드는 포도 품종이나 지역 등을 한번 공부하고자 읽었고 책의 내용도 가벼우면서 얻고자하는 필요한 내용들은 모두 들어있었고 저자도 뭔가 고상한척 있어보이려고 하지 않고 친근한 어투로 설명해서 간단하게 훑어보기 좋은 책이다.\n이 책과는 별개로 요즘 빠진 화이트와인 하나를 추천하고 싶다.\n러시안 잭 소비뇽 블랑\r러시안 잭 소비뇽블랑 이라는 화이트 와인인데 뉴질랜드 와인으로 자몽이나 패션후르츠와 같은 향이 느껴지며 적당히 상큼해 식전에 입맛을 돋구거나 가볍게 마시기에 좋고 가격도 2만원대로 괜찮아 요즘 자주 마시고 있는 와인이다.\n"},{"section":"Blog","slug":"/blog/spring/dto/","title":"DTO에 대하여","description":"DTO는 어떤 계층에서 Entity로 반환이 이루어지는지, 변환방법에는 무엇이 있는지 정리한 글","date":"2021년 4월 15일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/spring/preview_hu740a35c095c653155a0595aa38be9f22_18108_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"200\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/spring\\/preview_hu740a35c095c653155a0595aa38be9f22_18108_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/spring/preview_hu740a35c095c653155a0595aa38be9f22_18108_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/spring\\/preview_hu740a35c095c653155a0595aa38be9f22_18108_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Spring","tags":"Dto","content":"Spring boot 공부하면서 DTO의 개념과 깔끔하게 관리하는 방법등 생각하게 되는 데 다른사람들의 의견도 듣고싶고 방법을 기록하기 위해 글을 작성한다.\n1. 변환 수행 계층 Controller Service Repository 데이터의 전달을 수행하는 Controller단이 가장 일반적이고 적합하다고 생각이 들지만, 다른사람들의 글을 보면 Service나 Repository에서 수행하는 것을 보기도 했다.수정사항이 별로 없는 기능에 대해서는 Repository에서 바로 Dto를 이용한다면 별도의 Mapping이 필요없고 간단하다는 글을 어디서 봤는데 이는 계층의 영역을 침범하는 것 같고 수정사항이 생기면 수정이 힘들것 같다.\n2. 변환 방법 1) ModelMapper와 같은 라이브러리 이용 백기선님의 Rest API강의를 보다가 처음 사용해본 라이브러리 인데 ModelMapper의 map()메서드를 통해 쉽게 맵핑할 수 있는 방법.\n간단하지만 외부 모듈을 한개 더 의존하게 된다.\n2) Entity의 Builder를 이용해 DTO값으로 생성 Entity의 파라미터를 갖는 생성자보다 더 명시적이라 괜찮은 방법이라 생각이 들지만, 코드가 길어질 수 있다.\n3) static 팩토리 메서드 이용 필드들에 따라 의미있는 메서드명이 필요할때 사용하면 괜찮다고 생각이 든다. 오히려 Builder패턴보다 맵핑하는 계층에서는 깔끔하게 보일 수 있을 것 같다.\n4) Entity 파라미터들을 갖는 생성자로 생성 기본적인 방법으로 재사용성이 좋아지고 로직이 정말 간단한 경우에는 이것이 제일 간단할 수도 있다.\n5) DTO를 파라미터로 갖는 Entity생성자 생성 맵핑을 하는 계층에서는 편하긴 하겠지만 엔티티가 DTO를 의존하게 되기때문에 별로인 것 같다.\n이외에도 복합해서 사용한다던지 방법은 많은 것 같고 정답은 없는 것 같다. 어떤 상황에서는 어떤 방법이 더 괜찮은가 계속 고민하고 나만의 철학(?), 방법을 정립해 일관되게 사용하는 것이 좋을 것 같다고 생각이 들었다.\n중요한건 중복을 피하면서 가장 간단하고 편한 방법을 상황에맞게 사용하는 것 같다.\n"},{"section":"Blog","slug":"/blog/error/intellij-down-error/","title":"Intellij 시작시 바로 꺼지는 Error","description":"`Internal error. Please refer to https://jb.gg/ide/critical-startup-errors`/`java.net.BindException: Address already in use: bind` error 해결","date":"2021년 4월 15일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Error","tags":"Intellij","content":"윈도우로 작업을 위해 IDE를 실행시켜보면 아래와 같은 에러가 발생하며 IntelliJ뿐만 아니라 Jetbrain사의 모든 IDE들이 실행이 안되는데 매번 어떻게 해결했더라 기억을 되짚고 그때마다 여러 글을 뒤져보는게 힘들어 기록을 위해 작성한다.\nInternal error. Please refer to https://jb.gg/ide/critical-startup-errors java.util.concurrent.CompletionException: java.net.BindException: Address already in use: bind at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:314) at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:319) at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1702) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:668) at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:665) at java.base/java.security.AccessController.doPrivileged(Native Method) at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1.run(Executors.java:665) at java.base/java.lang.Thread.run(Thread.java:834) Caused by: java.net.BindException: Address already in use: bind at java.base/sun.nio.ch.Net.bind0(Native Method) at java.base/sun.nio.ch.Net.bind(Net.java:455) at java.base/sun.nio.ch.Net.bind(Net.java:447) at java.base/sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:227) at io.netty.channel.socket.nio.NioServerSocketChannel.doBind(NioServerSocketChannel.java:134) at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:550) at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1334) at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:506) at io.netty.channel.AbstractChannelHandlerContext.bind(AbstractChannelHandlerContext.java:491) at io.netty.channel.DefaultChannelPipeline.bind(DefaultChannelPipeline.java:973) at io.netty.channel.AbstractChannel.bind(AbstractChannel.java:248) at io.netty.bootstrap.AbstractBootstrap$2.run(AbstractBootstrap.java:356) at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164) at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500) at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989) at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ... 1 more 원래 해결했던 방법으로는 config 파일을 삭제하고 재실행하면 됐는데 여전히 실행이 안돼서 IDE를 삭제했다가 재실행을 수행했다. 하지만 삭제했다 다시 깔아도 문제가 해결되지 않아 c://user/사용자이름/AppData/Roaming/JetBrains 안에 있는 모든 설정파일도 삭제했다가 재설치를 진행했으나 결과는 똑같았다.\n어떻게 해결해야하지 고민중에 에러메세지가 눈에 들어왔고 그 중 Address already in use: bind 라는 문구가 보여서 이를 이용해 해결했다.\n1. 문제 원인 JetBrain사의 IDE가 사용하는 포트를 Windows의 hyper-v가 점유하여 실행이 안된 것이다. 문제의 원인이었던, hyper-v를 끄고 재부팅을 하면 정상적으로 IDE가 실행되지만 WSL2를 사용하고 있어 hyper-v는 사용해야 했기에 추가작업을 실행해주었다.\n2. 해결 방법 cmd를 관리자모드로 실행\nhyper-v 비활성화 (몇 번의 다시 시작이 필요함)\ndism.exe /Online /Disable-Feature:Microsoft-Hyper-V 필요한 모든 재시작을 완료하면 원하는 포트를 예약하여 hyper-v가 다시 예약하지 않도록 하기\nnetsh int ipv4 add excludedportrange protocol=tcp startport=50051 numberofports=1 hyper-V를 다시 활성화합니다. (이과정에서도 재부팅이 발생)\ndism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All 결국 해결은 되었으나 JetBrain의 설정파일을 다날렸고 설정파일을 동기화하지 않은 나는 key-map부터 theme등 각종 설정파일을 다시 처음부터 셋팅하느라 시간을 많이 잡아먹었다.\nReference https://github.com/docker/for-win/issues/3171#issuecomment-459205576 "},{"section":"Blog","slug":"/blog/algorithms/floyd-warshall/","title":"[APSP] Floyd Warshall 알고리즘","description":"모든최단경로를 구하는 알고리즘인 Floyd Warshall알고리즘을 정리하고 직접구현해보는 글","date":"2021년 4월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"APSP, Floyd Warshall","content":"벨만-포드 알고리즘과 다익스트라 알고리즘과 달리 모든 최단 경로를 구하는 알고리즘이다. (물론 두 알고리즘도 모든 정점에대해 수행하면 모든 최단 경로를 구할 수 있다.)\n1. 특징 음의 가중치 허용 optimal substructure 개념 이용 배열을 이용하여 구현 밀집그래프에서 모든 edge간 경로 구할때 적합 2. Pesudo Code let dist be a |V| × |V| array of minimum distances initialized to ∞ let p be a |V| × |V| array of previous node initialized to null for each edge (u,v) dist[u][v] ← w(u,v) // edge (u,v)의 가중치 next[u][v] ← u // 연결된 edge는 시작값으로 초기화 for each vertex v dist[v][v] ← 0 //사이클을 허용하지 않으니 자기자신은 0 for i from 1 to |V| for j from 1 to |V| for k from 1 to |V| if (dist[i][j] \u0026gt; dist[i][k] + dist[k][j]) dist[i][j] ← dist[i][k] + dist[k][j] next[i][j] ← next[k][j] 3. 구현 방법 그래프 edge가 주어졌을때, edge들의 정보를 이용하여 각 edge간 거리 정보를 저장할 distance 2차원 행렬과 경로를 구하기 위해 이전 노드를 저장할 previous 2차원 행렬 생성 distance 행렬은 Infinity로 previous 행렬은 NIL(-1)로 초기화 그래프 G의 edge들의 가중치의 정보를 이용해 distance행렬을 초기화하고 자기의 거리는 0으로 초기화 3중 반복문을 이용하여, 현재까지 계산된 i - j까지의 경로 값보다 사이에 k를 경유하는 경로 값이 더 작다면 값을 바꾸기 4. 시간복잡도 매번 모든 노드들의 조합에 대해서 현재까지의 최단 경로를 구하고 총 |V-1| 번 반복하기 때문에 O(|V|^3) 의 시간복잡도를 갖는다.\ni-j까지의 경로 중 k를 경유하는 값이 더작다면 값을 교환하는 방식으로 k는 V-1번 이 올 수 있으며 목적지 노드인 j도 V-1번, i도 V-1번으로 총 O(|V|^3) 의 시간을 갖는다.\n5. 구현 코드 아래 코드는 사이클이없는 방향의 그래프이고, 양의 가중치를 무작위로 생성한 그래프이다.\n#include \u0026lt;time.h\u0026gt; //시간 측정 #include \u0026lt;algorithm\u0026gt; //for_each #include \u0026lt;cstdlib\u0026gt; //rand #include \u0026lt;ctime\u0026gt; //time #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #define INFINITY 214000000 #define NIL -1 #define II std::pair\u0026lt;int, int\u0026gt; // first = weight, second = dest typedef struct edge { int src; //출발 vertex int dest; //도착 vertex int weight; //가중치(비용) } edge; class Graph { private: edge e; public: Graph(int src = 0, int dest = 0, int weight = 0) { this-\u0026gt;e.src = src; this-\u0026gt;e.dest = dest; this-\u0026gt;e.weight = weight; } int getSrc() { return this-\u0026gt;e.src; } int getDest() { return this-\u0026gt;e.dest; } int getWeight() { return this-\u0026gt;e.weight; } }; void CalcTime(); void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;); // graph에 사이클 없는 연결그래프 cost값 무작위 생성 void print_edge_info(std::vector\u0026lt;Graph\u0026gt;); // graph 간선들 보기 void make_adj_matrix(std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;); //주어진 그래프를 인접행려로 표현 std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; floyd_warshall(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;); int V; // vertex 개수 clock_t start, finish, used_time = 0; //실행 시간 측정을 위한 변수 int main() { std::vector\u0026lt;Graph\u0026gt; g; // graph g std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; shortestPath; // first = cost / second = previous node std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; adjMatrix; randomPush(g); //간선 random 삽입 print_edge_info(g); // edge info print make_adj_matrix(g, adjMatrix); //주어진 그래프를 인접행렬로 만들기 start = clock(); shortestPath = floyd_warshall(adjMatrix); finish = clock(); std::cout \u0026lt;\u0026lt; \u0026#34;\\ncost : \\n\u0026#34;; for (int i = 0; i \u0026lt; V; i++) { for (int j = 0; j \u0026lt; V; j++) { if (shortestPath[i][j].first == INFINITY) std::cout \u0026lt;\u0026lt; \u0026#34;INF\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else std::cout \u0026lt;\u0026lt; shortestPath[i][j].first \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;\\npath : \\n\u0026#34;; for (int i = 0; i \u0026lt; V; i++) { for (int j = 0; j \u0026lt; V; j++) { if (shortestPath[i][j].second == NIL) std::cout \u0026lt;\u0026lt; \u0026#34;NIL\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else std::cout \u0026lt;\u0026lt; shortestPath[i][j].second \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; for (int i = 0; i \u0026lt; V; i++) { for (int j = 0; j \u0026lt; V; j++) { if (i == j) continue; std::cout \u0026lt;\u0026lt; \u0026#34;src -\u0026gt; \u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; dest : \u0026#34; \u0026lt;\u0026lt; j + 1 \u0026lt;\u0026lt; \u0026#34; path : \u0026#34;; int p = shortestPath[i][j].second; std::string str = \u0026#34;\u0026#34;; while (p != NIL) { str = std::to_string(p + 1) + \u0026#34; \u0026#34; + str; p = shortestPath[i][p].second; } std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; std::endl; } CalcTime(); return 0; } std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; floyd_warshall(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; matrix) { std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; dp(V, std::vector\u0026lt;II\u0026gt;(V, {0, 0})); for (int i = 0; i \u0026lt; V; i++) { for (int j = 0; j \u0026lt; V; j++) { dp[i][j].first = matrix[i][j]; dp[i][j].second = (dp[i][j].first != INFINITY) ? i : NIL; } } for (int i = 0; i \u0026lt; V; i++) { for (int j = 0; j \u0026lt; V; j++) { for (int k = 0; k \u0026lt; V; k++) { if (dp[i][j].first \u0026gt; dp[i][k].first + dp[k][j].first) { dp[i][j].first \u0026gt; dp[i][k].first + dp[k][j].first; dp[i][j].second = dp[k][j].second; } } } } return dp; } void make_adj_matrix(std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;adj) { adj.assign(V, std::vector\u0026lt;int\u0026gt;(V, INFINITY)); for (int i = 0; i \u0026lt; g.size(); i++) { int src = g[i].getSrc(); int dest = g[i].getDest(); int weight = g[i].getWeight(); if (adj[src][dest] \u0026gt; weight) { adj[src][dest] = weight; } } } /*vertex수 입력받은 후 그래프 간선 가중치 random 삽입*/ void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g) { std::cout \u0026lt;\u0026lt; \u0026#34;create number of Vertex : \u0026#34;; std::cin \u0026gt;\u0026gt; V; srand((unsigned int)time(NULL)); for (int i = 0; i \u0026lt; V - 1; i++) { g.push_back(Graph(i, i + 1, rand() % 1000)); for (int j = i + 1; j \u0026lt; V; j++) { g.push_back(Graph(i, j, rand() % 1000)); } } for (int i = (rand() % 3); i \u0026lt; V - 1; i += (rand() % 10)) { g.push_back(Graph(i, i + 1, rand() % 1000)); for (int j = i + 1; j \u0026lt; V; j += (rand() % 10)) { g.push_back(Graph(i, j, rand() % 1000)); } } } void print_edge_info(std::vector\u0026lt;Graph\u0026gt; g) { std::cout \u0026lt;\u0026lt; \u0026#34;edge info : \\n\u0026#34;; std::for_each(g.begin(), g.end(), [](Graph a) { std::cout \u0026lt;\u0026lt; \u0026#34;src : \u0026#34; \u0026lt;\u0026lt; a.getSrc() + 1 \u0026lt;\u0026lt; \u0026#34; desc : \u0026#34; \u0026lt;\u0026lt; a.getDest() + 1 \u0026lt;\u0026lt; \u0026#34; weight : \u0026#34; \u0026lt;\u0026lt; a.getWeight() \u0026lt;\u0026lt; std::endl; }); } //실행 시간을 측정 및 출력하는 함수 void CalcTime() { used_time = finish - start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time) / CLOCKS_PER_SEC); } "},{"section":"Blog","slug":"/blog/algorithms/prim/","title":"[MST] Prim 알고리즘","description":"Graph에서 MST를 찾는 알고리즘인 Primn알고리즘에 대해 정리하고 코드로 구현해본 글","date":"2021년 4월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"MST, Prim","content":"우선순위 큐의 방법을 이용하는 알고리즘으로 vertex를 한개씩 선택하며 최소 비용의 edge를 찾는 방법이다.\ndecrease-key의 개념을 이용하며 decrease-key는 현재 계산된 v노드까지의 거리보다 현재 노드 u부터 v까지의 경로가 더 작다면 값을 갱신해주는 방법을 이용한다.\n1. 특징 정점 선택 기반 시작 정점부터 출발하여 해당 노드까지의 최소 비용을 기록하는 배열을 이용하여 구하는 방식 자료구조중 하나인 우선순위 큐를 이용하며, 우선순위 큐를 어떻게 구현했는가가 시간복잡도에 영향 2. Pesudo Code MST-Prim(G, w, r) Q = V[G]; for each u ∈ Q key[u] = INFINITY; key[r] = 0; p[r] = NULL; while (Q not empty) u = ExtractMin(Q); for each v ∈ Adj[u] if (v ∈ Q and w(u,v) \u0026lt; key[v]) //Decrease-key p[v] = u; key[v] = w(u,v); 3. 구현 방법 vertex들의 key값을 Infinity로 초기화 start vertex의 key값을 0으로 초기화 (어떤 vertex를 선택하더라고 MST가 나온다.) 현재 vertex에 인접한 vertex들 중 선택하지 않았고, 가장 vertex의 key값이 작은 vertex을 찾기 (exract-min = 최소값 추출) 현재 vertex를 선택 인접한 vertex중 vertex의 key값보다 간선의 가중치가 더 작다면 key값을 가중치로 갱신 (decrease -key) 인접한 vertex중 선택하지 않았고, 가장 vertex의 key값이 작은 vertex를 기준으로 3번부터 다시 반복 모든 vertex가 선택되었다면 종료 1) 인접 행렬 int v = -1; //인접 vertex중 가장 작은 가중치를 갖는 vertex int min_key = INFINITY; //인접 vertex중 가장 작은 가중치 /* 인접 vertex중 가장 작은 가중치를 갖는 vertex 찾기*/ for (int j = 0; j \u0026lt; V; j++) { if (!selected[j] \u0026amp;\u0026amp; (min_key \u0026gt; vertex_key[j])) { v = j; min_key = vertex_key[j]; } } 위에 설명한 3번 방법의 extract-min을 아래와 같이 배열로 구현하며, 매번 V회 반복한다.\nfor (int j = 0; j \u0026lt; V; j++) { if (vertex_key[j] \u0026gt; adjMatrix[v][j]) { vertex_key[j] = adjMatrix[v][j]; } } 5번 방법으로 인접한 vertex중 vertex의 key값보다 간선의 가중치가 더 작다면 key값을 가중치로 갱신 한다.\n2) 인접 리스트 std::set\u0026lt;II\u0026gt; q; //이진힙으로 queue 만들기 ( set은 red-black tree로 만들어짐 ) auto u = q.begin(); // extract-min 인접 리스트는 인접한 vertex의 가중치를 priority queue를 통해 저장하기때문에 3번 방법의 exract-min은 맨앞에서 pop을 시켜 찾아주면 된다.\n/*select한 vertex와 인접한 간선인 e*/ for (auto e : adjList[현재 vertex]) { /* 선택되지 않은 vertex이고 해당 vertex의 key값과 edge의 cost를 비교해 cost가 더 작다면*/ if (!selected[인접한 vertex] \u0026amp;\u0026amp; vertex_key[인접한 vertex] \u0026gt; 가중치) { q.erase({vertex_key[인접한 vertex], e.second}); //같은 vertex로 향하는 간선중 weight가 더 작은 간선이 있다면 그 전 간선은 삭제 vertex_key[인접한 vertex] = 가중치; // vertex key값 갱신 q.insert({가중치, 인접한 vertex}); //큐에 삽입 } } 5번 방법으로 인접한 vertex중 vertex의 key값보다 간선의 가중치가 더 작다면 key값을 가중치로 갱신 하는 방법은 아래와 같이 인접한 간선의 개수만큼 수행한다.\n4. 시간 복잡도 시간복잡도는 초기화하는데 O(|V|), MST계산하는데 O(|V|) * T(extract-min) (가장 적은 값 추출하는데 걸린시간) + O(|E|) * T(decrease-key) ( key값 변경하는데 걸리는 시간 )이기 때문에 priority-queue를 어떻게 구현했는지에 따라 시간복잡도가 달라진다.\n일반 배열로 구현했을 경우 T(extract)가 O(|V|), T(decrease)는 O(1) 만큼 걸려 총 O(|V^2|) 이 걸린다.\nbinary heap(이진 힙)으로 구현하면 T(extract)가 O(lgV), T(decrease)는 O(lgV) 만큼 걸려 총 O(VlgV) + O(ElgV) 이기 때문에 O((E+V)lgV) 만큼 걸린고 무방향 그래프일때 E의 최소값은 V-1로 거의 대부분이 |E| \u0026gt; |V| 이므로 O(|E|lg|V|) 라고 할 수 있다.\nfibonacci heap으로 구현하면 decrease-key의 시간을 좀더 줄일 수 있는데 decrease-key시간이 O(1)만큼 걸리기 때문에 O(E+VlgV) 라고 할 수 있다. O(E) or O(VlgV) 인 이유는 최악의 경우에 E는 O(V^2)이기 때문이다.\n5. 구현 코드 아래 코드는 사이클이없는 무방향의 그래프이고, 가중치를 무작위로 생성한 그래프이다.\n#include \u0026lt;time.h\u0026gt; //시간 측정 #include \u0026lt;algorithm\u0026gt; //for_each #include \u0026lt;cstdlib\u0026gt; //rand #include \u0026lt;ctime\u0026gt; //time #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #define INFINITY 2147483647 #define II std::pair\u0026lt;int, int\u0026gt; // first = weight, second = dest typedef struct edge { int src; //출발 vertex int dest; //도착 vertex int weight; //가중치(비용) } edge; class Graph { private: edge e; public: Graph(int src = 0, int dest = 0, int weight = 0) { this-\u0026gt;e.src = src; this-\u0026gt;e.dest = dest; this-\u0026gt;e.weight = weight; } int getSrc() { return this-\u0026gt;e.src; } int getDest() { return this-\u0026gt;e.dest; } int getWeight() { return this-\u0026gt;e.weight; } }; void CalcTime(); void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;); // graph에 사이클 없는 연결그래프 cost값 무작위 생성 void print_edge_info(std::vector\u0026lt;Graph\u0026gt;); // graph 간선들 보기 int prim_adjList_heap(std::vector\u0026lt;Graph\u0026gt; \u0026amp;, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt;, int); // Adj list와 priority queue 이용해 구현 --\u0026gt; set은 red-black-tree void make_adj_list(std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; \u0026amp;); //주어진 그래프를 인접리스트로 표현 int prim_adjMatrix(std::vector\u0026lt;Graph\u0026gt; \u0026amp;, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;, int); // Adj matrix로 구현 void make_adj_matrix(std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;); //주어진 그래프를 인접행렬로 표현 int V; // vertex 개수 clock_t start, finish, used_time = 0; //실행 시간 측정을 위한 변수 int main() { std::vector\u0026lt;Graph\u0026gt; g; // graph g int minimum_weight = 0; // minimum cost std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; adjList; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; adjMatrix; randomPush(g); //간선 random 삽입 print_edge_info(g); // edge info print make_adj_list(g, adjList); //주어진 그래프를 인접리스트로 만들기 make_adj_matrix(g, adjMatrix); //주어진 그래프를 인접행렬로 만들기 start = clock(); minimum_weight = prim_adjMatrix(g, adjMatrix, 0); //인접행렬을 이용한 prim\u0026#39;s algorithm (0번노드를 첫 노드로 시작) // minimum_weight = prim_adjList_heap(g, adjList, 0); //인접리스트를 이용한 prim\u0026#39;s algorithm (0번노드를 첫 노드로 시작) finish = clock(); std::cout \u0026lt;\u0026lt; \u0026#34;\\nminimum cost : \u0026#34; \u0026lt;\u0026lt; minimum_weight \u0026lt;\u0026lt; std::endl; CalcTime(); return 0; } int prim_adjList_heap(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; adjList, int start) { int sum = 0; std::set\u0026lt;II\u0026gt; q; //이진힙으로 queue 만들기 ( set은 red-black tree로 만들어짐 ) std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 std::vector\u0026lt;bool\u0026gt; selected(g.size(), false); //선택된 vertex인가 vertex_key[start] = 0; q.insert(II(0, start)); //시작 노드 가중치 0으로 시작 std::cout \u0026lt;\u0026lt; \u0026#34;\\nroute\u0026#34;; /*vertex 수만큼 반복한다 while대신 for(int i=0; i \u0026lt; V ; i++)로 해도 무방 */ while (!q.empty()) { /*extract min*/ int select_key = q.begin()-\u0026gt;second; int min_of_key = q.begin()-\u0026gt;first; q.erase(q.begin()); if (selected[select_key]) { std::cout \u0026lt;\u0026lt; \u0026#34; NOT MST\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } sum += min_of_key; selected[select_key] = true; std::cout \u0026lt;\u0026lt; \u0026#34;dest : \u0026#34; \u0026lt;\u0026lt; select_key \u0026lt;\u0026lt; \u0026#34; (dis : \u0026#34; \u0026lt;\u0026lt; vertex_key[select_key] \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; /*decrease key*/ for (auto e : adjList[select_key]) { if (!selected[e.second] \u0026amp;\u0026amp; vertex_key[e.second] \u0026gt; e.first + vertex_key[select_key]) { q.erase({vertex_key[e.second], e.second}); //같은 노드로 향하는 간선중 weight가 더 작은 간선이 있다면 그 전 간선은 삭제 q.insert({e.first, e.second}); //큐에 삽입 vertex_key[e.second] = e.first + vertex_key[select_key]; } } } std::cout \u0026lt;\u0026lt; std::endl; return sum; } void make_adj_list(std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; \u0026amp;adj) { adj.resize(V); bool isEdge; for (int i = 0; i \u0026lt; g.size(); i++) { isEdge = false; int src = g[i].getSrc(); int dest = g[i].getDest(); int weight = g[i].getWeight(); /*동일 vertex로 향하는 간선중 가장 작은 값만가지고 인접 리스트를 만들기 위한 코드*/ if (adj[src].empty()) { adj[src].push_back({weight, dest}); } else { for (int j = 0; j \u0026lt; adj[src].size(); j++) { if (adj[src][j].second == dest) { isEdge = true; if (adj[src][j].first \u0026gt; weight) { adj[src][j].first = weight; } } } if (!isEdge) adj[src].push_back({weight, dest}); } isEdge = false; if (adj[dest].empty()) { adj[dest].push_back({weight, src}); } else { for (int j = 0; j \u0026lt; adj[dest].size(); j++) { if (adj[dest][j].second == src) { isEdge = true; if (adj[dest][j].first \u0026gt; weight) { adj[dest][j].first = weight; } } } if (!isEdge) adj[dest].push_back({weight, src}); } } } int prim_adjMatrix(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; adjMatrix, int start) { int sum = 0; std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 std::vector\u0026lt;bool\u0026gt; selected(g.size(), false); //선택된 vertex인가 vertex_key[start] = 0; //시작노드 key값 0으로 시작 std::cout \u0026lt;\u0026lt; \u0026#34;\\nroute\u0026#34;; /*vertex 수만큼 반복한다*/ for (int i = 0; i \u0026lt; V; i++) { int select_idx = -1; //인접 vertex중 가장 작은 가중치를 갖는 vertex int min_key = INFINITY; //인접 vertex중 가장 작은 가중치 /* 인접 vertex중 가장 작은 가중치를 갖는 vertex 찾기*/ for (int j = 0; j \u0026lt; V; j++) { if (!selected[j] \u0026amp;\u0026amp; (min_key \u0026gt; vertex_key[j])) { select_idx = j; min_key = vertex_key[j]; } } /*현재 코드에서는 연결안된 그래프는 주어지지 않기 때문에 없어도 무방하지만 만약을 위한 에러처리*/ if (select_idx == -1) { std::cout \u0026lt;\u0026lt; \u0026#34;Not MST\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } selected[select_idx] = true; sum += min_key; std::cout \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34; \u0026lt;\u0026lt; select_idx \u0026lt;\u0026lt; \u0026#34;(cost : \u0026#34; \u0026lt;\u0026lt; min_key \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; /*인접 vertex의 weight가 vertex_key값보다 작다면 key값 갱신 */ for (int j = 0; j \u0026lt; V; j++) { if (!selected[j] \u0026amp;\u0026amp; vertex_key[j] \u0026gt; adjMatrix[select_idx][j]) { vertex_key[j] = adjMatrix[select_idx][j]; } } } std::cout \u0026lt;\u0026lt; std::endl; return sum; } void make_adj_matrix(std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;adj) { adj.assign(V, std::vector\u0026lt;int\u0026gt;(V, INFINITY)); for (int i = 0; i \u0026lt; g.size(); i++) { int src = g[i].getSrc(); int dest = g[i].getDest(); int weight = g[i].getWeight(); if (adj[src][dest] \u0026gt; weight) { adj[src][dest] = weight; } if (adj[dest][src] \u0026gt; weight) { adj[dest][src] = weight; } } } /*vertex수 입력받은 후 그래프 간선 가중치 random 삽입*/ void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g) { std::cout \u0026lt;\u0026lt; \u0026#34;create number of Vertex : \u0026#34;; std::cin \u0026gt;\u0026gt; V; srand((unsigned int)time(NULL)); for (int i = 0; i \u0026lt; V - 1; i++) { g.push_back(Graph(i, i + 1, rand() % 1000)); for (int j = i + 1; j \u0026lt; V; j++) { g.push_back(Graph(i, j, rand() % 1000)); } } for (int i = (rand() % 3); i \u0026lt; V - 1; i += (rand() % 10)) { g.push_back(Graph(i, i + 1, rand() % 1000)); for (int j = i + 1; j \u0026lt; V; j += (rand() % 10)) { g.push_back(Graph(i, j, rand() % 1000)); } } } void print_edge_info(std::vector\u0026lt;Graph\u0026gt; g) { std::cout \u0026lt;\u0026lt; \u0026#34;edge info : \\n\u0026#34;; std::for_each(g.begin(), g.end(), [](Graph a) { std::cout \u0026lt;\u0026lt; \u0026#34;src : \u0026#34; \u0026lt;\u0026lt; a.getSrc() \u0026lt;\u0026lt; \u0026#34; desc : \u0026#34; \u0026lt;\u0026lt; a.getDest() \u0026lt;\u0026lt; \u0026#34; weight : \u0026#34; \u0026lt;\u0026lt; a.getWeight() \u0026lt;\u0026lt; std::endl; }); } //실행 시간을 측정 및 출력하는 함수 void CalcTime() { used_time = finish - start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time) / CLOCKS_PER_SEC); } "},{"section":"Blog","slug":"/blog/algorithms/union-find/","title":"[Disjoint Set] Union Find 알고리즘","description":"서로소 집합을 구하는 알고리즘으로 Union Find알고리즘을 정리합니다.","date":"2021년 4월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"Disjoint Set, Union Find","content":"1. Disjoint Set 번역하면 서로소 집합으로 서로 중복 되지 않는 부분 집합들로 이루어진 집합(set)으로 교집합이 존재 하지 않는 부분집합들로 이루어진 집합이다.\n2. Union-Find Union : 두개의 집합을 하나의 집합으로 합치는 것. Find : 어떤 원소가 주어졌을 때 이 원소가 속한 집합을 반환하는(찾는) 것. 집합들을 tree구조로 나타내어 해당원소가 어떤 집합에 속하는지 판단할때 각 집합의 대표값(root)을 이용해서 집합이 같은지를 비교.\n3. 구현 방법 1) 연결리스트 typedef struct node{ int data; struct node* parent; struct node* next; }node; void MakeSet(node* p,int x){ p-\u0026gt;data = x; p-\u0026gt;parent = p;//처음은 다 원소가 하나씩있는 집합이므로 자기 자신이 root p-\u0026gt;next=null; } void Find(node* p,int x){ if(p-\u0026gt;parent-\u0026gt;data == x) return x; //root값이 자기 자신이라면 집합의 대표값 else return Find(p-\u0026gt;parent,x); //재귀적으로 집합 대표값 찾기 } void Union(node* p1,node* p2,int x,int y){ x = Find(p1,x); y = Find(p2,y); p1-\u0026gt;next = p2; p2-\u0026gt;parent = p1; } 2) Disjoint Set Forest ( Tree ) int root[n]; void MakeSet(int x){ root[x] = x; //처음은 다 원소가 하나씩있는 집합이므로 자기 자신이 root } void Find(int x){ if(root[x] == x) return x; //root값이 자기 자신이라면 집합의 대표값 else return Find(root[x]); //재귀적으로 집합 대표값 찾기 } void Union(int x,int y){ x = Find(x); y = Find(y); root[y] = x; } 4. 시간 복잡도 연결리스트로 구현시 O(nlgn) 의 시간을 갖으며 Tree로 구현해도 불균형한 트리 (예 : skewd tree)와 같게 되면 연결리스트와 다를 것이 없어진다.\n5. 문제점 find시에 재귀적으로 찾기 때문에 만약에 set의 tree구조가 선형적인 형태라고 한다면 최악의 경우로 O(n)만큼의 시간이 소요 되게 된다.\n➡ path compression (경로 압축) 기법 사용\n또한, union시에 깊이가 작은 트리에 깊이가 깊은 트리를 붙이게 되면 깊이가 더 증가하여 시간에 악영향을 준다.\n➡ union by rank 기법 사용\n6. path compression (경로 압축) find 연산 수행시마다 트리의 구조를 평평하게 만드는 방법으로 각 root값을 재귀적으로 가리키는 것이 아닌 해당 집합의 속하는 원소는 모두 동일한 root를 가리키게 만드는 방법이다.\nvoid Find(int x){ /*find수행마다 해당 parent값을 root로 초기화*/ if(root[x] != x) root[x] = Find(root[x]); else return root[x]; } 7. union by rank 항상 깊이가 깊은 트리에 작은 트리를 붙여 깊이를 유지하는 방법으로 깊이가 서로 같은 트리라면, 깊이를 1증가 시키게 된다.\nint root[n]; int rank[n]; void MakeSet(int x){ root[x] = x; //처음은 다 원소가 하나씩있는 집합이므로 자기 자신이 root rank[x] = 0; //깊이도 0으로 초기화 } void Union(int x,int y){ x = Find(x); //입력받은 x값의 root값을 저장 y = Find(y); //입력받은 y값의 root값을 저장 if(x==y) return; //root가 같다면 같은 집합 if(rank[x] \u0026lt; rank[y]) root[x] = y; //x의 root를 y로 변경 else if(rank[x] \u0026gt; rank[y]) root[y]= x; //y의 root를 x로 변경 else{ root[y] = x; rank[x]++; //깊이가 같다면 x에 y를 붙였으므로 x깊이 증가 } 8. 두 기법을 적용 후 시간 복잡도 O(lgn)\n9. 활용 Disjoint Set 자료구조는 집합의 분할을 모델링 하기 때문에 무방향 그래프(undirected graph) 의 연결된 요소들을 추적 할 수 있어, 사이클이 발생하는지 또는 같은 요소에 속하는지 확인 할 수 있고 대표적으로 MST를 찾는 Kruskal 알고리즘에 이용된다.\n"},{"section":"Blog","slug":"/blog/algorithms/kruskal/","title":"[MST] Kruskal 알고리즘","description":"Graph에서 MST를 찾는 알고리즘인 Kruskal알고리즘에 대해 정리하고 코드로 구현해본 글","date":"2021년 4월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"MST, Kruskal","content":"그래프 중에서 MST (Minumum Spannig Tree) 를 찾는 알고리즘중에 하나로 Union-Find알고리즘을 이용하며, 간선 (edge)의 가중치(weight)를 오름차순으로 정렬하여 가중치가 사이클이 생기지 않는 낮은 간선을 먼저 선택하는 방법이다.\n사이클의 여부를 확인할때 union-find 알고리즘을 이용하여 찾는 알고리즘이다.\nunion find 알고리즘 설명 보기 1. 특징 탐욕적인 방법 (Greedy) 간선 선택 기반 알고리즘 간선 선택 단계에서 사이클을 포함하지 않고 최소 비용 간선을 선택 부분 트리집합을 병합하면서 하나의 트리로 확장 희소그래프에 적합 ( V \u0026gt; E ) 정렬 속도가 시간복잡도에 영향 2. Pesudo Code algorithm Kruskal(G) is T := ∅ for each v ∈ G.V do MAKE-SET(v) for each (u, v) in G.E ordered by weight(u, v), increasing do if FIND-SET(u) ≠ FIND-SET(v) then T := T ∪ {(u, v)} UNION(FIND-SET(u), FIND-SET(v)) return T 3. 구현 Note\n그래프의 edge(간선)의 가중치(비용)을 작은것 부터 큰 순서대로(오름차순)으로 정렬\n모든 간선에 대해 해당 간선의 두 vertex(정점)가 같은 집합에 속하는지 검사(Find)\n두 vertex(정점)의 부분집합들이 서로 다르다면, 합치기(union)\n두 vertex(정점)의 부분집합이 같은 집합이라면, 사이클이 생성되기 때문에 패스\n총 선택한 edge(간선)의 비용을 계산\n기본적으로 사이클이 생성되는지 검사하기 위해 union-find알고리즘이 쓰이며, kruskal 알고리즘의 시간복잡도는 edge를 정렬하는 속도와 밀접한 연관이 있다.\n4. 시간복잡도 make_set 하는데 O(V), 정렬하는데 걸리는 시간은 T (간선 E를 가지고 정렬 =\u0026gt; O(E), O(1), O(ElgE), O(E^2) 등등), Union하기 위해 집합이 속하는지 검사하는 Find가 O(E) 번 일어나며, Find 에 O(lgV) 번 일어난다. 따라서, Union을 끝내는데 O(ElgV) 만큼 걸린다.\n총 O(ElgV + T) 의 시간복잡도를 갖는다.\n5. 구현 코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; //sort #include \u0026lt;vector\u0026gt; //vector #include \u0026lt;cstdlib\u0026gt; //rand #include \u0026lt;ctime\u0026gt; //time typedef struct edge { int src; //출발 vertex int dest; //도착 vertex int weight; //가중치(비용) } edge; class Edge { private: edge e; public: Edge(int src = 0, int dest = 0, int weight = 0) { this-\u0026gt;e.src = src; this-\u0026gt;e.dest = dest; this-\u0026gt;e.weight = weight; } int getSrc() { return this-\u0026gt;e.src; } int getDest() { return this-\u0026gt;e.dest; } int getWeight() { return this-\u0026gt;e.weight; } bool operator\u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;e.weight \u0026lt; edge.e.weight; } }; int Kruskal(std::vector\u0026lt;Edge\u0026gt; \u0026amp;); int Find(std::vector\u0026lt;int\u0026gt; \u0026amp;, int); bool Union(std::vector\u0026lt;int\u0026gt; \u0026amp;, std::vector\u0026lt;int\u0026gt; \u0026amp;, int, int); void randomPush(std::vector\u0026lt;Edge\u0026gt; \u0026amp;); //graph에 사이클 없는 연결그래프 무작위 생성 int V; int main() { std::vector\u0026lt;Edge\u0026gt; g; //graph g int minimum_weight = 0; //minimum cost randomPush(g); //간선 random 삽입 /*edge info print*/ std::cout \u0026lt;\u0026lt; \u0026#34;edge info : \\n\u0026#34;; std::for_each(g.begin(), g.end(), [](Edge a) { std::cout \u0026lt;\u0026lt; \u0026#34;src : \u0026#34; \u0026lt;\u0026lt; a.getSrc() \u0026lt;\u0026lt; \u0026#34; desc : \u0026#34; \u0026lt;\u0026lt; a.getDest() \u0026lt;\u0026lt; \u0026#34; weight : \u0026#34; \u0026lt;\u0026lt; a.getWeight() \u0026lt;\u0026lt; std::endl; }); minimum_weight = Kruskal(g); //kruskal algorithm std::cout \u0026lt;\u0026lt; \u0026#34;minimum cost : \u0026#34; \u0026lt;\u0026lt; minimum_weight \u0026lt;\u0026lt; std::endl; //minimum cost print return 0; } int Kruskal(std::vector\u0026lt;Edge\u0026gt; \u0026amp;g) { int sum = 0; /*set, rank 초기화 == \u0026gt; make_set */ std::vector\u0026lt;int\u0026gt; set(V); std::vector\u0026lt;int\u0026gt; rank(V, 0); for (int i = 0; i \u0026lt; V; i++) { set[i] = i; } sort(g.begin(), g.end()); //오름차순으로 정렬 /*minumum edge 선택*/ std::cout \u0026lt;\u0026lt; \u0026#34;\\nselected edge : \\n\u0026#34;; for (int i = 0; i \u0026lt; g.size(); i++) { if (Union(set, rank, g[i].getSrc(), g[i].getDest())) { std::cout \u0026lt;\u0026lt; \u0026#34;edge : \u0026#34; \u0026lt;\u0026lt; g[i].getSrc() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; g[i].getDest() \u0026lt;\u0026lt; \u0026#34; weight : \u0026#34; \u0026lt;\u0026lt; g[i].getWeight() \u0026lt;\u0026lt; std::endl; sum += g[i].getWeight(); } } return sum; } int Find(std::vector\u0026lt;int\u0026gt; \u0026amp;set, int x) { if (set[x] == x) return x; return set[x] = Find(set, set[x]); } bool Union(std::vector\u0026lt;int\u0026gt; \u0026amp;set, std::vector\u0026lt;int\u0026gt; \u0026amp;rank, int x, int y) { x = Find(set, x); y = Find(set, y); if (x == y) return false; /*집합에 안속해있다면 union*/ if (rank[x] \u0026lt; rank[y]) set[x] = y; else if (rank[x] \u0026gt; rank[y]) set[y] = x; else { set[y] = x; rank[x]++; } return true; } /*vertex수 입력받은 후 그래프 간선 가중치 random 삽입*/ void randomPush(std::vector\u0026lt;Edge\u0026gt; \u0026amp;g) { std::cout \u0026lt;\u0026lt; \u0026#34;create number of Vertex : \u0026#34;; std::cin \u0026gt;\u0026gt; V; srand((unsigned int)time(NULL)); for (int i = 0; i \u0026lt; V - 1; i++) { g.push_back(Edge(i, i + 1, rand() % 100)); for (int j = i + 1; j \u0026lt; V; j += (rand() % 4)) { g.push_back(Edge(i, j, rand() % 100)); } } for (int i = V - 1; i \u0026gt; 0; i--) { g.push_back(Edge(i, i - 1, rand() % 100)); for (int j = i - 1; j \u0026gt; 0; j -= (rand() % 4)) { g.push_back(Edge(i, j, rand() % 100)); } } } "},{"section":"Blog","slug":"/blog/algorithms/dijkstra/","title":"[SPSP] Dijkstra 알고리즘","description":"단일 최단경로를 구하는 알고리즘인 Dijkstra알고리즘에 대해 정리하고 직접 구현해보는 글","date":"2021년 4월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"SPSP, Dijkstra","content":"그래프 중에서 최단 경로를 찾는 알고리즘중에 하나로 하나의 정점에서 다른 모든 정점까지의 최단경로를 구하는 알고리즘 (single-source shortest path algorithmm)으로 우선순위 큐의 방법을 이용하는 알고리즘이다.\n가장 최적의 vertex를 한개씩 선택하며 최단 경로를 찾는 방법으로 relax의 개념을 이용하며 relax는 현재 계산된 v노드까지의 거리보다 현재 노드 u까지의 경로와 u에서 v의 가중치 ( e(u,v) ) 가 더 작다면 값을 갱신해준다.\n이때, relax는 prim 알고리즘의 decrease-key와 유사하며 dp를 추가한 개념이다.\n1. 특징 음의 가중치 허용 x 시작 정점부터 출발하여 최소 비용의 간선을 갖는 정점을 선택하여 신장 트리 집합을 단계적으로 확장 밀집 그래프에 적합 자료구조중 하나인 우선순위 큐를 이용하며, 우선순위 큐를 어떻게 구현했는가가 시간복잡도에 영향 2. Pesudo Code Dijkstra(G, w , s){ INITIALIZE-SINGLE-SOURCE(G, s) S \u0026lt;- ∅ Q \u0026lt;- V[G] while Q != ∅ do u \u0026lt;- EXTRACT-MIN(∅) s \u0026lt;- S ∪ {u} for each vertex v ∈ Adj[u] do RELAX(u, v, w) } RELAX(u,v,w) if v.d \u0026gt; u.d + w(u,v) v.d = u.d + w(u,v) v.π = u 3. 구현 방법 Prim\u0026rsquo;s 알고리즘에서 decrease key 부분을 dp를 이용한다는 것 빼고 다른 것이 없다.\nvertex들의 key값을 Infinity로 초기화 start vertex의 key값을 0으로 초기화 (어떤 vertex를 선택하더라고 MST가 나온다.) 현재 vertex에 인접한 vertex들 중 선택하지 않았고, 가장 vertex의 key값이 작은 vertex을 찾기 (exract-min = 최소값 추출) 현재 vertex를 선택 인접한 vertex중 vertex의 key값보다 간선의 가중치와 현재까지의 거리의 합이 더 작다면 key값을 가중치와 현재까지의 거리의 합으로 갱신 (RELAX) 인접한 vertex중 선택하지 않았고, 가장 vertex의 key값이 작은 vertex를 기준으로 3번부터 다시 반복 모든 vertex가 선택되었다면 종료 1) 인접 행렬 위에 설명한 3번 방법의 extract-min을 아래와 같이 배열로 구현하며, 매번 V회 반복한다.\nint v = -1; //인접 vertex중 가장 작은 가중치를 갖는 vertex int min_key = INFINITY; //인접 vertex중 가장 작은 가중치 /* 인접 vertex중 가장 작은 가중치를 갖는 vertex 찾기*/ for (int j = 0; j \u0026lt; V; j++) { if (min_key \u0026gt; vertex_key[j]) { v = j; min_key = vertex_key[j]; } } 아래는 5번 방법으로 인접한 vertex중 vertex의 key값보다 간선의 가중치와 현재까지의 거리의 합이 더 작다면 key값을 가중치와 현재까지의 거리의 합으로 갱신 한다..\n잘 보면 알겠지만 Prim 알고리즘과 비교해서 vertex_key[selct_idx] 추가 됐다.\nfor (int j = 0; j \u0026lt; V; j++) { if ( vertex_key[j] \u0026gt; adjMatrix[select_idx][j] + vertex_key[select_idx]) { vertex_key[j] = adjMatrix[select_idx][j] + vertex_key[select_idx]; } } 2) 인접 리스트 인접 리스트는 인접한 vertex의 가중치를 priority queue를 통해 저장한다.\n때문에, 3번 방법의 exract-min은 맨앞에서 pop을 시켜 찾아주면 된다.\nint select_key = q.begin()-\u0026gt;second; int min_of_key = q.begin()-\u0026gt;first; q.erase(q.begin()); /*select한 vertex와 인접한 간선인 e*/ for (auto e : adjList[select_key]) { if ( vertex_key[e.second] \u0026gt; e.first + vertex_key[select_key]) { q.erase({vertex_key[e.second], e.second}); //같은 노드로 향하는 간선중 weight가 더 작은 간선이 있다면 그 전 간선은 삭제 q.insert({e.first, e.second}); //큐에 삽입 vertex_key[e.second] = e.first + vertex_key[select_key]; } } 5번 방법으로 인접한 vertex중 vertex의 key값보다 간선의 가중치와 현재 정점까지의 거리의 합이 더 작다면 key값을 가중치와 현재 정점까지의 거리의 합으로 갱신 하는 방법은 아래와 같이 인접한 간선의 개수만큼 수행한다.\n4. 시간 복잡도 Prim 알고리즘과 거의 동일하기 때문에 시간복잡도도 동일하다.\n시간복잡도는 초기화하는데 O(|V|), MST계산하는데 O(|V|) * T(extract-min) (가장 적은 값 추출하는데 걸린시간) + O(|E|) * T(RELAX) ( key값 변경하는데 걸리는 시간 )와 같기 때문에 priority-queue를 어떻게 구현했는지에 따라 시간복잡도가 달라진다.\n일반 배열로 구현했을 경우 T(extract)가 O(|V|), T(RELAX)는 O(1) 만큼 걸려 총 O(|V^2|) 이 걸린다.\nbinary heap(이진 힙)으로 구현하면 T(extract)가 O(lgV), T(RELAX)는 O(lgV) 만큼 걸려 총 O(VlgV) + O(ElgV) 이기 때문에 O((E+V)lgV) 만큼 걸린다. 무방향 그래프일때 E의 최소값은 V-1로 거의 대부분이 |E| \u0026gt; |V| 이므로 O(|E|lg|V|) 라고 할 수 있다.\npriority queue를 이진 힙이 아닌 fibonacci heap으로 구현하면 RELAX의 시간을 좀더 줄일 수 있는데 RELAX시간이 O(1) 만큼 걸리기 때문에 O(E+VlgV) 라고 할 수 있다. O(E) or O(VlgV) 인 이유는 최악의 경우에 E는 O(V^2)이기 때문이다.\n구현 코드 아래 코드는 사이클이없는 무방향의 그래프이고, 가중치를 무작위로 생성한 그래프이다.\n#include \u0026lt;time.h\u0026gt; //시간 측정 #include \u0026lt;algorithm\u0026gt; //for_each #include \u0026lt;cstdlib\u0026gt; //rand #include \u0026lt;ctime\u0026gt; //time #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;vector\u0026gt; #define INFINITY 2147483647 #define II std::pair\u0026lt;int, int\u0026gt; // first = weight, second = dest typedef struct edge { int src; //출발 vertex int dest; //도착 vertex int weight; //가중치(비용) } edge; class Graph { private: edge e; public: Graph(int src = 0, int dest = 0, int weight = 0) { this-\u0026gt;e.src = src; this-\u0026gt;e.dest = dest; this-\u0026gt;e.weight = weight; } int getSrc() { return this-\u0026gt;e.src; } int getDest() { return this-\u0026gt;e.dest; } int getWeight() { return this-\u0026gt;e.weight; } }; void CalcTime(); void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;); // graph에 사이클 없는 연결그래프 cost값 무작위 생성 void print_edge_info(std::vector\u0026lt;Graph\u0026gt;); // graph 간선들 보기 void make_adj_list(std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; \u0026amp;); //주어진 그래프를 인접리스트로 표현 void make_adj_matrix(std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;); //주어진 그래프를 인접행려로 표현 int dijkstra_heap(std::vector\u0026lt;Graph\u0026gt; \u0026amp;, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt;, int); int dijkstra_array(std::vector\u0026lt;Graph\u0026gt; \u0026amp;, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;, int); int V; // vertex 개수 clock_t start, finish, used_time = 0; //실행 시간 측정을 위한 변수 int main() { std::vector\u0026lt;Graph\u0026gt; g; // graph g int minimum_weight = 0; // minimum cost std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; adjMatrix; std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; adjList; randomPush(g); //간선 random 삽입 // 10print_edge_info(g); // edge info print make_adj_matrix(g, adjMatrix); //주어진 그래프를 인접행렬로 만들기 make_adj_list(g, adjList); //주어진 그래프를 인접리스트로 만들기 start = clock(); // minimum_weight = dijkstra_heap(g, adjList, 0); //binary heap을 이용한 구현 minimum_weight = dijkstra_array(g, adjMatrix, 0); // array 이용한 구현 finish = clock(); std::cout \u0026lt;\u0026lt; \u0026#34;\\nall route dis : \u0026#34; \u0026lt;\u0026lt; minimum_weight \u0026lt;\u0026lt; std::endl; CalcTime(); return 0; } int dijkstra_heap(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; adjList, int start) { int sum = 0; std::set\u0026lt;II\u0026gt; q; //이진힙으로 queue 만들기 ( set은 red-black tree로 만들어짐 ) std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 vertex_key[start] = 0; q.insert(II(0, start)); //시작 노드 가중치 0으로 시작 std::cout \u0026lt;\u0026lt; \u0026#34;\\nstart : 0\\n\u0026#34;; /*Vertex만큼 반복*/ while (!q.empty()) { /*extract min*/ int select_key = q.begin()-\u0026gt;second; int min_of_key = q.begin()-\u0026gt;first; q.erase(q.begin()); sum += min_of_key; std::cout \u0026lt;\u0026lt; \u0026#34;dest : \u0026#34; \u0026lt;\u0026lt; select_key \u0026lt;\u0026lt; \u0026#34; (dis : \u0026#34; \u0026lt;\u0026lt; vertex_key[select_key] \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; /*decrease key*/ for (auto e : adjList[select_key]) { if ( vertex_key[e.second] \u0026gt; e.first + vertex_key[select_key]) { q.erase({vertex_key[e.second], e.second}); //같은 노드로 향하는 간선중 weight가 더 작은 간선이 있다면 그 전 간선은 삭제 q.insert({e.first, e.second}); //큐에 삽입 vertex_key[e.second] = e.first + vertex_key[select_key]; } } } std::cout \u0026lt;\u0026lt; std::endl; return sum; } int dijkstra_array(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; adjMatrix, int start) { int sum = 0; std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 vertex_key[start] = 0; std::cout \u0026lt;\u0026lt; \u0026#34;\\nstart : 0\\n\u0026#34;; /*Vertex만큼 반복*/ for (int i = 0; i \u0026lt; V; i++) { /*extract min*/ int select_idx = -1, min_of_key = INFINITY; for (int j = 0; j \u0026lt; V; j++) { if (min_of_key \u0026gt; vertex_key[j]) { min_of_key = vertex_key[j]; } } sum += min_of_key; std::cout \u0026lt;\u0026lt; \u0026#34;dest : \u0026#34; \u0026lt;\u0026lt; select_idx \u0026lt;\u0026lt; \u0026#34; (dis : \u0026#34; \u0026lt;\u0026lt; vertex_key[select_idx] \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; /*decrease key*/ for (int j = 0; j \u0026lt; V; j++) { if ( vertex_key[j] \u0026gt; adjMatrix[select_idx][j] + vertex_key[select_idx]) { vertex_key[j] = adjMatrix[select_idx][j] + vertex_key[select_idx]; } } } std::cout \u0026lt;\u0026lt; std::endl; return sum; } void make_adj_list(std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; \u0026amp;adj) { adj.resize(V); bool isEdge; for (int i = 0; i \u0026lt; g.size(); i++) { isEdge = false; int src = g[i].getSrc(); int dest = g[i].getDest(); int weight = g[i].getWeight(); /*동일 vertex로 향하는 간선중 가장 작은 값만가지고 인접 리스트를 만들기 위한 코드*/ if (adj[src].empty()) { adj[src].push_back({weight, dest}); } else { for (int j = 0; j \u0026lt; adj[src].size(); j++) { if (adj[src][j].second == dest) { isEdge = true; if (adj[src][j].first \u0026gt; weight) { adj[src][j].first = weight; } } } if (!isEdge) adj[src].push_back({weight, dest}); } } } void make_adj_matrix(std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;adj) { adj.assign(V, std::vector\u0026lt;int\u0026gt;(V, INFINITY)); for (int i = 0; i \u0026lt; g.size(); i++) { int src = g[i].getSrc(); int dest = g[i].getDest(); int weight = g[i].getWeight(); if (adj[src][dest] \u0026gt; weight) { adj[src][dest] = weight; } } } /*vertex수 입력받은 후 그래프 간선 가중치 random 삽입*/ void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g) { std::cout \u0026lt;\u0026lt; \u0026#34;create number of Vertex : \u0026#34;; std::cin \u0026gt;\u0026gt; V; srand((unsigned int)time(NULL)); for (int i = 0; i \u0026lt; V - 1; i++) { g.push_back(Graph(i, i + 1, rand() % 1000)); for (int j = i + 1; j \u0026lt; V; j++) { g.push_back(Graph(i, j, rand() % 1000)); } } for (int i = (rand() % 3); i \u0026lt; V - 1; i += (rand() % 10)) { g.push_back(Graph(i, i + 1, rand() % 1000)); for (int j = i + 1; j \u0026lt; V; j += (rand() % 10)) { g.push_back(Graph(i, j, rand() % 1000)); } } } void print_edge_info(std::vector\u0026lt;Graph\u0026gt; g) { std::cout \u0026lt;\u0026lt; \u0026#34;edge info : \\n\u0026#34;; std::for_each(g.begin(), g.end(), [](Graph a) { std::cout \u0026lt;\u0026lt; \u0026#34;src : \u0026#34; \u0026lt;\u0026lt; a.getSrc() \u0026lt;\u0026lt; \u0026#34; desc : \u0026#34; \u0026lt;\u0026lt; a.getDest() \u0026lt;\u0026lt; \u0026#34; weight : \u0026#34; \u0026lt;\u0026lt; a.getWeight() \u0026lt;\u0026lt; std::endl; }); } //실행 시간을 측정 및 출력하는 함수 void CalcTime() { used_time = finish - start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time) / CLOCKS_PER_SEC); } "},{"section":"Blog","slug":"/blog/algorithms/bellman-ford/","title":"[SPSP] Bellman Ford 알고리즘","description":"단일 최단경로를 구하는 알고리즘인 Bellman Ford알고리즘에 대해 정리하고 직접 구현해보는 글","date":"2021년 4월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"SPSP, Bellman Ford","content":"그래프 중에서 최단 경로를 찾는 알고리즘중에 하나로 하나의 정점에서 다른 모든 정점까지의 최단경로를 구하는 알고리즘 (single-source shortest path algorithmm)으로 음의 가중치도 계산 할수 있는 알고리즘이다.\nVertex의 개수가 N개일 때, 한 vertex에서 다른 vertex까지 가는데 거치는 edge수는 최소 1개부터 최대 N-1번 거치게 된다. 이때, relax의 개념을 이용하며 relax는 현재 계산된 v노드까지의 거리보다 현재 노드 u까지의 경로와 u에서 v의 가중치 (e(u,v)) 가 더 작다면 값을 갱신해주는 것이다.\n이때, relax는 Prim 알고리즘의 decrease-key와 유사하며 dp를 추가한 개념이다.\n1. 특징 음의 가중치를 갖는 경로를 포함해도 구할 수 있다.\n음의 사이클 존재 여부를 알 수 있다. (무한 루프)\nedge 의 정보로 입력이 주어지면 인접행렬, 인접리스트를 안 만들고도 구할 수 있다.\n2. Pesudo Code BELLMAN-FORD(G, w , s){ INITIALIZE-SINGLE-SOURCE(G, s) for i = 1 to |G.V| - 1 for each edge (u,v) ∈ G.E RELAX (u,v,w) for each edge (u,v) ∈ G.E if v.d \u0026gt; u.d + w(u,v) return false return true } RELAX(u,v,w) if v.d \u0026gt; u.d + w(u,v) v.d = u.d + w(u,v) v.π = u 3. 구현 방법 vertex들의 key값을 Infinity로 초기화 start vertex의 key값을 0으로 초기화 모든 edge에 대해 relax를 수행 3번을 V-1번 반복 4번이 끝나면 최단 경로는 구해졌으며, 음의 사이클이 있는지 아래의 방법으로 검사 모든 edge에 대해 목적지 vertex의 최단 경로 값이 출발지 vertex까지의 최단 경로 값 + w(u,v) 보다 큰지 검사 만약 크다면 음의 사이클이 존재하고 모든 edge에 대해 아니라면 음의 사이클이 존재하지 않는 그래프 1) 인접 행렬 std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 vertex_key[start] = 0; std::cout \u0026lt;\u0026lt; \u0026#34;\\nsrc : \u0026#34; \u0026lt;\u0026lt; start \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; V - 1; i++) { for (int j = 0; j \u0026lt; V; j++) { for (int k = 0; k \u0026lt; V; k++) { if (vertex_key[k] \u0026gt; adjMatrix[j][k] + vertex_key[j]) { vertex_key[k] = adjMatrix[j][k] + vertex_key[j]; } } } } for (int j = 0; j \u0026lt; V; j++) { for (int k = 0; k \u0026lt; V; k++) { if (vertex_key[k] \u0026gt; adjMatrix[j][k] + vertex_key[j]) { std::cout \u0026lt;\u0026lt; \u0026#34;음의 사이클을 갖는 그래프입니다.\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } } } return vertex_key; 2) 인접 리스트 std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 int dest, weight; vertex_key[start] = 0; std::cout \u0026lt;\u0026lt; \u0026#34;\\nsrc : \u0026#34; \u0026lt;\u0026lt; start \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; V - 1; i++) { for (int j = 0; j \u0026lt; adjList.size(); j++) { for (int k = 0; k \u0026lt; adjList[j].size(); k++) { dest = adjList[j][k].second; weight = adjList[j][k].first; if (vertex_key[dest] \u0026gt; weight + vertex_key[j]) { vertex_key[dest] = weight + vertex_key[j]; } } } } for (int j = 0; j \u0026lt; adjList.size(); j++) { for (int k = 0; k \u0026lt; adjList[j].size(); k++) { dest = adjList[j][k].second; weight = adjList[j][k].first; if (vertex_key[dest] \u0026gt; weight + vertex_key[j]) { std::cout \u0026lt;\u0026lt; \u0026#34;음의 사이클을 갖는 그래프입니다.\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } } } return vertex_key; 3) edge 정보로 주어졌을 경우 td::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 int src, dest, weight; vertex_key[start] = 0; std::cout \u0026lt;\u0026lt; \u0026#34;\\nsrc : \u0026#34; \u0026lt;\u0026lt; start \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; V - 1; i++) { for (int j = 0; j \u0026lt; g.size(); j++) { src = g[j].getSrc(); dest = g[j].getDest(); weight = g[j].getWeight(); if (vertex_key[dest] \u0026gt; weight + vertex_key[src]) { vertex_key[dest] = weight + vertex_key[src]; } } } for (int j = 0; j \u0026lt; g.size(); j++) { src = g[j].getSrc(); dest = g[j].getDest(); weight = g[j].getWeight(); if (vertex_key[dest] \u0026gt; weight + vertex_key[src]) { std::cout \u0026lt;\u0026lt; \u0026#34;음의 사이클을 갖는 그래프입니다.\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } } return vertex_key; 4. 시간 복잡도 초기화하는데 O(|V|) 이 소요되고, 최단 경로를 구하는데 O(|E|) 번의 relax가 |V-1| 번 반복하기 때문에, O(|V||E|) 만큼의 시간이 소요된다. (relax는 비교후 단순 대입이므로 O(1)의 시간 소요)\n그리고 음의 사이클이 존재하는 지 검사하는데 |E| 번 반복해 O(|E|)만큼의 시간이 소요되기 때문에 총 O(|V||E|) 의 시간복잡도를 갖는다.\n5. 구현 코드 아래 코드는 사이클이없는 방향의 그래프이고, 양의 가중치를 무작위로 생성한 그래프이다.\n#include \u0026lt;time.h\u0026gt; //시간 측정 #include \u0026lt;algorithm\u0026gt; //for_each #include \u0026lt;cstdlib\u0026gt; //rand #include \u0026lt;ctime\u0026gt; //time #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #define INFINITY 2140000000 #define II std::pair\u0026lt;int, int\u0026gt; // first = weight, second = dest typedef struct edge { int src; //출발 vertex int dest; //도착 vertex int weight; //가중치(비용) } edge; class Graph { private: edge e; public: Graph(int src = 0, int dest = 0, int weight = 0) { this-\u0026gt;e.src = src; this-\u0026gt;e.dest = dest; this-\u0026gt;e.weight = weight; } int getSrc() { return this-\u0026gt;e.src; } int getDest() { return this-\u0026gt;e.dest; } int getWeight() { return this-\u0026gt;e.weight; } }; void CalcTime(); void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;); // graph에 사이클 없는 연결그래프 cost값 무작위 생성 void print_edge_info(std::vector\u0026lt;Graph\u0026gt;); // graph 간선들 보기 void make_adj_list(std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; \u0026amp;); //주어진 그래프를 인접리스트로 표현 void make_adj_matrix(std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;); //주어진 그래프를 인접행려로 표현 std::vector\u0026lt;int\u0026gt; bellman_ford_list(std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt;, int); std::vector\u0026lt;int\u0026gt; bellman_ford_array(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;, int); std::vector\u0026lt;int\u0026gt; bellman_ford_edge(std::vector\u0026lt;Graph\u0026gt;, int); int V; // vertex 개수 clock_t start, finish, used_time = 0; //실행 시간 측정을 위한 변수 int main() { std::vector\u0026lt;Graph\u0026gt; g; // graph g std::vector\u0026lt;int\u0026gt; shortestPath; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; adjMatrix; std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; adjList; randomPush(g); //간선 random 삽입 print_edge_info(g); // edge info print make_adj_matrix(g, adjMatrix); //주어진 그래프를 인접행렬로 만들기 make_adj_list(g, adjList); //주어진 그래프를 인접리스트로 만들기 start = clock(); // shortestPath = bellman_ford_list(adjList, 0); // list을 이용한 구현 // shortestPath = bellman_ford_array(adjMatrix, 0); // array 이용한 구현 shortestPath = bellman_ford_edge(g, 0); // array 이용한 구현 finish = clock(); for (int i = 0; i \u0026lt; V; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;dest : \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; (cost : \u0026#34; \u0026lt;\u0026lt; ((shortestPath[i] == INFINITY) ? \u0026#34;no path\u0026#34; : std::to_string(shortestPath[i])) \u0026lt;\u0026lt; \u0026#34; )\u0026#34; \u0026lt;\u0026lt; std::endl; } CalcTime(); return 0; } std::vector\u0026lt;int\u0026gt; bellman_ford_list(std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; adjList, int start) { std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 int dest, weight; vertex_key[start] = 0; std::cout \u0026lt;\u0026lt; \u0026#34;\\nsrc : \u0026#34; \u0026lt;\u0026lt; start \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; V - 1; i++) { for (int j = 0; j \u0026lt; adjList.size(); j++) { for (int k = 0; k \u0026lt; adjList[j].size(); k++) { dest = adjList[j][k].second; weight = adjList[j][k].first; if (vertex_key[dest] \u0026gt; weight + vertex_key[j]) { vertex_key[dest] = weight + vertex_key[j]; } } } } for (int j = 0; j \u0026lt; adjList.size(); j++) { for (int k = 0; k \u0026lt; adjList[j].size(); k++) { dest = adjList[j][k].second; weight = adjList[j][k].first; if (vertex_key[dest] \u0026gt; weight + vertex_key[j]) { std::cout \u0026lt;\u0026lt; \u0026#34;음의 사이클을 갖는 그래프입니다.\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } } } return vertex_key; } std::vector\u0026lt;int\u0026gt; bellman_ford_array(std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; adjMatrix, int start) { std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 vertex_key[start] = 0; std::cout \u0026lt;\u0026lt; \u0026#34;\\nsrc : \u0026#34; \u0026lt;\u0026lt; start \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; V - 1; i++) { for (int j = 0; j \u0026lt; V; j++) { for (int k = 0; k \u0026lt; V; k++) { if (vertex_key[k] \u0026gt; adjMatrix[j][k] + vertex_key[j]) { vertex_key[k] = adjMatrix[j][k] + vertex_key[j]; } } } } for (int j = 0; j \u0026lt; V; j++) { for (int k = 0; k \u0026lt; V; k++) { if (vertex_key[k] \u0026gt; adjMatrix[j][k] + vertex_key[j]) { std::cout \u0026lt;\u0026lt; \u0026#34;음의 사이클을 갖는 그래프입니다.\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } } } return vertex_key; } std::vector\u0026lt;int\u0026gt; bellman_ford_edge(std::vector\u0026lt;Graph\u0026gt; g, int start) { std::vector\u0026lt;int\u0026gt; vertex_key(V, INFINITY); // vertex의 최소 weight값 계산 int src, dest, weight; vertex_key[start] = 0; std::cout \u0026lt;\u0026lt; \u0026#34;\\nsrc : \u0026#34; \u0026lt;\u0026lt; start \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; V - 1; i++) { for (int j = 0; j \u0026lt; g.size(); j++) { src = g[j].getSrc(); dest = g[j].getDest(); weight = g[j].getWeight(); if (vertex_key[dest] \u0026gt; weight + vertex_key[src]) { vertex_key[dest] = weight + vertex_key[src]; } } } for (int j = 0; j \u0026lt; g.size(); j++) { src = g[j].getSrc(); dest = g[j].getDest(); weight = g[j].getWeight(); if (vertex_key[dest] \u0026gt; weight + vertex_key[src]) { std::cout \u0026lt;\u0026lt; \u0026#34;음의 사이클을 갖는 그래프입니다.\u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } } return vertex_key; } void make_adj_list(std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;std::vector\u0026lt;II\u0026gt;\u0026gt; \u0026amp;adj) { adj.resize(V); bool isEdge; for (int i = 0; i \u0026lt; g.size(); i++) { isEdge = false; int src = g[i].getSrc(); int dest = g[i].getDest(); int weight = g[i].getWeight(); /*동일 vertex로 향하는 간선중 가장 작은 값만가지고 인접 리스트를 만들기 위한 코드*/ if (adj[src].empty()) { adj[src].push_back({weight, dest}); } else { for (int j = 0; j \u0026lt; adj[src].size(); j++) { if (adj[src][j].second == dest) { isEdge = true; if (adj[src][j].first \u0026gt; weight) { adj[src][j].first = weight; } } } if (!isEdge) adj[src].push_back({weight, dest}); } } } void make_adj_matrix(std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;adj) { adj.assign(V, std::vector\u0026lt;int\u0026gt;(V, INFINITY)); for (int i = 0; i \u0026lt; g.size(); i++) { int src = g[i].getSrc(); int dest = g[i].getDest(); int weight = g[i].getWeight(); if (adj[src][dest] \u0026gt; weight) { adj[src][dest] = weight; } } } /*vertex수 입력받은 후 그래프 간선 가중치 random 삽입*/ void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g) { std::cout \u0026lt;\u0026lt; \u0026#34;create number of Vertex : \u0026#34;; std::cin \u0026gt;\u0026gt; V; srand((unsigned int)time(NULL)); for (int i = 0; i \u0026lt; V - 1; i++) { g.push_back(Graph(i, i + 1, rand() % 1000)); for (int j = i + 1; j \u0026lt; V; j++) { g.push_back(Graph(i, j, rand() % 1000)); } } for (int i = (rand() % 3); i \u0026lt; V - 1; i += (rand() % 10)) { g.push_back(Graph(i, i + 1, rand() % 1000)); for (int j = i + 1; j \u0026lt; V; j += (rand() % 10)) { g.push_back(Graph(i, j, rand() % 1000)); } } } void print_edge_info(std::vector\u0026lt;Graph\u0026gt; g) { std::cout \u0026lt;\u0026lt; \u0026#34;edge info : \\n\u0026#34;; std::for_each(g.begin(), g.end(), [](Graph a) { std::cout \u0026lt;\u0026lt; \u0026#34;src : \u0026#34; \u0026lt;\u0026lt; a.getSrc() \u0026lt;\u0026lt; \u0026#34; desc : \u0026#34; \u0026lt;\u0026lt; a.getDest() \u0026lt;\u0026lt; \u0026#34; weight : \u0026#34; \u0026lt;\u0026lt; a.getWeight() \u0026lt;\u0026lt; std::endl; }); } //실행 시간을 측정 및 출력하는 함수 void CalcTime() { used_time = finish - start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time) / CLOCKS_PER_SEC); } "},{"section":"Blog","slug":"/blog/algorithms/topology-sort/","title":"Topological Sort (위상 정렬)","description":"위상정렬에 대해 정리하고 C++로 코드를 작성한 글","date":"2021년 4월 12일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"Sort, Topological Sort","content":"조건 : 방향이 있고 사이클이 없는 그래프 (Directed Acyclic Graph)\nDAG일때, 방향성을 거스르지 않고 나열하는 것으로 순서가 있는 작업을 차례로 수행해야할때 순서를 결정해주기 위해 사용하는 알고리즘이다.\n대학 커리큘럼의 선수과목이나 엄무의 일정을 시간 순서대로 배치한것이 그 예 이다.\n1. 특징 방향이 있는 그래프이어야 한다. (directed) 사이클이 없어야 한다. (Acyclic) 2. Pesudo Code 1) InDegree 이용방법 Topological Sort(G){ INITIALIZE-InDegree(G.V) result ← ∅ for each indegree[v] == 0 Q \u0026lt;- v for i = 1 to |G.V| u = Pop(Q); result \u0026lt;- u for each v ∈ Adj[u] indegree[u] ← indegree[u] - 1 if (inDegree[u] == 0) Q \u0026lt;- u } 2) dfs 이용방법 Topological Sort(G){ result ← ∅ visit ← ∅ for i =1 to |G.V| if not visit[i] dfs(i) } dfs(v){ visit[v] \u0026lt;- true for each v ∈ Adj[u] if not visit[u] dfs(u) result \u0026lt;- v } 3. 구현 방법 1) InDegree 이용 모든 vertex에 대해 InDegree값을 초기화 진입 차수 (indegree)가 0인 값을 큐에 삽입 큐에서 1개 vertex, v를 pop v를 stack에 쌓기 (정렬한 값을 담는 것이 stack) v에 연결된 vertex들의 indegree값을 1감소 진입 차수가 0인 정점들을 큐에 삽입 3-6번을 Vertex수만큼 반복 만약에 큐가 비어있다면, 사이클이 존재하는 그래프 (큐가 비어있다면 indegree가 0인 값이 없었다는 소리. 즉, 사이클 발생) 2) dfs 이용 방문하지 않은 vertex들을 dfs함수 진행. dfs 해당 vertex 방문표시 인접 vertex에 대해 방문하지 않았다면 dfs함수 진행 dfs함수 종료시 stack에 push 4. 시간 복잡도 indegree방법은 초기화하는데 O(V), 큐에 삽입, 제거 하는게 O(V)번씩 소요되며, indegree를 1감소 시켜주는게 O(E)번 일어난다. (indegree를 1감소해주는건 edge를 삭제해주는거와 같기 때문) 따라서, O(V+E)의 시간복잡도를 갖는다.\ndfs방법또한 모든 vertex에 대해 방문했는지 확인하고, 연결된 모든 E를확인후 dfs수행하기때문에 O(V+E)를 갖는다.\n5. 구현 코드 아래 코드는 사이클이없는 무작위의 무방향의 그래프가 입력으로 주어지고 정렬하게 되면 오름차순으로 정렬되게 edge를 생성하는 그래프가 된다.\n#include \u0026lt;time.h\u0026gt; //시간 측정 #include \u0026lt;algorithm\u0026gt; //for_each #include \u0026lt;cstdlib\u0026gt; //rand #include \u0026lt;ctime\u0026gt; //time #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; typedef struct edge { int src; //출발 vertex int dest; //도착 vertex } edge; class Graph { private: edge e; public: Graph(int src = 0, int dest = 0) { this-\u0026gt;e.src = src; this-\u0026gt;e.dest = dest; } int getSrc() { return this-\u0026gt;e.src; } int getDest() { return this-\u0026gt;e.dest; } }; void CalcTime(); void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;); // graph에 사이클 없는 연결그래프 cost값 무작위 생성 void print_edge_info(std::vector\u0026lt;Graph\u0026gt;); // graph 간선들 보기 void countInDegree(std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;int\u0026gt; \u0026amp;); std::vector\u0026lt;int\u0026gt; topologicalSort_queue(std::vector\u0026lt;int\u0026gt;, std::vector\u0026lt;Graph\u0026gt;); std::vector\u0026lt;int\u0026gt; topologicalSort_dfs(std::vector\u0026lt;Graph\u0026gt;); void dfs(int, std::vector\u0026lt;int\u0026gt; \u0026amp;, std::vector\u0026lt;int\u0026gt; \u0026amp;, std::vector\u0026lt;Graph\u0026gt;, std::vector\u0026lt;int\u0026gt; \u0026amp;); int V; // vertex 개수 clock_t start, finish, used_time = 0; //실행 시간 측정을 위한 변수 int main() { std::vector\u0026lt;Graph\u0026gt; g; // graph g std::vector\u0026lt;int\u0026gt; inDegree; std::vector\u0026lt;int\u0026gt; result; randomPush(g); //간선 random 삽입 print_edge_info(g); // edge info print countInDegree(g, inDegree); start = clock(); result = topologicalSort_queue(inDegree, g); // inDegree 이용 // result = topologicalSort_dfs(g); //dfs 이용 finish = clock(); /*DFS이용시 SORT PRINT*/ /* std::cout \u0026lt;\u0026lt; \u0026#34;\\nTopological Sort : \u0026#34;; for (int i = result.size() - 1; i \u0026gt;= 0; i--) { std::cout \u0026lt;\u0026lt; result[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } */ /*INDEGREE방법 이용시 SORT PRINT*/ for_each(result.begin(), result.end(), [](int v) { std::cout \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); CalcTime(); return 0; } void countInDegree(std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;int\u0026gt; \u0026amp;inDegree) { inDegree.assign(V, 0); for (int i = 0; i \u0026lt; g.size(); i++) { inDegree[g[i].getDest()]++; } } std::vector\u0026lt;int\u0026gt; topologicalSort_queue(std::vector\u0026lt;int\u0026gt; inDegree, std::vector\u0026lt;Graph\u0026gt; g) { std::vector\u0026lt;int\u0026gt; sort; std::queue\u0026lt;int\u0026gt; q; /*inDegree가 0인 선행차수가 없는 초기 노드들 큐에 삽입*/ for (int i = 0; i \u0026lt; V; i++) { if (inDegree[i] == 0) { q.push(i); } } /*process*/ for (int i = 0; i \u0026lt; V; i++) { if (q.empty()) { std::cout \u0026lt;\u0026lt; \u0026#34;No DAG (Direced Acyclic Graph) \u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } int top = q.front(); q.pop(); sort.push_back(top); /*pop한 정점과 연결된 모든 edge들 indegree 1감소 시키고 0이라면 push*/ for (int i = 0; i \u0026lt; g.size(); i++) { if (g[i].getSrc() == top) { inDegree[g[i].getDest()]--; if (inDegree[g[i].getDest()] == 0) { q.push(g[i].getDest()); } } } } return sort; } std::vector\u0026lt;int\u0026gt; topologicalSort_dfs(std::vector\u0026lt;Graph\u0026gt; g) { std::vector\u0026lt;int\u0026gt; sort; // vertex를 규칙에 맞게 sort std::vector\u0026lt;int\u0026gt; visited(V, false); //방문한 vertex표시 std::vector\u0026lt;int\u0026gt; selectVertex(V, false); //선택한 vertex표시 /*모든 vertex에 대해 dfs*/ for (int i = 0; i \u0026lt; V; i++) { if (!visited[i]) { dfs(i, visited, selectVertex, g, sort); } } return sort; } void dfs(int v, std::vector\u0026lt;int\u0026gt; \u0026amp;visited, std::vector\u0026lt;int\u0026gt; \u0026amp;selectVertex, std::vector\u0026lt;Graph\u0026gt; g, std::vector\u0026lt;int\u0026gt; \u0026amp;sort) { /*방문 vertex 표시*/ visited[v] = true; /*연결된 edge들 검사*/ for (int i = 0; i \u0026lt; g.size(); i++) { if (g[i].getSrc() == v) { /*방문안한 vertex라면 dfs수행*/ if (!visited[g[i].getDest()]) { dfs(g[i].getDest(), visited, selectVertex, g, sort); } /*방문한 vertex인데, 아직 선택안한 vertex. 즉, 부모~조상노드 =\u0026gt; cycle이 발생*/ else { if (!selectVertex[g[i].getDest()]) { std::cout \u0026lt;\u0026lt; \u0026#34;No DAG (Direced Acyclic Graph) \u0026#34; \u0026lt;\u0026lt; std::endl; exit(1); } } } } /*더이상 edge가 없으면 가장 stack에 넣고 표시*/ selectVertex[v] = true; sort.push_back(v); } /*vertex수 입력받은 후 그래프 간선 random 삽입*/ void randomPush(std::vector\u0026lt;Graph\u0026gt; \u0026amp;g) { std::cout \u0026lt;\u0026lt; \u0026#34;create number of Vertex : \u0026#34;; std::cin \u0026gt;\u0026gt; V; srand((unsigned int)time(NULL)); for (int i = 0; i \u0026lt; V - 1; i++) { g.push_back(Graph(i, i + 1)); for (int j = i + 2; j \u0026lt; V; j += rand() % 3) { g.push_back(Graph(i, j)); } } } void print_edge_info(std::vector\u0026lt;Graph\u0026gt; g) { std::cout \u0026lt;\u0026lt; \u0026#34;edge info : \\n\u0026#34;; std::for_each(g.begin(), g.end(), [](Graph a) { std::cout \u0026lt;\u0026lt; \u0026#34;src : \u0026#34; \u0026lt;\u0026lt; a.getSrc() \u0026lt;\u0026lt; \u0026#34; desc : \u0026#34; \u0026lt;\u0026lt; a.getDest() \u0026lt;\u0026lt; std::endl; }); } //실행 시간을 측정 및 출력하는 함수 void CalcTime() { used_time = finish - start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time) / CLOCKS_PER_SEC); } "},{"section":"Blog","slug":"/blog/spring/secruity-get-userdetails/","title":"인증된 사용자 정보 조회","description":"Spring Security를 이용한 인증에서 Controller의 메서드에서 인증된 사용자 정보 조회하기","date":"2021년 4월 11일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/spring/preview_hu740a35c095c653155a0595aa38be9f22_18108_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"200\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/spring\\/preview_hu740a35c095c653155a0595aa38be9f22_18108_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/spring/preview_hu740a35c095c653155a0595aa38be9f22_18108_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/spring\\/preview_hu740a35c095c653155a0595aa38be9f22_18108_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Spring","tags":"Spring Security","content":"Spring Security의 Filter들을 모두 거쳐 인증에 통과한 User가 특정 Controller에 도달했을 때, User의 정보가 필요할때가 있다. 이때, Url의 도메인으로 id를 표시하거나 param/body로 계속 전달하기도 무리이며, Filter를 통한 인증시에 이미 한번 유저 정보를 조회하는 로직을 수행하게 된다. 그런데 한번더 select로 조회시 두번 조회하게 되는 비효율적인 상황이 발생하기 때문에 Spring Security의 Context Holder에 들어있는 인증 정보를 가져다 사용하면 Filter에서 인증을 수행한 User의 정보(Details)에 접근할 수 있다.\n이 Context Holder에 접근하는 방법은 다음과 같은 방법이 존재한다.\n1. @Controller의 메서드에서 매개변수로 입력받기 @Controller public class UserController{} @GetMapping public String getMyInfo(Authentication authentication){ JwtAuthenticationToken authentication = (JwtAuthenticationToken) authentication; User user = (User)authentication.getDetails(); return user.toString(); } } @Controller로 등록된 Bean의 메서드들은 메서드에서 추가 매개변수 인자로 Authentication타입을 받을 수 있다. 위와같이 선언하면 Container가 인증객체를 메서드에 추가해주게 된다.\n인증처리과정에서 Custom Authenticaion 객체를 사용하고 있다면 Authentication을 이용해서 명시적 형변환을 이용하거나 처음부터 매개변수타입으로 지정을 할 수 있다.\n@Controller public class UserController{} @GetMapping public String getMyInfo(JwtAuthenticationToken authentication){ User user = (User)authentication.getDetails(); return user.toString(); } } @Controller public class UserController{} @GetMapping public String getMyInfo(Principal principal){ return principal.toString(); } } 또한 Authentication 객체 뿐만이 아닌 Principal객체도 주입받아 사용할 수 있다.\n2. @AuthenticationPrincipal @Controller public class UserController{} @GetMapping public String getMyInfo(@AuthenticationPrincipal Object principal){ return principal.toString(); } } //Custom principal @Controller public class UserController{} @GetMapping public String getMyInfo(@AuthenticationPrincipal UserInfo principal){ return principal.toString(); } } 위와같이 어노테이션을 선언 후 통해 현재 사용자의 인증 주체를 주입받을수도 있다. 이때 보통 principal은 Object로 선언되어있기 때문에 Object타입을 주입해주어야하고 Custom한 Principal객체가 있다면 그것을 주입해주어도 가능하다.\n다른 타입을 주입시에 null값이 들어가게 된다.\n3. SecurityContext @Controller public class UserController{} @GetMapping public String getMyInfo(){ Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); //Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); UserInfo userInfo = (UserInfo)principal; String id = principal.getId(); return id; } } 가장 원초적인 방법으로는 Container가 주입시켜주는 것이 아닌 SecurityContextHolder에 직접 접근해서 인증 객체를 가져오는 방법으로도 사용자 정보를 가져올 수 있다.\n"},{"section":"Blog","slug":"/blog/error/one-to-many-error/","title":"@OneToMany 관계시 발생한 에러","description":"&#34;A collection with cascade=&#34;all-delete-orphan&#34; was no longer referenced by the owning entity instance&#34;에러 해결하기","date":"2021년 4월 11일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Error","tags":"JPA, Spring Boot","content":"JPA의 구현체인 hiberante를 이용해서 엔티티간의 상속관계를 설정하고 처음 사용해보는데 발생한 에러인 A collection with cascade=\u0026ldquo;all-delete-orphan\u0026rdquo; was no longer referenced by the owning entity instance 문제 해결한 방법을 기록하려고 한다.\nUser의 엔티티와 Customer엔티티간의 1:N 양방향 연관관계를 맺기 위해 User에는 @OneToMany를 Customer에는 @ManyToOne관계를 설정을 하고 로직을 돌려보는데 위와 같은 에러가 발생했다.\n문제점1. 초기화 부재 public class User{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Customer\u0026gt; customers; } 연관관계를 위 코드처럼 작성을 했는데, 새로운 User를 선언하거나 수정할때 해당 cutomer가 null이 되서 아무 것도 참조하지 않는다고 에러가 뜬 것이었다.\n엔티티를 영속 상태로 만들때 컬렉션 필드를 효율적으로 관리하기 위해 하이버네이트에서 미리 만들어둔 Wrapper클래스로 감싸(변경하여) 저장하기 때문에 즉시 초기화해서 사용하는 것을 권장한다고 한다.\nPersistentBag : Collection/List (중복 허용o / 순서 x) PersistentSet : Set (중복 허용 x / 순서 x) PersistentList : List + @OrderColumn (중복 허용 o / 순서 o) 해결방법 public class User{ @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; @OneToMany(mappedBy = \u0026#34;user\u0026#34;, cascade = CascadeType.ALL, orphanRemoval = true) private List\u0026lt;Customer\u0026gt; customers = new ArrayList\u0026lt;\u0026gt;(); //리스트 초기화 추가 } 초기화 문제이기 때문에 위와 같이 처음부터 비어있는 ArrayList를 갖도록 바꾸어 주어 해결했다.\n"},{"section":"Blog","slug":"/blog/projects/spring-graphql/custom-context/","title":"spring boot Graphql CustomContext 생성하기","description":"Spring boot Graphql CustomContext 생성하기","date":"2021년 4월 7일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/spring-graphql/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"420\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/spring-graphql\\/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/spring-graphql/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/spring-graphql\\/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"Spring boot, Graphql, Spring Graphql","content":"GraphQL의 요청을 핸들링하는 GraphQLServletContextBuilder를 implements하여 grpahQL요청에 대해 커스텀Context를 반환하도록 만들 수 있다.\n예를들어 요청의 헤더에 접근하여 Context에 특정 헤더값을 저장하는 식으로의 custom이 가능하다. 이번 예시에서는 헤더에 api-key가 포함되어있고 이 key를 분리하여 context도 저장하고있는 context를 만들어보려고 한다.\n1. CustomContext 정의 GraphQLServletContext를 implements하여 총6개의 메서드들을 정의해주면 된다.\n@Getter @RequiredArgsConstructor public class CustomGraphQLContext implements GraphQLServletContext { private final String apiKey; private final GraphQLServletContext context; @Override public List\u0026lt;Part\u0026gt; getFileParts() { return context.getFileParts(); } @Override public Map\u0026lt;String, List\u0026lt;Part\u0026gt;\u0026gt; getParts() { return context.getParts(); } @Override public HttpServletRequest getHttpServletRequest() { return context.getHttpServletRequest(); } @Override public HttpServletResponse getHttpServletResponse() { return context.getHttpServletResponse(); } @Override public Optional\u0026lt;Subject\u0026gt; getSubject() { return context.getSubject(); } @Override public DataLoaderRegistry getDataLoaderRegistry() { return context.getDataLoaderRegistry(); } } 기본적인 ServletContext의 정보를 갖고있을 context 변수와 예시로 헤더값에 포함된 api-key를 저장할 필드를 포함한 커스텀context를 정의 해주면 된다.\n2. GraphQLServeltContextBuilder 실제로 GraphQLServletContext를 생성하는 Builder도 구현해주어야 우리가 생성한 CustomContext로 Context가 생성이 된다.\n@Component @RequiredArgsConstructor public class CustomGraphQLContextBuilder implements GraphQLServletContextBuilder { @Override public GraphQLContext build(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) { String apiKey = httpServletRequest.getHeader(\u0026#34;api-key\u0026#34;); DefaultGraphQLServeltContext context = DefaultGraphQLServletContext.createServletContext() .with(httpServletRequest) .with(httpServletResponse) .build(); return new CustomGraphQLContext(apiKey, context); } @Override public GraphQLContext build(Session session, HandshakeRequest handshakeRequest) { throw new IllegalStateException(\u0026#34;Unsupported\u0026#34;); } @Override public GraphQLContext build() { throw new IllegalStateException(\u0026#34;Unsupported\u0026#34;); } } build() 메서드 3개를 Override해 정의 해주어야 하는데, session방식은 사용하지 않기 때문에 Exception처리 해주었고 build의 매개변수인 httpServletRequest의 getHeader를 통해 api-key의 값을 꺼내고 만들어둔 CustomGraphQLContext에 apiKey를 포함하여 return하면 실제 QueryResolver를 처리하는 Context는 우리가 만든 CustomContext가 처리하게 된다.\n그래서 이전에 설명한 Environment의 getContext() 메서드를 통해서 특정 필드에 접근도 가능하다.\n@Component @Slf4j public class WetayoQuery implements GraphQLQueryResolver { //... 각종 Service들과 Constructor public List\u0026lt;RouteStationGraphQLDto\u0026gt; getStations(Double x, Double y, Double distance, DataFetchingEnvironment e) { CustomGraphQLContext context = e.getContext(); log.info(context.getApiKey()); //헤더의 api-key 값 출력 if(!context.getApiKey().equals(\u0026#34;123456789\u0026#34;)) throw new UnAuthorizedAccessExeption(\u0026#34;유효하지 않은 api key\u0026#34;); //비즈니스 로직 return routeStationDtos; } } 위와 같이 Controller의 메서드에서 context의 필드에도 접근,조회가 가능하게 된다. 하지만 위의 방법은 단일 책임 원칙에 위배되고 AOP스럽지도 못하기 때문에 썩 그렇게 좋은 코드는 아니고 예시로만 봐주면 될 것 같다.\n"},{"section":"Blog","slug":"/blog/projects/spring-graphql/environment/","title":"spring boot Graphql 요청 Environment 접근","description":"spring boot Graphql에서 datafetchingenvironment를 이용해서 쿼리명, 파라미터, 필드에 접근하는 방법을 포스팅합니다.","date":"2021년 4월 3일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/spring-graphql/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"420\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/spring-graphql\\/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/spring-graphql/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/spring-graphql\\/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"Spring boot, Graphql, Spring Graphql","content":"이번에는 Spring Boot GraphQL 환경변수(쿼리명, 파라미터명, 값, 받고자하는 데이터명 등)들을 Controller에서 접근하는 방법을 포스팅하려고 한다.\n보통 Rest한 서버의 Controller에서는 @PathVariable , @RequestBody 등과 같은 어노테이션을 이용해서 파라미터들에 접근할 수 있는데 요청자체가 body안에 json형태로 들어오는 graphQL은 위와 같은 어노테이션을 사용하기에 다소 무리가 있다.\n그래서 지난번에 포스팅한 graphql-java 에서는 DataFetchingEnvironment라는 객체를 제공한다.\nDataFetchingEnvironment는 쿼리의 필드, 필드의 인수, 타입, 쿼리 루트 객체, 쿼리 컨텍스트와 같은 정보를 포함하고 있는 객체이다.\n1. 적용 예 query{ getstaion(double x, double y, double distance){ stationId stationName distance routes{ routeId routeName } } } @PreAuthorize(\u0026#34;hasAuthority(\u0026#39;user\u0026#39;)\u0026#34;) public List\u0026lt;RouteStation\u0026gt; getStations(Double x, Double y, Double distance, DataFetchingEnvironment environment) { List\u0026lt;Station\u0026gt; stations = stationService.getNearByStations(x, y, distance); List\u0026lt;RouteStation\u0026gt; routeStations = new ArrayList\u0026lt;\u0026gt;(); if(environment.getSelectionSet().contains(\u0026#34;routes\u0026#34;)) { for (RouteStation routeStation : routeStationDtos) { List\u0026lt;RouteStation\u0026gt; routeStations = routeStationService.findByStationId(routeStation.getStationId()); routeStation.setRoutes(routeGraphQLDtos); } } return routeStations; } DataFetchingEnvironment를 사용하는 방법은 간단한데 기존에 존재하는 Resolver내의 메서드의 매개변수 인자로 주어주면 사용이 가능하다.\ngraphQL은 요청 파라미터에 따라 응답이 달라지게 되는데 routes정보를 뺀 getStations를 호출하게 되도 getStations메서드가 실행되면서 routes정보를 조회하는 쿼리가 실행되고 응답이 반환되게 된다. 이런 문제를 DataFetchingEnvironment를 이용해서 요청 파라미터에 있는지 확인을 먼저하여 성능향상을 꾀할 수 있게 된다.\n요청 필드명을 DataFetchingFieldSelectionSet이라는 객체로 변환하여 맵핑시킨 environment.getSelectionSet() 을 이용해 요청 파라미터를 확인해볼 수 있다.\n2. 제공 메서드들 getstaion(double x, double y, double distance){ stationId stationName distance routes{ routeId routeName } } 다음과 같은 쿼리를 예시로 설명하겠다.\n1) getField 쿼리명(getStation), 파라미터(x, y, distance), 요청 필드(stationId, stationName\u0026hellip;)들을 담고있는 객체가 반환되어 이 객체에서 getArgument() , getSelectionSet() 과 같은 메서드로 변수들을 접근할 수 있다.\n2) getArguments() 요청 필드(stationId, staionName \u0026hellip;)들을 담고있는 Map을 반환 받고 Map이기 때문에 get() 메서드로 접근이 가능한데 getField().getArgument() 와 차이점은 getField의 getArgument는 List이기 때문에 index로만 접근이 가능하지만 getArguments() 는 Map이기 때문에 필드명으로 접근이 가능하다.\n3) getContext() 현재 쿼리를 담당하는 Context를 반환하는 메서드로 DefaultGraphQLServletContext가 반환되고 GraphQLServeltContextBuilder 인터페이스를 상속받아 Custom Context를 만들어서 요청, 응답 헤더에 접근이 가능하다.\n다음글로 CustomContext를 만드는 것을 포스팅 할 예정이다.\n4) getSelectionSet() DataFetchingFieldSelectionSet 이라는 객체로 반환이 되며 contains() / containsAnyOf() / containsAllOf() 메서드로 필드명이 존재하는 지 확인이 가능하고 getFields() 를 이용해 정규표현식에 부합한 필드를 반환받을 수도 있다.\n5) getExecutionId() 각 쿼리 실행에 고유한 Id가 부여되고 이를 이용해서 각각의 쿼리에 대해 로그를 찍을때 태그를 지정할 수 있다.\nReference https://www.graphql-java.com/documentation/v11/data-fetching/ "},{"section":"Blog","slug":"/blog/projects/spring-graphql/security/","title":"Spring Security 적용해보기","description":"springboot GraphQL서버에 SpringSecurity 적용해보기","date":"2021년 4월 1일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/spring-graphql/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"420\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/spring-graphql\\/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/spring-graphql/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/spring-graphql\\/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"Spring boot, Graphql, Spring Graphql","content":"지난번에 spring boot를 이용해서 graphQL서버를 구성해보았는데, 서비스를 운영할때 가장 중요한 보안을 설정하기 위해 springSecurity를 적용한 사례를 작성해보려고 한다.\n우선, 인증 방식을 선택해야 하는데, 버스정보 어플같은 경우 사용자를 구분할 별도의 인증이 필요없기 때문에 간단하게 api-key를 통한 인증을 구현해보았다. graphQL로 kickstart 라이브러리를 이용하여 구현했기 때문에 다른 라이브러리를 이용했다면 Resolver와 같은 Handler클래스는 형식이 달라질 수 있다.\n1. 라이브러리 추가 dependencies { ... 그 외 라이브러리 //spring security compile \u0026#34;org.springframework.boot:spring-boot-starter-security\u0026#34; } gradle은 위와 같이 한줄을 추가 해주면 되고 maven은 maven repository 에서 버전을 선택해 의존성 추가해주면된다.\n2. WebSecurityConfigurerAdapter를 상속받은 Config클래스 생성 @EnableWebSecurity @EnableGlobalMethodSecurity(prePostEnabled = true) @RequiredArgsConstructor public class GraphQLSecurityConfig extends WebSecurityConfigurerAdapter { public static final String USER_ID_PRE_AUTH_HEADER = \u0026#34;api_key\u0026#34;; @Override protected void configure(HttpSecurity http) throws Exception { http // api-key auth 필터 추가 .addFilterBefore(new ApiKeyAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class) .authorizeRequests() // 모든 endpoint는 인증이 필요 .anyRequest().authenticated() .and() // session manager filter 사용 x .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .csrf().disable() .httpBasic().disable() // Disable the /logout filter .logout().disable() // Disable anonymous users .anonymous().disable(); } @Override public void configure(WebSecurity web) { web.ignoring().antMatchers(\u0026#34;/playground\u0026#34;); } } spiring security를 의존성 추가만 해줘도 springsecurity filter들이 자동으로 등록되어 모든 도메인에대한 접속이 인증이 필요하게 되는데 우리는 서버 접속에 id/pw방식을 사용하지 않을 것이기 때문에 filter를 custom해주어야한다.\n그래서 WebSecurityConfigurerAdapter를 상속하여 configure메서드를 오버라이딩 해주어 재설정 해주면된다. @EnableWebSecurity어노테이션을 달면 springSecurity filter들이 자동으로 포함되고, @EnableGlobalMethodSecurity(prePostEnabled = true) 어노테이션을 통해 컨트롤러에 존재하는 메서드들에 @PreAuthorize() 어노테이션을 통해 권한여부를 파악할 수 있게 해준다.\ngraphQL은 endpoint가 한개이므로 도메인별 권한을 config에서 부여하기 힘들기 대문에 이 어노테이션 방식을 통해 권한을 인증하는 방식으로 구성해야 한다.\nconfigure메서드를 통해 기본인증방식인 form방식/session/httpBasic등을 비활성화 해주고, 웹으로 /playground 접속을 할 수 있게 WebSecurity를 매개변수로 갖는 configure메서드에서 위와 같이 추가해주었다.\n3. Filter 추가 public class ApiKeyAuthenticationFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if(request instanceof HttpServletRequest \u0026amp;\u0026amp; response instanceof HttpServletResponse){ String apiKey = getApiKey((HttpServletRequest) request); if(apiKey != null){ ApiKeyAuthenticationToken apiToken = new ApiKeyAuthenticationToken(apiKey); SecurityContextHolder.getContext().setAuthentication(apiToken); }else { HttpServletResponse httpResponse = (HttpServletResponse) response; httpResponse.setStatus(403); } chain.doFilter(request, response); } } private String getApiKey(HttpServletRequest httpRequest) { return httpRequest.getHeader(USER_ID_PRE_AUTH_HEADER); } } 필터를 하나 생성하여 http요청 헤더에서 api-key라는 헤더가 있는지 검사하는 로직을 수행하게 해주었는데, filter를 custom으로 생성을 해주었으면 chain.doFilter(req,res) 를 꼭 넣어줘어야 필터체인의 다음 필터를 이어서 수행하기 때문에 빼먹지말자.\n헤더에 api-key가 존재하면 해당 api-key가 유요한 key인지 인증(검사)를 해야 하기 때문에 를 Set해주면 된다.\n1) 커스텀 인증 객체 생성 public class ApiKeyAuthenticationToken extends AbstractAuthenticationToken { private String apiKey; public ApiKeyAuthenticationToken(String apiKey) { super(null); this.apiKey = apiKey; } public ApiKeyAuthenticationToken(Collection\u0026lt;? extends GrantedAuthority\u0026gt; authorities, String apiKey) { super(authorities); this.apiKey = apiKey; setAuthenticated(true); } @Override public Object getCredentials() { return null; } @Override public Object getPrincipal() { return apiKey; } } SecurityContexholder에 추가해줄 Custom한 Authentication객체를 만들어야 하는데 AbstractAuthenticationToken을 상속받아 객체를 정의 해주면 되고 apiKey만 파라미터로하는 생성자는 인증전의 객체이며, Role을 담은 authorities를 포함하여 객체를 생성하면 인증 후의 객체로 setAuthrenticatd(true) 을 수행해주면 된다.\n위의 필터에서는 apikey만을 파라미터로 주고있기 때문에 apikey가 있는지 검사하는 필터일 뿐이지 인증을 수행하지는 않은 상태이다.\n4. Provider 생성 @Component public class ApiKeyProvider implements AuthenticationProvider { private final AuthProperties authProperties; public ApiKeyProvider(AuthProperties authProperties) { this.authProperties = authProperties; } @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { if(authentication.isAuthenticated()) return authentication; if(authentication.getPrincipal().toString().equals(authProperties.getApiKey().get(\u0026#34;user\u0026#34;))){ ApiKeyAuthenticationToken token = new ApiKeyAuthenticationToken(AuthorityUtils.createAuthorityList(\u0026#34;user\u0026#34;),authentication.getPrincipal().toString()); token.setAuthenticated(true); return token; }else if(authentication.getPrincipal().toString().equals(authProperties.getApiKey().get(\u0026#34;bus\u0026#34;))){ ApiKeyAuthenticationToken token = new ApiKeyAuthenticationToken(AuthorityUtils.createAuthorityList(\u0026#34;bus\u0026#34;),authentication.getPrincipal().toString()); token.setAuthenticated(true); return token; } else throw new AccessDeniedException(\u0026#34;invalid api-key\u0026#34;); } @Override public boolean supports(Class\u0026lt;?\u0026gt; authentication) { return ApiKeyAuthenticationToken.class.isAssignableFrom(authentication); } } UsernamePasswordAuthenticationFilter, BasicAuthenticationFilter, FilterSecurityInterceptor에서 Authentication Manager를 통해 Authentication객체의 인증을 수행하게 되는데 이때 Manger는 각종 Provider를 이용해서 인증객체를 인증한다.\n많은 Provider중에서 supports메서드를 통해 인증할 객체타입에 맞는 Provider를 찾아 인증을 수행하기 때문에 일일히 Filter에서 특정 Provider를 사용하도록 Manager에게 알려줄 필요가 없다. 그래서 Provider를 정의할때는 supports도 override하여 해당 객체타입임을 알려주어야 한다.\nManager가 적합한 provider를 찾으면 수행하는 메서드인 authenticate를 override하여 여기에 인증 과정을 정의해주면 된다. 나는 application.properties에 미리 api-key를 생성해놓고 이를 이용해 비교로직을 수행하기 위해 AuthProperties라는 객체를 따로 빈으로 생성해서 .properties의 값을 가져오도록 했다.\n값이 같다면 역할(Authority)을 포함한 인증객체를 생성해 return하여 인증객체가 인증되었음( setAuthenticated(true) )을 수행토록 했다.\n5. controller의 메서드들에 @PreAuthorize추가 @Component @Slf4j public class WetayoQuery implements GraphQLQueryResolver { private final StationService stationService; private final RouteStationService routeStationService; private final RideService rideService; private final RouteService routeService; private final ModelMapper modelMapper; WetayoQuery(StationService stationService, ModelMapper modelMapper, RouteStationService routeStationService , RideService rideService, RouteService routeService) { this.stationService = stationService; this.modelMapper = modelMapper; this.routeStationService = routeStationService; this.rideService = rideService; this.routeService = routeService; } @PreAuthorize(\u0026#34;hasAuthority(\u0026#39;user\u0026#39;)\u0026#34;) public List\u0026lt;RouteStationGraphQLDto\u0026gt; getStations(Double x, Double y, Double distance, DataFetchingEnvironment e) { List\u0026lt;Station\u0026gt; stations = stationService.getNearByStations(x, y, distance); List\u0026lt;RouteStationGraphQLDto\u0026gt; routeStationDtos = new ArrayList\u0026lt;\u0026gt;(); // = Arrays.asList(modelMapper.map(stations, RouteStationGraphQLDto[].class)); stations.forEach(station -\u0026gt; { RouteStationGraphQLDto tmp = modelMapper.map(station,RouteStationGraphQLDto.class); tmp.setDistance(GeometryUtil.calculateDistance(x, y, station.getGps().getX(), station.getGps().getY())); routeStationDtos.add(tmp); }); routeStationDtos.sort(Comparator.comparing(RouteStationGraphQLDto::getDistance)); if(e.getSelectionSet().contains(\u0026#34;routes\u0026#34;)) { for (RouteStationGraphQLDto routeStationDto : routeStationDtos) { List\u0026lt;RouteStation\u0026gt; routeStations = routeStationService.findByStationId(routeStationDto.getStationId()); List\u0026lt;RouteDto\u0026gt; routeGraphQLDtos = Arrays.asList(modelMapper.map(routeStations, RouteDto[].class)); routeStationDto.setRoutes(routeGraphQLDtos); } } log.info(\u0026#34;Query Stations (요청 gps : \u0026#34; + x + \u0026#34;, \u0026#34; + y + \u0026#34;) = \u0026#34; + routeStationDtos); return routeStationDtos; } @PreAuthorize(\u0026#34;hasAuthority(\u0026#39;bus\u0026#39;)\u0026#34;) public boolean getRide(Integer stationId, Integer routeId) { rideService.getRide(stationId, routeId); log.info(\u0026#34;Query Ride(stationId : \u0026#34; + stationId + \u0026#34;, routeId : \u0026#34; + routeId ); return true; } @PreAuthorize(\u0026#34;hasAuthority(\u0026#39;bus\u0026#39;)\u0026#34;) public List\u0026lt;RouteDto\u0026gt; getRoutes(String regionName) { List\u0026lt;Route\u0026gt; routes = routeService.getRoutes(\u0026#34;%\u0026#34; + regionName + \u0026#34;%\u0026#34;);; List\u0026lt;RouteDto\u0026gt; routeDtos = Arrays.asList(modelMapper.map(routes, RouteDto[].class));; log.info(\u0026#34;Query Routes (요청 지역 이름 : \u0026#34; + regionName + \u0026#34;) = \u0026#34; + routeDtos); return routeDtos; } } GraphQL의 contoller역할을 수행하는 QueryResolver의 메서드들에 어노테이션들을 붙여, api-key에 따른 역할을 구분하고 권한인증을 처리하도록 수행해주면 간단한 api-key를 통한 인증이 마무리 된다.\n6. 결과 http://localhost:8080/playground에 접속해서 header를 셋팅하고 query를 날려보면 정상적으로 응답이 잘 오는 것을 볼 수 있다. 꼭 playground가 아니고 postman과 같은 프로그램을 이용해도 무방하다.\n"},{"section":"Blog","slug":"/blog/java/sort/","title":"자바에서의 정렬","description":"자바에서 각종 자료구조들을 정렬하는 방법을 정리합니다. Comparalbe과 Comparator의 차이점, 커스텀 객체 정렬방법","date":"2021년 3월 28일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"순서화가 가능한 자료구조를 정렬하는 방법에는 삽입정렬,버블정렬,분할정렬,퀵정렬 등 잘알려진 정렬 외에도 정말 많이 존재하는데 지금은 이러한 정렬의 알고리즘이 아닌 이미 자바 라이브러리에서 제공하는 자료구조들을 쉽게 정렬하는 방법을 정리하고자 한다.\n자바에서의 크기를 비교할 수 있는 객체들은 모두 Comparable을 implements하여 compareTo를 구현하여 두 값중 어떤 것이 더 큰 값인지 알 수 있게끔 명시하고 있다.\nSort 방법 ◾ Arrays.sort() int[] intArr = {4, 5, 1, 6, 3, 8}; String[] strArr = {\u0026#34;A\u0026#34;,\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;aA\u0026#34;, \u0026#34;ab\u0026#34; }; Arrays.sort(intArr); Arrays.sort(strArr); System.out.println(Arrays.toString(intArr)); // [1, 3, 4, 5, 6, 8] System.out.println(Arrays.toString(strArr)); // [A, a, aA, ab, b] 배열들을 정렬하는 메서드로 각 클래스에 정의된 compareTo()를 기준으로 정렬을 수행하고 내부 코드를 들여다보면 int/char/double\u0026hellip;와 같은 원시타입의 배열은 dual pivot quick정렬을 사용하고 있고 Object형은 레거시로 merge sort, 자바 7이후부터는 TimSort를 사용하고 있다.\n배열을 정렬하는 메서드이기 때문에 Arrays.sort()로 List와 같은 Collection을 정렬하려고 하면 에러가 난다.\n◾ Collections.sort() Arrays.sort()로는 정렬을 하지 못했던 자료구조들을 정렬하기 위해 대부분의 자료구조의 조상인 Collections에 sort가 구현되어 있다.\nList\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); intList.add(4); intList.add(5); intList.add(1); List\u0026lt;String\u0026gt; strList = new ArrayList\u0026lt;\u0026gt;();strList.add(\u0026#34;Aa\u0026#34;); strList.add(\u0026#34;AA\u0026#34;); strList.add(\u0026#34;AZ\u0026#34;); strList.add(\u0026#34;z\u0026#34;); Collections.sort(intList); Collections.sort(strList); System.out.println(intList); //[1, 4, 5] System.out.println(strList); //[AA, AZ, Aa, z] Collections.sort는 내부에 List.sort()를 수행하도록 되어있고 List.sort()는 결국 List를 배열로 바꾸어 Arrays.sort()를 수행해 List로 다시 바꿔 반환하는 방법으로 수행하게 된다. Arrays.sort()에 Object형을 정렬하기 때문에 TimSort로 정렬하게 된다.\nintList.sort(null); strList.sort(null); System.out.println(intList); //[1, 4, 5] System.out.println(strList); //[AA, AZ, Aa, z] Collections.sort()가 결국 List.sort()를 수행하기 때문에 List변수를 가지고 바로 sort메서드를 호출 할 수도 있으며, 인자값으로 Comparator를 넘겨주어야하는데 null을 넘겨주면 기본값인 오름차순으로 정렬한다.\nComparable 인터페이스 Custom 객체와 같이 순서가 정의 되지 않은 객체들을 정렬하기 위해서 어떤 값이 더 큰 값인지 정의를 해주어야하기 때문에 클래스를 선언할 때 Comparable를 implement하여 compareTo를 Override해주어야 한다.\nclass Pair implements Comparable\u0026lt;Pair\u0026gt;{ int x; int y; public Pair(int x, int y) { this.x = x; this.y = y; } @Override public int compareTo(Pair o) { if(this.x \u0026gt; o.x) return 1; else if(this.x \u0026lt; o.x) return -1; else return (this.y \u0026gt; o.y) ? 1 : -1; } @Override public String toString() { return \u0026#34;Pair{\u0026#34; + \u0026#34;x=\u0026#34; + x + \u0026#34;, y=\u0026#34; + y + \u0026#39;}\u0026#39;; } } public class Main{ public static void main(String[] args){ Pair[] arr1 = {new Pair(2,1), new Pair(1,2), new Pair(1,1)}; Arrays.sort(arr1); System.out.println(Arrays.toString(arr1)); //[Pair{x=1, y=1}, Pair{x=1, y=2}, Pair{x=2, y=1}] } } 다음은 값이 쌍으로 있는 객체일때 x를 기준으로 오름차순, x가 같다면 y를 기준으로 오름차순으로 정렬한 예제이다.\n핵심은 Comparable을 implements하여 compareTo를 구현하는 것인데 return 값이 양수이면 두 값을 swap하겠다는 의미이다. 그렇기 때문에 오름차순으로 정렬하려면 기준이되는 값이 비교값보다 크다면 양수를 return해야하고 내림차순이라면 작을때 양수를 return하면 된다.\n한마디로 Comparable은 순서가 정의되지 않은 객체들(Custom 객체들)을 정렬하고자 할때 기본이 되는 정렬순서를 정의하는 인터페이스이다.\nComparator 인터페이스 https://gowoonsori.comimages/java/sort/comparator.png does not exist\rCollections.sort/List.sort()는 결국 Arrays.sort()를 수행한다고 위에서 설명했는데, Arrays.sort()의 인자값으로 배열뿐만이 아닌 Comparator라는 인터페이스를 구현한 구현체도 받는걸 볼 수 있다. 이처럼 Comparator는 sort메서드를 수행하려고 할때 객체에 정의된 compareTo가 아닌 새로운 기준을 제시하고자 할때 사용할 수 있다.\nPair[] arr1 = {new Pair(2,1), new Pair(1,2), new Pair(1,1)}; Arrays.sort(arr1, new Comparator\u0026lt;Pair\u0026gt;() { @Override public int compare(Pair o1, Pair o2) { if(o1.x \u0026gt; o2.x) return 1; else if(o1.x \u0026lt; o2.x) return -1; else return (o1.y \u0026gt; o2.y) ? 1 : -1; } }); /* 변수 할당해 삽입 Comparator myCompartor = new Comparator() { @Override public int compare(Object o1, Object o2) { if(o1.x \u0026gt; o2.x) return 1; else if(o1.x \u0026lt; o2.x) return -1; else return (o1.y \u0026gt; o2.y) ? 1 : -1; } }; Arrays.sort(arr1, myCompartor); */ /* Lambda 이용 Arrays.sort(arr1, (Pair o1, Pair o2) -\u0026gt; { if (o1.x \u0026gt; o2.x) return 1; else if (o1.x \u0026lt; o2.x) return -1; else return (o1.y \u0026gt; o2.y) ? 1 : -1; }); */ System.out.println(Arrays.toString(arr1)); //[Pair{x=1, y=1}, Pair{x=1, y=2}, Pair{x=2, y=1}] 위와 같이 Arrays.sort()나 Collections.sort()에 두번째 인자로 Comparator을 넘겨주면 정렬 순서를 재정의 할 수 있고, Comparator가 함수형 인터페이스 인 것을 이용해 람다식으로 간단하게 표현도 가능하다.\n여기서 이미 눈치챈사람도 있겠지만, Comparable은 객체에 implements하여 정렬 기준을 정의하고 Comparator는 제네릭 두개를 인자로 받아 비교를 하는 compare를 구현하기 때문에 정렬할 데이터 타입이 객체가 아니면 정렬 순서를 재정의 할 수 없다.\nint[] intArr = {4, 5, 1, 6, 3, 8}; Arrays.sort(intArr); //가능 Arrays.sort(intArr, (int a, int b) -\u0026gt; a \u0026lt; b? 1: -1)); //불가능 int배열은 객체가 아니기 때문에 기본으로 제공하는 sort메서드를 이용하면 오름차순으로 정렬은 가능하지만, Comparator를 이용한 내림차순으로 정렬이 불가능하다.\n이는 int를 객체타입인 Integer로 바꾸어 정렬을 수행해주면 해결이 가능하다.\nint[] intArr = {4, 5, 1, 6, 3, 8}; Integer[] cpyArr = Arrays.stream(arr).boxed().toArray(Integer[]::new); Arrays.sort(cpyArr, Collections.reverseOrder()); // Arrays.sort(cpyArr,(Integer a, Integer b) -\u0026gt; a \u0026lt; b? 1: -1); System.out.println(Arrays.toString(cpyArr)); //[8, 6, 5, 4, 3, 1] int[]를 for문이나 stream을 이용하여 Integer[]로 바꿔준 후 내림차순으로 정렬되도록 Comparator를 선언해서 sort하면 내림차순으로 정렬이 가능한데, Pair처럼 두개의 값을 비교하는 것이 아니라 단순히 한개의 값을 내림차순으로 정렬되도록 하는 Comparator는 Collections 내에 reverseOrder()이라는 메서드로 정의되어있기 때문에 이를 이용해도 동일한 결과를 볼 수 있다.\n◾ 추가) Integer[]를 int[]로 변환 Integer[] arr = {1,2,3,4,5}; int[] cpyArr = Arrays.stream(arr).mapToInt(Integer::intValue).toArray(); System.out.println(Arrays.toString(cpyArr)); // [1, 2, 3, 4, 5] for문을 이용해도 가능하지만 stream을 이용하면 코드 한줄로 가능하다.\n"},{"section":"Blog","slug":"/blog/java/string/","title":"문자열","description":"Java의 문자열의 내부생성 방식, 자주사용하는 메서드, 문자열정렬에 대해 정리합니다.","date":"2021년 3월 27일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"String 타입을 선언하는 방법 ◾ 리터럴 방식 String str = \u0026#34;Hello\u0026#34;; String str2 = \u0026#34;Hello\u0026#34;; System.out.println(str == str2); //true 편하기 때문에 많이 사용하는 방법으로 큰따옴표(\u0026quot; \u0026quot;)로 바로 할당하는 방법이다.\n이 방법은 내부적으로 JVM메모리에 있는 상수풀에 저장이 되는데 이때문에 같은 문자열을 다른 변수에 선언을 하고 ==연산을 수행하면 true가 나오는 이유가 된다. 내부적으로 상수풀에 등록된 문자열의 reference를 intern을 이용해 호출해 할당하기 때문에 같은 문자열을 참조하고 있기 때문이다.\n◾ 생성자 방식 String도 class이기 때문에 생성자로 선언이 가능하고 생성자로 선언하게 되면 서로 다른 객체가 반환이되기 때문에 같은 문자열이더라도 ==연산시 false가 출력된다.\nbyte[] bytes = { 72, 101, 108, 108, 111 }; String s = new String(bytes); System.out.println(s); //Hello String s1 = new String(\u0026#34;Hello\u0026#34;); System.out.println(s == s1); //false String Class는 내부적으로 byte[] 형태로 문자열을 저장하고 관리하기 때문에 생성자도 byte/char 배열형태로 주면 String이 생성이 되고 생성자 안에 \u0026quot;\u0026quot;로 문자열을 입력할 수도 있다.\n이때 문자열은 상수풀에서 해당 문자열을 복사하여 byte[]로 저장하게 되는데, 이는 리터럴 방식과 똑같은 방식으로 동작하기 때문에 굳이 문자열을 인수로하는 생성자 방식은 수행할 필요가 없다.\nString s1 = new String(\u0026#34;Hello\u0026#34;).intern(); String s2 = new String(\u0026#34;Hello\u0026#34;); System.out.println(s1 == s2.intern()); //true 생성자 생성 방식도 intern()함수를 이용하면 문자열 비교가 true가 될 수 있다.\n특징 ◾ Immutable(불변성) 내부에 선언되어있는 byte[]가 final로 선언이 되어있어 변경이 불가능하다.\n우리가 흔히 쓰는 +=방식의 문자열을 붙이는 것은 내부적으로보면 새로운 객체를 생성해 반환하는 방식이다. 그래서 문자열을 붙이는데 StirngBuilder를 쓰는 것이 속도가 더 빠른 이유인데 StringBuilder는 내부에 관리하는 문자열이 final이 아니라 동적으로 사이즈를 관리하기 때문에 그대로 배열에 이어쓰기 때문이다.\nString 객체의 문자열은 불변성이기 때문에 아래에 기술하는 대부분의 메서드들은 해당 문자열을 변환하는 것이 아니라 기준 메서드를 복사하여 변환해서 새로운 문자열을 반환하는 방식이기 때문에 모두 String형을 return하는 방식인것을 볼 수 있다.\n자주 사용하는 메서드 ◾ equals() String s1 = new String(\u0026#34;Hello\u0026#34;); String s2 = new String(\u0026#34;Hello\u0026#34;); System.out.println(s1 == s2); //false System.out.println(s1.equals(s2)); //false ==와 다르게 String객체 내부의 문자열(byte[]) 값을 비교하는 메서드이다.\npublic static boolean equals(byte[] value, byte[] other) { if (value.length == other.length) { for (int i = 0; i \u0026lt; value.length; i++) { if (value[i] != other[i]) { return false; } } return true; } return false; } 내부함수를 보면 String이 byte배열인 점 을 이용해 한글자씩 비교하고 있는 것을 볼 수 있다.\n◾ length() / isEmpty() 문자열의 길이와 문자열이 비어있는지 검사하여 반환하는 메서드\n◾ toUpperCase() / toLowerCase() 문자열을 모두 대문자/소문자로 변환하는 메서드\n◾ indexOf(int|String ch, (int startIdx)) String s = \u0026#34;Hello\u0026#34;; System.out.println(s.indexOf(\u0026#39;e\u0026#39;)); //1 System.out.println(s.indexOf(101)); //1 System.out.println(s.indexOf(\u0026#34;ll\u0026#34;)); //2 System.out.println(s.indexOf(\u0026#39;a\u0026#39;)); //-1 문자열 내부에서 특정 문자(char)/문자열을 찾아 시작 인덱스를 반환하는 메서드로, 두번째 매개변수로 int를 주면 해당 index부터 검사하여 결과를 반환한다.\n문자/문자열이 없다면 -1을 반환한다.\n◾ substring(int startIdx, (int endIdx)) String s = \u0026#34;Hello\u0026#34;; System.out.println(s.substring(0,1)); //H System.out.println(s.substring(3)); //lo 문자열을 idx로 구분하여 자르고 자른 문자열을 반환하는 메서드로 endIdx를 지정하지 않으면 끝인덱스까지 자르게 된다.\n◾ split(String regex, (int limit)) String s = \u0026#34;Hello Hi 안녕\u0026#34;; String[] array = s.split(\u0026#34; \u0026#34;); System.out.println(Arrays.toString(array)); // [Hello, Hi, 안녕] String[] array = s.split(\u0026#34; \u0026#34;,2); System.out.println(Arrays.toString(array)); // [Hello, Hi 안녕] 문자열을 정규표현식을 기준으로 나누어 Stirng배열로 반환하는 메서드로 두번째 인자로 나눌 배열 개수를 지정할 수 있고 그렇게 되면 앞에서부터 limit개수까지 만 나누어 반환한다.\n◾ replaceAll(String regex, String replacement) String s = \u0026#34;Hello\u0026#34;; s = s.replaceAll(\u0026#34;^.\u0026#34;,\u0026#34;h\u0026#34;); //hello s = s.replaceAll(\u0026#34;[a-z]\u0026#34;, \u0026#34;a\u0026#34;); //aaaaa 문자열에서 정규식을 만족하는 부분들을 replacement로 바꾼 문자열을 반환하는 메서드이다.\n◾ charAt(int index) String s = \u0026#34;Hello\u0026#34;; System.out.println(s.charAt(1)); //e //C++ string s = \u0026#34;Hello\u0026#34;; cout \u0026lt;\u0026lt; s[1]; 문자열을 index로 접근하고 싶을 때 사용할 수 있는 메서드로 C++에서 배열처럼 접근하는 것과 같다.\n◾ toCharArray() String s = \u0026#34;안녕하세요\u0026#34;; char[] array = s.toCharArray(); System.out.println(Arrays.toString(array)); //[안, 녕, 하, 세, 요] 문자열을 char[]로 반환하는 메서드이다.\n◾ compareTo(String anotherString) String s1 = \u0026#34;A\u0026#34;; String s2 = \u0026#34;B\u0026#34;; String s3 = \u0026#34;C\u0026#34;; String s4 = \u0026#34;A\u0026#34;; String s5 = \u0026#34;AA\u0026#34;; System.out.println(s1.compareTo(s2)); //-1 System.out.println(s1.compareTo(s3)); //-2 System.out.println(s2.compareTo(s1)); //1 System.out.println(s3.compareTo(s1)); //2 System.out.println(s1.compareTo(s4)); //0 System.out.println(s1.compareTo(s5)); //-1 두 문자열을 비교하여 사전순으로 기준 문자열이 더크면 양수, 아니면 음수, 같으면 0을 반환한다. (이때 사전순은 결국 ascii코드 값이다.)\n모두 똑같다가 s1,s5와 같이 한개가 문자열의 길이가 더 길다면 문자열이 한개라도 더있는 s5가 더 크다.\n양수 : 기준 문자열이 더 크다. 음수 : 기준 문자열이 더 작다. 0 : 같다. Comparable, Comparator를 정의하는데도 많이 사용된다.\n문자열 정렬 ◾ 오름차순 String s = \u0026#34;hello\u0026#34;; char[] array = s.toCharArray(); Arrays.sort(array); s = new String(array); System.out.println(s); //ehllo Arrays.sort()가 기본이 오름차순정렬인걸 이용해서 toCharArray()로 char[]을 만들어 문자열을 정렬할 수 있다.\n◾ 내림차순 String s = \u0026#34;hello\u0026#34;; String[] array = s.split(\u0026#34;\u0026#34;); Arrays.sort(array, Collections.reverseOrder()); //Collections.reverse(Arrays.asList(array)); //위 방식과 같은 결과를 보여준다. s = String.join(\u0026#34;\u0026#34;,array); System.out.println(s); //ollhe 문자열을 내림차순으로 정렬하고자 위 방법에서 Arrays.sort()에 Comparator속성으로 Collections.reverseOrder()를 주게 되면 array가 Object가 아닌 char[]형이라 컴파일 에러가 난다.\nString형 배열을 선언해 split(\u0026quot;\u0026quot;)으로 각 문자마다 나누어 배열에 저장하고 정렬을 수행하고 join()을 이용해 배열을 붙여주면 문자열을 내림차순으로 정렬이 가능하다.\n"},{"section":"Blog","slug":"/blog/spring/elk/","title":"Spring boot와 EK스택 연결하기","description":"spring boot와 filebeat를 통해 EK스택 연결하기","date":"2021년 3월 24일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/spring/preview_hu740a35c095c653155a0595aa38be9f22_18108_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"200\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/spring\\/preview_hu740a35c095c653155a0595aa38be9f22_18108_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/spring/preview_hu740a35c095c653155a0595aa38be9f22_18108_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/spring\\/preview_hu740a35c095c653155a0595aa38be9f22_18108_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Spring","tags":"Spring, Elastic Search, Logstash, Kibana","content":"현재 진행하고있는 spring boot 프로젝트에 쿼리 통계를 위해 ElasticSearch와 Kibana를 도입하기로 했고 이에 맞게 로깅방법이나 세팅 방법을 기록하기 위해 글을 작성하게 됬다.\ndiagram\r구성은 다음과 같은데 서버로 EC2 프리티어를 사용하고 있어 사양이 안좋기 때문에 서버 내부에 logstash없이 filebeat를 이용하여 로그를 전송하기로 했다. ELK스택으로는 Elastic Cloud 프리티어를 이용해 빠르게 구축하는 것을 테스트해볼 생각이다.\n1. spring boot에 로그 설정 우선, filebeat에서 file을 이용해 log를 감시하게 할 목적이기 때문에 springboot에서 log를 파일로 저장되게 해주어야한다.\nspring boot는 내부에 기본 로깅프레임워크로 logback이 설정되어 있고, slf4j와 bridge모듈을 함께 포함하고 있기 때문에 별도의 라이브러리는 추가해주지 않아도 된다. 그리고 Lombok을 사용중이라면 @Slf4j어노테이션을 붙이면 쉽게 이용이 가능하다.\n1) 라이브러리 추가 log message를 ELK가 읽을 수 있는 json형태의 로그로 변경을 위해 logstash-logback-encoder를 추가해주어야 한다.\n// https://mvnrepository.com/artifact/net.logstash.logback/logstash-logback-encoder implementation group: \u0026#39;net.logstash.logback\u0026#39;, name: \u0026#39;logstash-logback-encoder\u0026#39;, version: \u0026#39;6.3\u0026#39; 2) logback 설정 spring.profiles.active=local logging.config=classpath:logback-${spring.profiles.active}.xml ./src/main/resources/ 에 logback-spring.xml 를 추가하여 logback설정을 해줄 수 있는데 application.properties 파일로 개발/프로덕션 환경에 따른 설정을 해줄 수 도 있다.\n\u0026lt;!--logback-spring.xml--\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;property name=\u0026#34;CONSOLE_LOG_PATTERN\u0026#34; value=\u0026#34;%d{yyyy-MM-dd HH:mm:ss.SSS} %highlight(%-5level) %magenta(%-4relative) --- [ %thread{10} ] %cyan(%logger{20}) : %msg%n\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;LOG_PATH\u0026#34; value=\u0026#34;./logs\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;FILE_NAME\u0026#34; value=\u0026#34;wetayo-logs\u0026#34;/\u0026gt; \u0026lt;appender name=\u0026#34;CONSOLE\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder class=\u0026#34;ch.qos.logback.classic.encoder.PatternLayoutEncoder\u0026#34;\u0026gt; \u0026lt;pattern\u0026gt;${CONSOLE_LOG_PATTERN}\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;appender name=\u0026#34;FILE\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;file\u0026gt;${LOG_PATH}/${FILE_NAME}-json.log\u0026lt;/file\u0026gt; \u0026lt;encoder class=\u0026#34;net.logstash.logback.encoder.LogstashEncoder\u0026#34;/\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;${LOG_PATH}/${FILE_NAME}_%d{yyyy-MM-dd}.%i.log\u0026lt;/fileNamePattern\u0026gt; \u0026lt;maxHistory\u0026gt;90\u0026lt;/maxHistory\u0026gt; \u0026lt;timeBasedFileNamingAndTriggeringPolicy class=\u0026#34;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\u0026#34;\u0026gt; \u0026lt;maxFileSize\u0026gt;10MB\u0026lt;/maxFileSize\u0026gt; \u0026lt;/timeBasedFileNamingAndTriggeringPolicy\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;root level = \u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;CONSOLE\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; RollingFileAppender를 이용하여 file로 log를 저장하며 encoder의 속성으로 logstashEncoder를 주어 자동으로 json포맷에 맞게 변경시켜주도록 설정을 해주었다.\n2. Filebeat 설치 및 설정 1) 설치 나는 EC2에 Ubuntu 20.04를 사용하고 있고, 공식 사이트 를 참고하여 filebeat를 설치 해주었다.\ncurl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.12.0-amd64.deb sudo dpkg -i filebeat-7.12.0-amd64.deb 2) 설정파일 수정 sudo vi /etc/filebeat/filebeat.yml 설치가 완료되었다면 filebeat.yml 파일을 수정하여 input 모듈, output할 logstash/elastic search/kibana를 설정해주어야 한다.\n설정하는 법도 공식 사이트 에 잘 나와있어 개인상황에 맞게 설정해주면 될 것 같다.\ninput filebeat.input: - type: log enabled: true path: \u0026#34;/home/gowoo/logs/*.log\u0026#34; 이번에는 특정 모듈(nginx, mysql\u0026hellip;)들의 로그가 아닌 별도의 로그파일을 input으로 관리할 것이기 때문에 다음과 같이 추가해주었다.\noutput cloud.id: \u0026#34;cloudId\u0026#34; cloud.auth: \u0026#34;username:passwd\u0026#34; 내부/외부 서버에 ELK를 설치하여 사용한다면 각 ip로 설정을 해주면 되고, 나는 Elastic Cloud를 이용하고 있어 cloud:로 쉽게 연결을 할 수 있었다.\n또한, 간단한 로깅이기 때문에 filtering은 필요성을 못느껴 별도의 logstash는 사용하지 않았고 index pattern도 기본인 filebeat-*로 해도 괜찮다고 판단해 추가는 해주지 않았다.\n3) 설정파일 등록(Set up) sudo filebeat setup -e 를 입력하면 설정파일이 등록이 되며 이 단계에서 각종 output이 연결되었는 지 확인하는 등에 작업을 거치게 된다.\n그런데 여기서 \u0026ndash;machine-learning 모듈부분에서 자꾸 에러가 발생했는데 나는 ml기능을 이용하지 않기때문에 이를 제외하고 사용하는 설정만 setup시켜 주었다.\nsudo filebeat setup -e --dashboards --templete //output연결 검사 4) filebeat 실행 sudo service filebeat start sudo service filebeat status start로 실행시키고 status로 정상적으로 enabled되었는지 확인이 가능하다.\n3. Kibana로 확인 logs\r우선 서비스를 돌리고 log를 생성시켜준 후 path로 잡아준 경로에 log파일이 잘생성되었는 지 확인을 해보자.\ndiscover\rlog들은 잘 생성 되었으니, kibana에 접속해 Discover에 index pattern으로 filebeat-*를 검색해보면 다음과 같이 로그들이 수집된 것을 볼 수 있다.\nday\r만일 아무 로그가 보이지 않는다면 기본 설정이 15분전 이므로 데이터가 포함되어있는 기간으로 설정해주면 안보이던 데이터가 보일 것이다.\n1) 나만의 앱 생성 메뉴에 visualize -\u0026gt; Create visualization -\u0026gt; (다양한 앱들 중 선택) 을 통해 로그를 특정 필터에 맞게 앱을 생성할 수 있다.\npie\r예를 들어 쿼리들의 종류에 대한 분포를 pie로 보여주고자 한다면 Aggregation based의 pie를 선택하고 index pattern 으로 filebeat-*을 이용해 만들 수 있다.\nbucket\r여기서, 나는 logstash를 이용해 쿼리종류들마다 field들을 다르게 추가해준다던지의 작업은 하지 않았기 때문에 filter옵션으로 message의 내용을 filtering해 항목들을 추가해 bucket에 담아 주었다.\nbucket에 담고 update를 하고 날짜 수정을 해주면 이쁘게 잘 보이는 것을 볼 수 있다.\nlogstash 없이 filebeat와 Elastic Cloud를 이용해 쉽게 로그관리를 한번 해보았는데 확실히 Elastic Cloud를 이용하니 쉽게 되고 좋았는데 프리티어가 끝나게 되면, 학생입장으로써 가격이 부담되서 개인 서버로 새로 구축하게 될 것 같다.\nReference https://www.elastic.co/guide/en/beats/filebeat/current/index.html "},{"section":"Blog","slug":"/blog/projects/hugo/pagination/","title":"페이징 기능 추가하기","description":"hugo custome하기2 - hugo 블로그에 pagination처리를 하는 paging기능 추가하기","date":"2021년 3월 10일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/hugo/preview_hu637364512dd31ad226a1f796bce6289e_49062_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"115\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/hugo\\/preview_hu637364512dd31ad226a1f796bce6289e_49062_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/hugo/preview_hu637364512dd31ad226a1f796bce6289e_49062_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/hugo\\/preview_hu637364512dd31ad226a1f796bce6289e_49062_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"Hugo, Github Page","content":"각종 css와 shortcode들을 추가했던 이전 글 에 이어 이번에는 pagination을 추가해보려고 한다.\n저는 각 카테고리의 메인 페이지에서는 해당 카테고리의 글들을 paging처리하여 모두 볼 수 있게 구성을 하고 싶었는 데, 제가 사용하고 있는 docport 테마는 paging처리가 들어있지 않은 테마였다. 그래서 hugo 공식사이트 를 참고하여 적용시킨 방법을 공유하려고 한다.\n1. pagination.html작성 우선 **/latyouts/partials/**에 pagination.html을 생성해준다. 지난 번에 설명한것 처럼 이 경로에 파일을 추가해주면 해당 내용을 테마폴더의 내용을 오버라이딩하는 방식으로 적용이 된다. 현재 저는 theme파일에도 해당 이름의 파일은 존재하지 않기때문에 바로 적용이 된다.\n파일을 생성했으면 다음과 같이 파일을 작성해주면 된다.\n{{ $paginator := .Paginate (where .Data.Pages \u0026#34;Type\u0026#34; .Section ) }} \u0026lt;div class = \u0026#34;content\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;page\u0026#34;\u0026gt; {{ range $paginator.Pages }} \u0026lt;div class = \u0026#34;content-page\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{.RelPermalink}}\u0026#34; \u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ if gt .WordCount 0 }} \u0026lt;p\u0026gt;{{ slicestr .Summary 0 100 }} ...\u0026lt;/p\u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;!-- PAGE NUMBERS 그리는 부분 --\u0026gt; {{ $paginator := .Paginator }} {{ $adjacent_links := 2 }} \u0026lt;!-- $최대 표시 가능한 페이지 개수 = ($adjacent_links * 2) + 1 --\u0026gt; {{ $max_links := (add (mul $adjacent_links 2) 1) }} \u0026lt;!-- 하한 페이지 = $adjacent_links + 1 --\u0026gt; {{ $lower_limit := (add $adjacent_links 1) }} \u0026lt;!-- 상한 페이지 = $paginator.TotalPages - $adjacent_links --\u0026gt; {{ $upper_limit := (sub $paginator.TotalPages $adjacent_links) }} \u0026lt;!-- 해당 카테고리의 글이 있을때만 페이지를 render --\u0026gt; {{ if gt $paginator.TotalPages 1 }} \u0026lt;div class = \u0026#34;pagination-container\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;pagination\u0026#34;\u0026gt; \u0026lt;!-- 이전 페이지로 이동 버튼 --\u0026gt; {{ if $paginator.HasPrev }} \u0026lt;li class=\u0026#34;page-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ $paginator.Prev.URL }}\u0026#34; class=\u0026#34;page-link\u0026#34;\u0026gt; « \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;!-- 페이지 숫자 표시 부분 --\u0026gt; {{ range $paginator.Pagers }} {{ $.Scratch.Set \u0026#34;page_number_flag\u0026#34; false }} \u0026lt;!-- 현재 표시한 페이지 번호보다 페이지수가 더 많을 경우 --\u0026gt; {{ if gt $paginator.TotalPages $max_links }} \u0026lt;!-- 하한 페이지 수(1-3)보다 작을때 --\u0026gt; {{ if le $paginator.PageNumber $lower_limit }} \u0026lt;!-- hugo의 .Scratch를 이용해 렌더한 page번호가 max보다 작다면 기본설정이 false로 되어있는데 true로 변경 --\u0026gt; {{ if le .PageNumber $max_links }} {{ $.Scratch.Set \u0026#34;page_number_flag\u0026#34; true }} {{ end }} \u0026lt;!-- 상한 페이지수 보다 클 때 --\u0026gt; {{ else if ge $paginator.PageNumber $upper_limit }} {{ if gt .PageNumber (sub $paginator.TotalPages $max_links) }} {{ $.Scratch.Set \u0026#34;page_number_flag\u0026#34; true }} {{ end }} \u0026lt;!-- Middle pages. --\u0026gt; {{ else }} {{ if and ( ge .PageNumber (sub $paginator.PageNumber $adjacent_links) ) ( le .PageNumber (add $paginator.PageNumber $adjacent_links) ) }} {{ $.Scratch.Set \u0026#34;page_number_flag\u0026#34; true }} {{ end }} {{ end }} \u0026lt;!-- Simple page numbers. --\u0026gt; {{ else }} {{ $.Scratch.Set \u0026#34;page_number_flag\u0026#34; true }} {{ end }} \u0026lt;!-- 페이지 번호 출력 --\u0026gt; {{ if eq ($.Scratch.Get \u0026#34;page_number_flag\u0026#34;) true }} \u0026lt;!-- 현재 페이지라면 page-item-active로 --\u0026gt; {{ if eq . $paginator }} \u0026lt;li class=\u0026#34;page-item-active\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .URL }}\u0026#34; class=\u0026#34;page-link\u0026#34;\u0026gt; {{ .PageNumber }} \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ else }} \u0026lt;li class=\u0026#34;page-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .URL }}\u0026#34; class=\u0026#34;page-link\u0026#34;\u0026gt; {{ .PageNumber }} \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} {{ end }} {{ end }} \u0026lt;!-- 다음 page 버튼. --\u0026gt; {{ if $paginator.HasNext }} \u0026lt;li class=\u0026#34;page-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ $paginator.Next.URL }}\u0026#34; class=\u0026#34;page-link\u0026#34;\u0026gt; » \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 1) 코드 설명 코드만 보면 굉장히 어려워 보일 수 있는데 지금부터 간단하게 핵심만 설명해보겠다.\n{{ $paginator := .Paginate (where .Data.Pages \u0026#34;Type\u0026#34; .Section ) }} \u0026lt;div class = \u0026#34;content\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;page\u0026#34;\u0026gt; {{ range $paginator.Pages }} \u0026lt;div class = \u0026#34;content-page\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{.RelPermalink}}\u0026#34; \u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ if gt .WordCount 0 }} \u0026lt;p\u0026gt;{{ slicestr .Summary 0 100 }} ...\u0026lt;/p\u0026gt; {{ end }} \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; 위의 코드부분에서 .Section을 통해 현재 url을 통해 카테고리를 받아와 해당 폴더 밑에 있는 페이지들을 불러와 글 요약 표시를 div로 감싸 만들어 주었고, if gt .WordCount 0 부분은 내용이 없는 페이지를 그리려고 하면 그 밑의 .Summary가 null 이라 error가 발생하기 때문에 다음과 같이 조건문을 추가해 에러를 방지했다.\n{{ slicestr .Summary 0 100 }} 부분을 통해 내용을 요약 하여 보여주도록 했다. 해당 코드 아래부분은 모두 pagination의 핵심 기능인 page버튼을 그리는 부분이며 최대 표시가능 한 페이지 개수를 설정해 조금 더 똑똑한 paging처리를 해주었다.\n{{ $adjacent_links := 2 }} \u0026lt;!-- $최대 표시 가능한 페이지 개수 = ($adjacent_links * 2) + 1 --\u0026gt; {{ $max_links := (add (mul $adjacent_links 2) 1) }} adjacent_links가 2이면 최대 표시가능한 페이지 개수가 5이다. 만약 더 늘리거나 줄이고 싶으시면 이를 변경하면 되고 3,5,7 같이 홀수로 바뀌게 됩니다.\n\u0026lt;!-- 페이지 번호 출력 --\u0026gt; {{ if eq ($.Scratch.Get \u0026#34;page_number_flag\u0026#34;) true }} \u0026lt;!-- 현재 페이지라면 page-item-active로 --\u0026gt; {{ if eq . $paginator }} \u0026lt;li class=\u0026#34;page-item-active\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .URL }}\u0026#34; class=\u0026#34;page-link\u0026#34;\u0026gt; {{ .PageNumber }} \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ else }} \u0026lt;li class=\u0026#34;page-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .URL }}\u0026#34; class=\u0026#34;page-link\u0026#34;\u0026gt; {{ .PageNumber }} \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} {{ end }} 이 부분은 실제로 페이지 번호를 그리는 부분으로 if eq . $paginator 를 통해 현재 페이지 번호와 그렇지 않은 페이지를 구분해 class 명을 작성해 주었다.\n이렇게 해준 이유는 클래스명에 따라 현재 페이지의 css속성을 다르게 하여 가시성을 좋게 하기 위함이다.\n2. paination.html을 layout내에 추가 이렇게 작성한 pagination.html을 실제 content를 그리는 layout에 추가해주어야 실제로 render가 되기 때문에 main content를 그리는 layout에 추가해주면 된다.\n저의 테마는 body-article-content.html 이 실제 내용의 부분이기 때문에 해당 파일의 적절한 부분에 다음과 같이 추가해 주었다.\n\u0026lt;!-- pagination --\u0026gt; {{if (in .Params.page \u0026#34;true\u0026#34;)}} {{ partial \u0026#34;pagination.html\u0026#34; . }} {{end}} {{ partial \u0026ldquo;pagination.html\u0026rdquo; . }} 이 실제로 해당 html을 추가해 그리는 부분인데 그 앞에 if문을 추가해주어야 에러가 발생하지 않는다.\n조건문이 없다면 페이징이 적용되지 않는 페이지들, 예를 들어 실제 포스팅하는 글들도 해당 레이아웃을 이용하고 이런 페이지에는 sub page가 존재하지 않기 때문이다. 그래서 글 작성시 파라미터로 paging을 처리할 페이지임을 명시하고 이 파리미터가 true라면 paging처리를 하도록 해주어야 한다. (이 부분때문에 에러가 발생했었는데 해결하는데 정말 많은 골머리를 앓았었다\u0026hellip;)\n3. paging처리할 페이지에 파라미터 추가해주기 md파일 상단에 active: - page의 파라미터를 추가해주면 쉽게 적용이 된다.\n--- title: 페이징 예시 페이지 date: 2021-02-02T01:15:40+09:00 Description: \u0026#39;페이징 예시 페이지 입니다\u0026#39; weight: 1 images: hide: - breadcrumb - comment - nextpage active: - page //다음과 같이 파라미터를 추가 해주면 되고 page기능을 사용안한다면 생략하면 된다. --- 4. config.toml / config.yml 파일 수정 한 페이지에 최대 출력하는 글의 개수는 기본 10으로 설정되어있는데 이를 변경하고자 하면, 해당 설정파일에 paginate = 6과 같이 설정을 해주면 쉽게 변경이 가능하다.\n그리고 이제 build를 해보면 페이징이 추가된 것을 볼 수 있을 것이다.\n하지만 기대했던과는 다른 모양인 리스트형태의 페이징이 되었는 데 이는 css 설정을 안해 주었기 때문에 css만 추가해주면 간단하게 해결이 된다.\n5. css 추가 위의 코드를 그대로 이용하여 만들었다면 제가 설정한 클래스이름대로이기 때문에 아래의 css 파일을 /static/css 밑에 하나 만들어 추가해주고 커스텀해서 사용하면 된다.\narticle section.page div.content div.pagination-container { text-align: center; margin: 25px auto; width: 100%; } article section.page div.content div.pagination-container ul.pagination { display: inline-flex; width: auto; list-style: none; border-radius: 0.25rem; } article section.page div.content div.pagination-container ul.pagination li.page-item a.page-link { position: relative; display: block; padding: 0.5rem 0.75rem; margin-left: -1px; line-height: 1.25; color: #027f51; background-color: #fff; border: 1px solid #dee2e6; } article section.page div.content div.pagination-container ul.pagination li.page-item .page-link:hover { z-index: 2; color: #0056b3; text-decoration: none; background-color: #e9ecef; border-color: #dee2e6; } article section.page div.content div.pagination-container ul.pagination li.page-item-active a.page-link { position: relative; display: block; padding: 0.5rem 0.75rem; margin-left: -1px; line-height: 1.25; color: #fff; background-color: #027f51; border: 1px solid #dee2e6; } article section.page div.content div.pagination-container ul.pagination li.page-item-active .page-link:hover { z-index: 2; color: #0056b3; text-decoration: none; background-color: #dee2e6; border-color: #e9ecef; } article section.page div.content div.pagination-container ul.pagination li.page-item .page-link:focus { z-index: 3; outline: 0; box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); } article section.page div.content div.pagination-container ul.pagination li.page-item:first-child .page-link { margin-left: 0; border-top-left-radius: 0.25rem; border-bottom-left-radius: 0.25rem; } article section.page div.content div.pagination-container ul.pagination li.page-item:last-child .page-link { border-top-right-radius: 0.25rem; border-bottom-right-radius: 0.25rem; } 그리고 해당 css파일을 헤더에서 load해주면 되는데 페이지네이션 기능이 없는데 굳이 css파일을 로드할 필요가 없으므로 /layouts/partials/head.html 에 아래와 같이 추가해주면 적용이 된다.\n\u0026lt;!-- pagination --\u0026gt; {{if (in .Params.active \u0026#34;page\u0026#34;)}} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#39;{{\u0026#34;/css/pagination.css?ver=1\u0026#34; | relURL}}\u0026#39; /\u0026gt; {{end}} 6. 결과 결과\r위처럼 정상적인 페이지 버튼의 모습의 페이징이 추가된 것을 볼 수 있다.\n다음과 같이 적용했는데 css모습이 그대로인 경우가 있는데, css 캐싱기능 때문에 서버에서 가져오는 것이 아니라 웹캐시에서 이전에 저장된 css데이터를 불러와 css적용이 안될 수가 있다. 이때는 인터넷 설정에서 쿠키 및 사이트 데이터를 초기화 시켜주면 간단하게 해결이 된다.\n7) 처음, 마지막 페이지 이동 버튼 추가하기 \u0026lt;!-- First page. --\u0026gt; {{ if ne $paginator.PageNumber 1 }} \u0026lt;li class=\u0026#34;page-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;page-link\u0026#34; href=\u0026#34;{{ $paginator.First.URL }}\u0026#34;\u0026gt; «« \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;!-- Last page. --\u0026gt; {{ if ne $paginator.PageNumber $paginator.TotalPages }} \u0026lt;li class=\u0026#34;page-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ $paginator.Last.URL }}\u0026#34; class=\u0026#34;page-link\u0026#34;\u0026gt; »» \u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} 다음과 같이 두개의 코드 부분을 페이지 버튼 그리는 가장 윗 부분, 마지막 부분에 추가해주면 처음/마지막 페이지로 이동하는 버튼이 쉽게 추가가 가능하다.\n설명은 여기까지이며 마음에 드는 테마를 고르고 봤더니 페이징기능이 없어 다른 테마로 옮겨야 하나 고민했던 나와 비슷한 분들에게 많은 도움이 되면 좋겠다.\nReference https://gohugo.io/variables/page/ https://glennmccomb.com/articles/how-to-build-custom-hugo-pagination/ "},{"section":"Blog","slug":"/blog/projects/spring-graphql/start/","title":"GraphQL 서버 구축하기","description":"Spring boot로 Restful API가 아닌 GraphQL 서버 구축하기","date":"2021년 3월 9일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/spring-graphql/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"420\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/spring-graphql\\/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/spring-graphql/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/spring-graphql\\/preview_hu1114fde99ccfd41396a45fe4331f0bda_13589_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"Spring boot, Graphql, Spring Graphql","content":"이번에 버스 공공api를 이용해 현재 gps를 기반으로한 승차 예약 시스템 프로젝트를 진행중에 있는데, 이때의 구축과정기를 작성하려고 한다.\n1. Spring boot에 GraphQL적용 이유 우선, nodeJS를 이용하면 조금 더 편하게 구현할 수 있었을 텐데 그것이 아닌 Spring boot를 이용해서 GraphQL을 사용하는 이유가 프로젝트를 진행하면서 처음 팀원간 합의 할때는 Rest하게 만들 생각이었고, nodeJS는 사용을 저만 해보았기 때문에 Spring boot로 처음 프로젝트를 시작 했다.\n그런데, 이미 공공 api에서 DB형태(테이블과 그에 대한 컬럼들)를 제공해주고 우리가 구현할 기능은 많지않았고 그 또한 select하는 쿼리가 대부분의 일이었으며 실제 서비스에 이 많은 컬럼들이 필요하지 않아 쉽게 필요한 데이터만 가져다 쓸 수 있는 형태인 graphQL방식을 사용하기로 했다.\n정류장에 속한 각 버스를 구분하는데에는 하나의 key값이 아닌 정류장id, 버스노선id 두개의 키가 복합키로 구분하는 형태이고 이를 REST한 방식으로 설계하면 url이 지저분해질 것 같다고 판단이 되어 graphQL방식을 채택했다.\n2. Spring boot에 GraphQL적용하기 1) 라이브러리 추가 처음에 spring boot에서 사용가능한 라이브러리를 찾는데 애를 많이먹었는데 찾고 보면 업데이트를 안한지 오래된 라이브러리이거나 설명문서가 빈약한 경우가 대부분이었기 때문이었다.\n그러다가 graphql-java-kickstart 라는 라이브러리를 찾았고, 들어가서 보면 spring boot뿐만이 아닌 java 생태계에서 사용가능한 여러 프로젝트를 진행하고 있는 것을 볼 수 있다.\njava-graphql이라는 라이브러리를 시작으로 java생태계에서 graphQL서버 기능을 수행할 수 있는 기능들을 제공하는 프로젝트로 commit이 최근까지 존재해서 선택을 했다.\n해당 github에 들어가면 의존성 추가 방법이 나와있는데 나는 gradle로 프로젝트를 진행하였기 때문에 다음과 같이 추가해주었다.\nrepositories { jcenter() mavenCentral() } dependencies { //...다른 라이브러리 implementation \u0026#39;com.graphql-java-kickstart:graphql-spring-boot-starter:11.0.0\u0026#39; implementation \u0026#39;com.graphql-java-kickstart:playground-spring-boot-starter:11.0.0\u0026#39; testImplementation \u0026#39;com.graphql-java-kickstart:graphql-spring-boot-starter-test:11.0.0\u0026#39; } graphql-spring-boot-starter : Query, Mutation등 다양한 graphQL 클래스,인터페이스를 제공하는 라이브러리 playground-spring-boot-starter : graphql test tool인 playground를 이용하기위한 라이브러리 graphql-spring-boot-starter-test : test code작성을 위해 여러가지 어노테이션을 제공하는 라이브러리 dependencies { // to embed Altair tool runtimeOnly \u0026#39;com.graphql-java-kickstart:altair-spring-boot-starter:11.0.0\u0026#39; // to embed GraphiQL tool runtimeOnly \u0026#39;com.graphql-java-kickstart:graphiql-spring-boot-starter:11.0.0\u0026#39; // to embed Voyager tool runtimeOnly \u0026#39;com.graphql-java-kickstart:voyager-spring-boot-starter:11.0.0\u0026#39; // testing facilities } 이 외에도 해당 프로젝트는 GraphiQL, Voyager등 다양한 graphQL서버를 제공한다.\n3. properties 설정 graphql.servlet.mapping=/graphql graphql.tools.schema-location-pattern=**/*.graphqls graphql.servlet.cors-enabled=true graphql.servlet.max-query-depth=100 graphql.servlet.exception-handlers-enabled=true application.properties 나 .yaml 파일에 graphql 설정을 해줄 수 있고 여기서 mappin의 값이 url의 endpoint가 된다.\n4. 스키마 작성 grpahQL은 하나의 엔드포인트에 조회를 담당하는 Query와 삽입/수정/삭제를 담당하는 Mutation으로 나뉜다.\n해달 라이브러리는 .graphqls 라는 파일 형식을 통해 스키마를 선언해 주면 된다.\nschema { query: Query } type Query { getStations(gpsY: Float!, gpsX: Float!, distance: Float!): [Station] } type Station { stationId: Int! stationName: String! mobileNumber: String! distance: Int! } gps의 위도,경도와 찾고자하는 반경거리를 매개변수로 주어지면, 그에 속하는 정류장 정보(id,이름,모바일번호, 현재위치와의 거리)를 받는 Query문이 들어있는 main/resources/ 밑에 graphql폴더를 생성해주고 query.graphqls 를 작성해 주었다.\n5. GraphQLQueryResolver 작성 해당 라이브러리에서는 Query에 GraphQLQueryResolver와 GraphQLResolver 두개의 인터페이스를 제공하는 데 GraphQLQueryResolver가 Query의 Root가 되는 역할을 한다.\n이는 내부적으로 graphql-java의 DataFetcher를 활용하여 구현한 더 상위의 라이브러리로 편하게 사용할 수 있도록 제공하는 인터페이스이다.\nDataFetcher가 servlet이라면 Resolver는 Spring MVC의 개념\n@Builder @Entity @Getter @Setter @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode(of = \u0026#34;id\u0026#34;) public class Station { @Id private Integer id; private String stationName; @Column(columnDefinition = \u0026#34;POINT\u0026#34;) @JsonSerialize(using = GeometrySerializer.class) @JsonDeserialize(contentUsing = GeometryDeserializer.class) private Point gps; private String mobileNumber; } @Builder @NoArgsConstructor @AllArgsConstructor @Data public class StationGraphQLDto { @NotNull private Integer stationId; @NotEmpty private String stationName; @NotEmpty private String mobileNumber; @NotNull private Integer distance; } @Component public class WetayoQuery implements GraphQLQueryResolver { private final StationService stationService; private final ModelMapper modelMapper; WetayoQuery(StationService stationService, ModelMapper modelMapper,) { this.stationService = stationService; this.modelMapper = modelMapper; } public List\u0026lt;StationGraphQLDto\u0026gt; getStations(Double x, Double y, Double distance) { List\u0026lt;Station\u0026gt; stations = stationService.getNearByStations(x, y, distance); //근처 정류장 조회 List\u0026lt;StationGraphQLDto\u0026gt; stationDtos = Arrays.asList(modelMapper.map(stations, StationGraphQLDto[].class)); //distance 필드가 포함된 DTO로 맵핑 /*distance 계산*/ int index = 0; for (StationGraphQLDto stationDto : stationDtos) { stationDto.setDistance(GeometryUtil.calculateDistance(x, y, stations.get(index).getGps().getX(), stations.get(index++).getGps().getY())); } stationDtos.sort((o1, o2) -\u0026gt; o1.getDistance().compareTo(o2.getDistance())); return stationDtos; } } Query스키마에 해당하는 메서드는 GraphQLQueryResolver 인터페이스를 상속한 클래스에 작성을 해주면 된다.\n메서드 이름 맵핑 전략은 query 스키마에 get이 붙지 않는 stations로 작성을 해도 GraphQLQueryResolver에서 우선 stations이름의 메서드를 찾고 없으면 각 메서드들에 get을 붙여 getStations가 있는지 확인하여 메서드를 맵핑시켜준다.\n여기 까지 작성하고 어플리케이션을 실행시켜 localhost:8080/playground 에 접속 해보면 다음과 같이 playground 툴 화면이 보이는 것을 확인할 수 있다.\n6. query문 호출해보기 왼쪽 페이지에 query문 양식에 맞게 입력하고 재생버튼을 클릭하면 오른쪽 페이지에 정상적으로 응답이 오는 것을 확인할 수 있다.\n이와 같은 방법으로 Query의 다른 메서드와 Mutation을 추가해주는 방식으로 spring boot에 graphQL을 적용시켜 보았다.\n7. 사용하고 든 생각 처음 시작할때는 제대로 된 문서를 찾기가 힘들어 많은 삽질끝에 구성을 완료했는데, 이렇게 블로그를 작성하며 다시한번 살펴보니 생각보다 별게 없고, 사용법이 간단하다고 느꼈고, 얼마전에 Netflix의 포스팅을 보다가 발견한건데 Netflix에서 제공하는 어노테이션 방식인 DGS 를 사용해봐도 괜찮겠다고 생각이 들었다. (그래도 GraphQL은 JS/TS를 할 줄 안다면 Apollo server가 더 편하게 작성할 수 있지 않을까\u0026hellip;) -\u0026gt; 2022년 현재 spring 공식 프로젝트로 spring graphQL이 추가되었다\u0026hellip;\nReference https://stackoverflow.com/questions/56555001/difference-between-datafetchers-and-resolvers "},{"section":"Blog","slug":"/blog/java/lambda/","title":"함수형 인터페이스와 람다식","description":"Java8의 함수형 인터페이스와 람다식에 대하여 정리합니다.","date":"2021년 3월 1일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"1. 소개 함수형 인터페이스란 추상 메소드가 하나만 선언된 인터페이스이다.\n1) 함수형 VS. 객체지향 Java 개발자에게 익숙한 객체지향 프로그래밍과의 차이를 비교하자면, 값을 취급하는 단위가 어디까지 인지 나눌 수 있다.\nJava 는 값(상태)과 행위를 다루기 위한 기본 단위를 객체로 정의하고, 이 객체를 클래스라는 형태로 구현한다.\n함수형 프로그래밍은 행위(로직)를 값으로 취급한다. 입력에 의해서만 출력이 결정되는 순수 함수를 기본 단위로 정의한다.\n객체지향 → 기능 구현을 위해 필요한 객체를 먼저 설계 함수형 → 기능 단위로 함수를 만들어서 조합\n2) 왜 필요할까? Side-effect 를 제거할 수 있다. 연관관계나 연계성 보다는 기능을 하는 함수를 이용해 Side-effect가 없도록 선언형으로 개발한다. 순수 함수의 조합으로 이루어지기 때문에 결과 값도 변하지 않는다. 예를 들어, 멀티쓰레드 공유자원의 경우 변경이 아닌 복사를 통한 함수 로직 실행으로 결과 값을 얻어 동시성 Side-effect 이슈가 없다. 구조적으로 유연하고 간결해진다. 코드 재사용 단위가 클래스였던 것이 함수 단위로 가능하여 유연한 개발이 가능하다. 복잡한 연계를 줄일 수 있어 구조적으로 간결해진다. 3) 코드를 살펴보자. @FunctionalInterface public interface RunSomething { void doIt(); } 추상 메소드 하나만 정의하면 된다.\n@FunctioanlInterface 어노테이션은 컴파일 시 체크해주기 때문에 명시해주면 명확하다.\n//before public class Foo { public static void main(String[] args) { RunSomething runSomething = new RunSomething() { @Override public void doIt() { System.out.println(\u0026#34;Hello\u0026#34;); } }; } } //after public class Foo { public static void main(String[] args) { RunSomething runSomething = () -\u0026gt; System.out.println(\u0026#34;Hello\u0026#34;); } } Java8 이전에는 이 함수형 인터페이스의 구현체를 만들어서 쓰기 위해 익명 내부 클래스(annonymous inner class)로 정의해서 사용했는데, 람다 표현식을 사용하면 더 간결하게 표현할 수 있다.\npublic class Foo { public static void main(String[] args) { RunSomething runSomething = () -\u0026gt; { System.out.println(\u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;YoungJun\u0026#34;); }; } } 메소드 구현 코드 라인이 많아지면 위와 같이 쓸 수 있다.\nJava에서는 이 함수를 일급 객체로 사용할 수 있다. () -\u0026gt; System.out.println(\u0026ldquo;Hello\u0026rdquo;) 이 행위(함수)의 결과를 변수로 할당할 수 있다.\n위 함수 자체를 리턴 할 수도 있다.\n함수가 함수를 파라미터로 받거나, 함수가 함수를 리턴할 수 있다. → 이를 고차함수라고 하고 고차함수는 순수함수이다.\n순수 함수란 동일 입력, 동일 출력이 원칙이다.\n@FunctionalInterface public interface PureFunction { int doIt(int number); } PureFunction pureFunction = (number) -\u0026gt; number + 10; System.out.println(pureFunction.doIt(1)); System.out.println(pureFunction.doIt(1)); System.out.println(pureFunction.doIt(1)); //print 11 11 11 위처럼 동일 입력, 동일 출력이 보장되어야 Side-effect가 없는 함수형 프로그래밍이다.\n값이 변경될 여지가 있는 경우 함수 외부 상태 값에 의존하는 경우 함수 외부에 있는 값을 변경하는 경우 입력으로 참조값(변수)이 오는 경우 Side-effect가 발생할 수 있다.\n동일 입력-동일 출력을 지향하되, Java 특성 때문에 순수 함수가 보장되지 않을 수 있다. 진짜 함수형 프로그래밍을 구현하려면 순수 함수, 불변성을 잘 고려하자.\nint id = 2; RunSomething runSomething = new RunSomething() { int value = 1; @Override public void doIt(int num){ value++; //함수 내부의 상태를 변화 시키면 -\u0026gt; 순수함수는아니고, 함수형 프로그래밍에는 어긋난다. id++; //이렇게 함수 외의 값이 변화하거나 return num+id; } } 위 코드는 순수 함수형 프로그래밍은 아니지만, 자바에서 가능한 모양의 함수형 프로그래밍이다. 물론 사이드 이펙트의 문제점은 가지고 있으므로, 주의해서 사용해야한다.\n2. 자바에서 제공하는 함수형 인터페이스 java.lang.funcation 패키지에 있다.\n종류 인자 반환 예시 설명 Runnable 기본적인 형태의 인터페이스, 인자와 반환값 모두 없음 Function\u0026lt;T, R\u0026gt; R apply(T t) 함수 조합 용 메소드(andThen, compose) BiFunction\u0026lt;T, U, R\u0026gt; \u0026lt;T, U\u0026gt; R apply(T t, U u) 두 개의 값(T, U)를 받아서 R 타입을 리턴 Consumer void Accept(T t) T 타입을 받아서 아무값도 리턴하지 않는 함수 Supplier T get() 항상 같은 값을 반환 Predicate Boolean boolean test(T t) 함수 조합 용 메소드(And, Or, Negate) UnaryOperator Function\u0026lt;T, R\u0026gt; 의 특수한 형태 입력값 하나를 받아서 동일한 타입을 리턴 BinaryOperator \u0026lt;T, T\u0026gt; BiFunction\u0026lt;T, U, R\u0026gt; 의 특수한 형태 동일한 타입의 입렵값 두개를 받아 리턴 BiConsumer\u0026lt;T, U\u0026gt; \u0026lt;T, U\u0026gt; void Accept(T t, U u) 인자 2개를 받고 리턴하지 않는 함수 BiPredicate\u0026lt;T, U\u0026gt; \u0026lt;T, U\u0026gt; Boolean boolean test(T t, U u) 인자 2개를 받고 Boolean 타입 반환 Comparator \u0026lt;T, T\u0026gt; int 같은 제너릭 타입의 인자 2개를 받고 Integer 반환 객체간의 값을 비교하기 위한 compare 기능 제네릭 타입으로 객체형을 명시한다. 인자는 최대 2개로 설계했다. 이것은 함수를 어떻게 설계하는 것이 좋은지에 대한 가이드라고 볼 수 있음 함수는 한가지의 일만 해야 되며 인자가 2개를 넘어가는 순간 하나 이상의 일을 하고 있을 가능성이 높으므로 다른 부수효과를 일으키지 않도록 어느정도 설계를 강제하는 것 하지만 로직에 어쩔 수 없이 (그런 경우는 거의 없지만) 하나의 함수에서 처리하는게 더 효율적이라면 별도의 DTO 를 정의하고 여기에 값을 담아 인자로 전달하는 방법을 사용 자세한 구현은 java.lang.funcation 에서 확인하면 될 것 같다. 4가지 API 함수형 인터페이스 적절하게 사용\nFunction\u0026lt;T, R\u0026gt; : 작업으로 타입 변환할 때 Consumer : 작업은 하되 딱히 리턴되는 것이 없을 때 Predicate : 작업하면서 true, false 작업이 필요할 때 Supplier : 작업을 지연시켜야할 때 혹은 특정 시점에만 작업될 수 있도록 할 때 3. 람다 표현식 (인자 리스트) → {바디} 내부적으로는 익명 클래스 구현과 같다고 한다. 1) 특징 간결한 코드\n//before int max(int a, int b){ return a \u0026gt; b ? a : b; } //after (int a, int b) -\u0026gt; { return a \u0026gt; b ? a : b; } 멀티스레드환경에서 용이\n람다식은 순수함수로써 같은 입력이라면 항상 같은 출력을 보장하여 Side Effect가 없으며 외부 상태를 변경하지 않기 때문에 병렬환경에서 용이하다.\n지연 연산이 가능\nStreaming/Chaning 이라고 부르는 방식으로 변수값 각각 하나에 대하여 체이닝된 함수를 순서대로 실행한다. 첫 함수에 모든 변수가 실행되고 다음 함수가 실행되는 방식이 아니다. 이런 지연연산을 통해 cpu자원을 아낄 수 있다.\n//홀수인지 체크 public boolean isOdd(int n){ System.out.println(\u0026#34;isOdd : \u0026#34; + n); return n % 2 == 1; } //곱하기 2 public int doubleIt(int n){ System.out.println(\u0026#34;doubleIt : \u0026#34; + n); return n * 2; } //6보다 큰지 체크 public boolean isGreaterThan6(int n){ System.out.println(\u0026#34;is greater than 6 : \u0026#34; + n); return n \u0026gt; 6; } 위와 같은 메서드가 존재할 때 주어진 배열에서 홀수이면서 곱하기 2했을때 6보다 큰 가장 첫번째 숫자를 찾는 로직을 구현한다고 하자.\nint[] arr = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9}; List\u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); for(int n : arr){ if(isOdd(n))list1.add(n); } List\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); for(int n : list1){ list2.add(doubleIt(n)); } for(int n : list2){ if(isGreaterThan6(n)) { System.out.println(list3.get(0)); break; } } //print isOdd : 1 isOdd : 2 isOdd : 3 isOdd : 4 isOdd : 5 isOdd : 6 isOdd : 7 isOdd : 8 isOdd : 9 doubleIt : 1 doubleIt : 3 doubleIt : 5 doubleIt : 7 doubleIt : 9 is greater than 6 : 2 is greater than 6 : 6 is greater than 6 : 10 10 구현 결과 만일 위와같이 코드를 작성한다면 매 함수마다 특정 변수를 모두 loop돌게 된다.\nSystem.out.println(Arrays.stream(arr) .filter(Lambda::isOdd) .map(Lambda::doubleIt) .filter(Lambda::isGreaterThan6) .findFirst().getAsInt()); //print isOdd : 1 doubleIt : 1 is greater than 6 : 2 sOdd : 2 sOdd : 3 doublet : 3 is greater than 6 : 6 isOdd : 4 isOdd : 5 doubleIt : 5 is greater than 6 : 10 10 하지만 위처럼 람다식을 이용하게 되면 지연연산이 수행되면서 체이닝을 끝내는 함수인 findFirst를 만나 더이상 loop을 돌지 않고 끝내는 걸 볼 수 있다.\nfor(int n : arr){ if(isOdd(n) \u0026amp;\u0026amp; isGreaterThan6(doubleIt(n))){ System.out.println(\u0026#34;(End) N is \u0026#34; + n); break; } } 물론 위와 같이 코드를 작성할 수도 있지만 함수의 조건이 많아질 수록 코드의 가독성은 람다보다 떨어지게 될 것이다.\nloan pattern (빌려쓰기 패턴) 적용 가능\n빌려쓰기 패턴? 람다를 입력으로 받는 메서드가 대신해서 자원을 열고 닫는 패턴\nclass Resource{ public Resource(){ System.out.println(\u0026#34;Create resource\u0026#34;); } public void useResource(){ System.out.println(\u0026#34;Use resource\u0026#34;); } public void dispose(){ System.out.println(\u0026#34;Disposing resource\u0026#34;); } } public static void main(String[] args) { Resource resource = new Resource(); resource.useResource(); //자원 사용 resource.dispose(); } 일반적으로 객체를 생성하여 사용하게 되면 그 자원의 관리를 자원을 빌려쓴쪽(사용하는쪽)이 하게되고 만일 Run 타임시에 에러가 발생하여 무조건 자원을 반환해야한다면 자원을 사용하는 코드블럭마다 try~finally로 묶어 dispose해주어야 되기 때문에 코드의 반복이 발생하게 된다.\n이를 아래처럼 람다를 이용하면 자원의 관리를 빌려쓰는쪽이 아닌 빌려주는 쪽(자원의 주체)가 관리할 수 있게 되고 코드의 반복을 피할 수 있다.\npublic class Resource { private Resource() { System.out.println(\u0026#34;Create resource\u0026#34;); } public void useResource() { System.out.println(\u0026#34;Use resource\u0026#34;); } public void dispose() { System.out.println(\u0026#34;Disposing resource\u0026#34;); } public static void withResource(Consumer\u0026lt;Resource\u0026gt; consumer) { Resource resource = new Resource(); try { consumer.accept(resource); } finally { resource.dispose(); } } } public class Lambda { public static void main(String[] args) { Resource.withResource(Resource::useResource); } } 2) 인자 리스트 인자 없을 때 : () 인자 한 개일 때 : (one) / one 인자 두 개이상 일 때 : (onw, two ~) 인자 타입 생략 가능 -\u0026gt; 컴파일러가 추론(infer) 3) 바디 화살표 오른쪽에 함수 본문 정의 여러 줄인 경우 { } 사용 한 줄인 경우 { }, return 생략 가능 4) 변수 캡처 (Variable Capture) Local variable capture\nfinal, effective final인 경우에만 참조 가능 → 아닌 경우 concurrency 문제 발생 가능 effective final (JAVA 8 지원)\n(final) int baseNumber = 10; // final이 없지만 이 변수는 어디서도 변경하지 않는다. 사실상 final인 변수 final 사용하지 않은 변수를 익명 클래스 구현체 또는 람다에서 참조할 수 있다. 람다는 익명 클래스 구현체와 달리 Shadowing 않는다. 참조 익명 클래스는 새로운 Scope를 만들지만 람다는 람다를 감싸고 있는 Scope와 같다. 5) Shadowing [옳은 예]\npublic class ShadowTest { public int x = 0; class FirstLevel { public int x = 1; void methodInFirstLevel(int x) { System.out.println(\u0026#34;x = \u0026#34; + x); System.out.println(\u0026#34;this.x = \u0026#34; + this.x); System.out.println(\u0026#34;ShadowTest.this.x = \u0026#34; + ShadowTest.this.x); } } public static void main(String... args) { ShadowTest st = new ShadowTest(); ShadowTest.FirstLevel fl = st.new FirstLevel(); fl.methodInFirstLevel(23); } } // ---------------------- Output ------------------------------------------- x = 23 this.x = 1 ShadowTest.this.x = 0 [틀린 예]\npublic class Foo { public static void main(String[] args) { Foo foo = new Foo(); foo.run(); } private void run() { int baseNumber = 10; // Lambda Error : run()과 같은 scope 공유 IntConsumer printInt = (baseNumber) -\u0026gt; { System.out.println(i + baseNumber) } // Lambda 내부 Sout부분 오류발생 : 람다는 effective final, final만 사용 가능 baseNumber++; } } [제약사항]\n람다식을 쓴다면 최소한 인터페이스 타입 객체가 생성될 때 타입파라미터가 있어야함\n아무런 정보없이 람다식을 사용하면 타입추론이 어려워서 컴파일 단계에서 에러남 함수형 인터페이스의 메서드가 제네릭 메서드인 경우 호출할 때 어떤 타입인지 알 수 있는 경우 (추론 불가) @FunctionalInterface public interface InvaildFuncInterface { \u0026lt;T\u0026gt; String print(T value); } class InvalidFuncInterfaceUse{ public static void main(String[] args) { /* 호출할 때 value가 비로소 어떤 타입인지 알 수 있음 : 추론 불가 */ //getPrint(1, s -\u0026gt; s.toString()); } public static \u0026lt;T\u0026gt; void getPrint(T value, InvaildFuncInterface invalidFuncInterfaceUse){ System.out.println(invalidFuncInterfaceUse.print(value)); } } 4. 메소드 레퍼런스 람다가 하는 일이 기존 메소드 또는 생성자를 호출하는 거라면, 메소드 레퍼런스를 사용해서 매우 간결하게 표현할 수 있다.\n1) 방법 생성자 참조\nSupplier\u0026lt;String\u0026gt; supplier = () -\u0026gt; new String(); Supplier\u0026lt;String\u0026gt; supplier2 = String::new; String str = supplier.get(); //사용예 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); int[][] arr = list.stream() .map(l -\u0026gt; l.stream() .mapToInt(Integer::intValue) .toArray()) .toArray(int[][]::new); 이때 생성자 참조는 실제 생성자를 이용해 객체를 만든 것이 아니라 말그대로 참조이기 때문에 Supplier의 get(), Function의 apply(), 위 예시의 Stream의 toArray()와 같이 실제로 실행하는 부분에서 생성자를 이용하게 된다.\nStatic Method 참조 Static 메서드 또한 참조가 가능하며 이도 직접적으로 실행하는 메서드를 통해 실행이 가능\nstatic class MethodReference{ public MethodReference() { System.out.println(\u0026#34;hi\u0026#34;); } public static void print(String name){ System.out.println(\u0026#34;hi \u0026#34; + name); } } public static void main(String[] args) { String name = \u0026#34;홍\u0026#34;; MethodReference.print(name); //일반적인 static 메서드 사용 Consumer\u0026lt;String\u0026gt; consumer = MethodReference::print; //static 메서드 참조 consumer.accept(name); } 특정 객체의 Instance Method 참조 특정 객체(인스턴스)의 일반 메서드도 참조\nstatic method와 달리 클래스명::static 메서드명이 아니라 인스턴스명::메서드명과 같은 형태로 참조가 가능하다.\nstatic class MethodReference{ public MethodReference() { System.out.println(\u0026#34;hi\u0026#34;); } public void print(String name){ System.out.println(\u0026#34;hi \u0026#34; + name); } } public static void main(String[] args) { String name = \u0026#34;홍\u0026#34;; MethodReference object = new MethodReference(); //일반적인 객체 메서드 사용 object.print(name); Consumer\u0026lt;String\u0026gt; consumer = object::print; //instance 메서드 참조 consumer.accept(name); } 임의 객체의 Instance Method 참조 정렬에 이용되는 Comparator가 대표적으로 이때는 static 메서드 참조와 동일하게 클래스명::메서드명으로 사용된다.\nString[] names = {\u0026#34;a\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;c\u0026#34;}; Arrays.sort(names, String::compareToIgnoreCase); (a,b) -\u0026gt; int를 리턴하는 형태여야지만, 람다를 사용할 수 있는데 compareToIgnoreCase 의 Comparator 람다식이 작동할 수 있는 이유는 다음과 같다\npublic int compareToIgnoreCase(String str) { return CASE_INSENSITIVE_ORDER.compare(this, str); } 얼핏보기에는 파라미터가 하나라서, 왜 가능한가? 싶겠지만.\n현재 객체인 this와 String parameter에 들어간 Str이 a와 b가 되고 Return으로 int를 리턴해주기 때문에 이것이 임의 객체의 instance Method 참조를 사용하는 방식이다\n5. Deep Dive 🤿 1) byte 코드 비교 //일반적인 함수형 인터페이스 구현 public class Lambda { @FunctionalInterface public interface Functional { public int cal(int a, int b); } public static void main(String[] args) { Functional functional = new Functional() { @Override public int cal(int a, int b) { return a+b; } }; } } //byte 코드 public class ex/Lambda { // compiled from: Lambda.java NESTMEMBER ex/Lambda$Functional NESTMEMBER ex/Lambda$1 // access flags 0x609 public static abstract INNERCLASS ex/Lambda$Functional ex/Lambda Functional // access flags 0x0 INNERCLASS ex/Lambda$1 null null // access flags 0x1 public \u0026lt;init\u0026gt;()V L0 LINENUMBER 11 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.\u0026lt;init\u0026gt; ()V RETURN L1 LOCALVARIABLE this Lex/Lambda; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 17 L0 NEW ex/Lambda$1 DUP INVOKESPECIAL ex/Lambda$1.\u0026lt;init\u0026gt; ()V //Lambda$1의 메서드 호출 ASTORE 1 L1 LINENUMBER 23 L1 RETURN L2 LOCALVARIABLE args [Ljava/lang/String; L0 L2 0 LOCALVARIABLE functional Lex/Lambda$Functional; L1 L2 1 MAXSTACK = 2 MAXLOCALS = 2 } //컴파일러가 생성한 익명 클래스 Lambda$1 class Lambda$1 implements Functional { Lambda$1() { } public int cal(int a, int b) { return a + b; } } 메서드내에서 함수형인터페이스를 override하여 직접 구현하는 방식은 build 했을때 Functional이라는 인터페이스를 이용하여 Lambda$1이라는 익명 클래스를 만들어내어 호출부에서느 Lamda$1의 메서드를 호출하는 것을 볼 수 있다. 내부적으로 익명클래스로 컴파일하여 사용하지 않는 이유는 java8이전의 람다를 사용하기 위한 라이브러리나, 코틀린같은 언어에서 람다를 이와 가티 단순히 익명클래스로 치환하여 사용하기 때문에 이처럼 구현이 되어있다.\n이렇게 익명클래스로 사용할 경우의 문제점은 람다식마다 클래스가 하나씩 생겨나고 항상 새로운 인스턴스로 할당되는 문제가 있을수 있다.\n//람다이용한 함수형 인터페이스 구현 // class version 55.0 (55) // access flags 0x21 public class ex/Lambda2 { // compiled from: Lambda2.java NESTMEMBER ex/Lambda2$Functional // access flags 0x609 public static abstract INNERCLASS ex/Lambda2$Functional ex/Lambda2 Functional // access flags 0x19 public final static INNERCLASS java/lang/invoke/MethodHandles$Lookup java/lang/invoke/MethodHandles Lookup // access flags 0x1 public \u0026lt;init\u0026gt;()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.\u0026lt;init\u0026gt; ()V RETURN L1 LOCALVARIABLE this Lex/Lambda2; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 9 L0 INVOKEDYNAMIC cal()Lex/Lambda2$Functional; [ // handle kind 0x6 : INVOKESTATIC java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; // arguments: (II)I, // handle kind 0x6 : INVOKESTATIC ex/Lambda2.lambda$main$0(II)I, (II)I ] ASTORE 1 L1 LINENUMBER 10 L1 RETURN L2 LOCALVARIABLE args [Ljava/lang/String; L0 L2 0 LOCALVARIABLE functional Lex/Lambda2$Functional; L1 L2 1 MAXSTACK = 1 MAXLOCALS = 2 // access flags 0x100A private static synthetic lambda$main$0(II)I L0 LINENUMBER 9 L0 ILOAD 0 ILOAD 1 IADD IRETURN L1 LOCALVARIABLE a I L0 L1 0 LOCALVARIABLE b I L0 L1 1 MAXSTACK = 2 MAXLOCALS = 2 } 람다를 이용한 방식은 새로운 익명클래스를 생성시키지는 않고 람다를 사용한 메서드를 새롭게 static으로 생성(lambda$main$0)해서 이를 실행하는 것을 볼 수 있다.\nINVOKEDYNAMIC 이란?\nbootstrap영역의 lambdafactory.metafactory()를 호출하는데 이는 Java runtime library의 표준화 메서드로 객체를 어떤방법으로 생성할지 동적으로 결정한다는 의미 (새로, 재사용, 프록시, 래퍼클래스 등). 후에 java/lang/invoke/CallSite를 통해서 객체를 return.\n한마디로 람다가 변환되는 인터페이스의 인스턴스를 반환하는 코드로 한번만 생성되고 재 호출시에는 재사용이 가능하다.\n"},{"section":"Blog","slug":"/blog/java/generic/","title":"제네릭","description":"Java의 제네릭에 대해서 정리합니다.","date":"2021년 2월 24일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법으로 컴파일 시에 더 많은 버그를 탐지할 수 있도록해 코드의 안전성을 더한다.\nC++의 템플릿과 처리 과정이나 방법의 차이점이 존재하지만 타입을 제거기술이라는 개념에서는 비슷하다고 볼 수 도 있다.\nJava 제네릭 컴파일타임에 에러를 검출할 수 있찌만 실제 동작코드는 제네릭을 사용하지 않을때와 동일해 성능도 동일하다. static 변수는 모든 객체가 공유하고, 모든 타입은 Object를 상속해야 하기 때문에 원시형 타입이 사용이 불가능 하다. C++ 템플릿 : 사용하지 않으면 컴파일을 하지 않는다. 컴파일러는 각각 타입에 대해 별도의 템플릿 코드를 생성하기 때문에, static변수를 공유하지 않고, 원시형 타입이 사용가능하다. 1. 장점 강력한 타입 체크 : 런타임이 아닌 컴파일 타임에 에러를 출력한다. 편한 캐스팅 : Object로 선언하여 (Integer) 와 같이 캐스팅을 하지 않아도 컴파일러에 의해 자동으로 형변환이 이루어진다. 코드의 재사용성이 높아진다. (코드 중복 최소화) 2. 제네릭 사용법 public class ExampleArrayList { private int size; private Object[] arr = new Object[5]; public void add(Object val){ arr[size++] = val; } public Object get(int index){ return arr[index]; } } public class GenericTest { ExampleArrayList list; @BeforeEach public void init(){ list = new ExampleArrayList(); list.add(\u0026#34;hi\u0026#34;); list.add(\u0026#34;hello\u0026#34;); } @Test void ObjectList(){ Integer val = (Integer) list.get(0); System.out.println(val); } } 다음과 같이 Object형 배열을 갖는 ArrayList를 만들어 Integer형 배열로 사용하려고 하는데 String을 넣고 사용한다면 컴파일 타임에는 에러가 발생하지 않는데 런타임시 에러가 발생하게 된다.\njava.lang.ClassCastException: class java.lang.String cannot be cast to class java.lang.Integer (java.lang.String and java.lang.Integer are in module java.base of loader \u0026#39;bootstrap\u0026#39;) 누가 Integer배열에 String을 집어넣냐 라고 할 수 있지만 내가 작성한 코드가 아니거나, 시간이 지나면 잊어버리기 때문에 잘못 사용될 수 있고 이를 컴파일 타임에 발견하기 위해 사용하게 된다.\n애초에 Object로 선언하지 않고 Integer, String으로 선언해서 사용하몀 된다는 말도 나올 수 있는데, 파라미터, 반환 각 클래스별 선언을 해주어야하고 그만큼 코드 중복이 발생하게 된다.\n이를 아래와 같이 제네릭을 이용하여 문제를 해결할 수 있다.\npublic class GenericArrayList\u0026lt;T\u0026gt; { private Object[] arr = new Object[5]; private int size; public void add(T val) { arr[size++] = val; } public T get(int idx) { return (T) arr[idx]; } } @Test void GenericListTest(){ GenericArrayList\u0026lt;Integer\u0026gt; genericArrayList = new GenericArrayList\u0026lt;\u0026gt;(); genericArrayList.add(\u0026#34;hi\u0026#34;); genericArrayList.add(\u0026#34;hello\u0026#34;); } Integer의 List에 String을 집어넣으려고 한다면 컴파일타임에 에러가 발생한다.\n3. 제네릭 주요 개념 1) 제네릭에 오는 타입 변수 위의 코드 처럼 T와 같은 변수로 어떤 문자를 사용해도 상관없으나 일반적으로 사용목적에 맞는 특정 문자를 약속으로 사용하고 있다.\nT : type K : key V : value N : number E : element S : 두번째 파라미터 U : 세번째 파라미터 V : 네번째 파라미터 2) 바운디드 타입 (Bounded Type) 타입 변수를 특정 타입에 제한 할 수 있게 한다.\npublic class GenericArrayList\u0026lt;T extends String\u0026gt; { private Object[] arr = new Object[5]; private int size; public void add(T val) { arr[size++] = val; } public T get(int idx) { return (T) arr[idx]; } } public class GenericTest { @Test void boundedTest(){ GenericArrayList\u0026lt;Integer\u0026gt; genericArrayList = new GenericArrayList\u0026lt;\u0026gt;(); } } String으로 제한을 했기 때문에 Integer로 사용하려고 한다면 컴파일타임에 에러를 발생 시킨다.\n3) 와일드 카드 ? 를 일반적으로 와일드 카드라고 부르며, 제네릭 객체를 메서드의 매개변수로 받을 때 데이터 타입에 상관없이 사용하고자 할때 사용할 수 있다\n종류\nUnbounded 와일드카드 타입파라미터를 ?만 사용하는 방법으로 어떤 클래스나 인터페이스 타입이 올 수 있다.\n\u0026lt;?\u0026gt; List\u0026lt;?\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); ==\u0026gt; List\u0026lt;? extends Object\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 위와 같이 내부적으로 Object가 생략된 형태로 타입에 상관없는 메서드를 정의할 때 사용할 수 있다.\nUpperBounded 와일드 카드 \u0026lt;? extends T\u0026gt; T와 그 자손들을 구현한 객체들만 매개변수로 가능하다.\nLowerBounded 와일드 카드 \u0026lt;? super T\u0026gt; T와 그 조상 객체들로만 매개변수로 가능하다.\n4) 제네릭과 와일드카드 타입 파라미터가 의미있게 사용된다면(지금은 타입을 모르지만 정해지면 목적에 맞게 사용) 제네릭 아니면 와일드카드를 사용 (지금도 타입을 모르고 앞으로도 모를 것이다! 할때 사용)\nList의 size, clear등 타입과 상관없는 기능등을 구현하고 add와 같은 타입에 상관있는 기능을 사용하지 않고자 한다면 와일드 카드\n@Test public void example() { List\u0026lt;Integer\u0026gt; integerList = Arrays.asList(1, 2, 3); wildCardExample(integerList); genericExample(integerList); } static void wildCardExample(List\u0026lt;?\u0026gt; list) { list.add(list.get(1)); //컴파일 에러 } static \u0026lt;T\u0026gt; void genericExamplelist(List\u0026lt;T\u0026gt; list) { list.add(list.get(1)); } wildCardExample의 list.add는 타입에 관심이 없기 때문에 add메서드를 사용 못해 컴파일 에러가 난다.\nnull은 가능하다.\n5) 캡쳐 에러 와일드 카드를 사용하는 데 컴파일러가 타입추론을 하지못하거나 구체적인 타입이 필요할때 발생한다.\n해결 방법 제네릭으로 변경 강제적으로 캡쳐하도록 헬퍼클래스 사용 제너릭 와일드 카드 사용없이 Raw type 사용 4. 제네릭 메소드 만들기 public class GeneralClass { public static void \u0026lt;T\u0026gt; genericMethodExample1(T t) { System.out.println(\u0026#34;hi\u0026#34; + t); } } static 옆에 를 붙여 만든 메서드로 위와 같이 사용이 가능하고 주로 일반 클래스에서 특정 메서드만 제네릭하게 만들때 사용한다.\n제네릭 클래스 안에서 메서드를 만들면 그게 제네릭 메서드가 아니냐라고 할 수 있는데 아래의 코드를 돌려보면 에러를 발생하는 것을 볼 수 있다.\npublic class GenericClass\u0026lt;T\u0026gt; { public static void genericMethodExample2(T t) { System.out.println(\u0026#34;hi\u0026#34; + t); } } 에러가 발생하는 이유는 static의 특징과 제네릭의 특징때문인데 제네릭타입은 인스턴스가 생성될 때 결정이 되고, static은 인스턴스 생성과 별도로 메모리에 적재된다.\nstatic으로 선언된 메서드가 메모리에 적재될때 제네릭 타입을 매개변수로 받게 되면 타입을 알 수 없기 때문에 에러가 발생하는 것이다. 반면에 제네릭 메서드는 호출되는 시점에 타입이 결정되기 때문에 에러가 발생하지 않는다.\n5. Genric Type Erasure 제네릭은 눈속임과 비슷하고 코드 작성시점 (컴파일 타임)의 편의성을 위한 기능으로 실제 강력한 타입제한을 하지 않는다.\n타입을 컴파일 타임에만 검사하고 런타임에는 타입 정보를 지워 알 수 없게 하기 때문이다.\nList 가 사실은 List\u0026lt;? extends Object\u0026gt;으로 바뀌게 되고 내부적으로 type casting, Bridge Method등을 제공한다.\n1) 실체화와 실체 불가타입 실체화 : 타입정보를 런타임에 완벽하게 사용할 수 있는 타입\nString[], Number[]와 같은 배열\n실체 불가 타입 : 런타임에는 타입 정보를 갖지않고 컴파일 타임에 타입 소거가 되는 타입\nList, List와 같은 리스트\n런타임에 타입을 추론하는 Array가 아닌 컴파일타임에 타입을 추론하는 List를 제네릭과 함께 사용해야 안전성을 보장 받을 수 있다.\nReference https://chchang.tistory.com/entry/C%EC%9D%98-template%EA%B3%BC-Java-generic-method-%EC%99%80%EC%9D%98-%EA%B3%B5%ED%86%B5%EC%A0%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4%EC%A0%90 https://vvshinevv.tistory.com/55 https://jinbroing.tistory.com/228 https://jyami.tistory.com/99 "},{"section":"Blog","slug":"/blog/java/io/","title":"I/O","description":"자바의 Input과 Ouput에 대해 학습합니다.","date":"2021년 2월 9일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"컴퓨터의 5대 기능인 입력/출력/연산/저장/제어 중 입력(Input)과 출력(Ouput)을 줄여 I/O라고 말한다.\n1. 스트림 / 버퍼 / 채널 기반의 I/O 1) 스트림 입출력을 도와주는 모듈로써 Stream이라는 단어 그대로 흐름을 의미하며, 한 방향으로만 진행하는 단방향통신이다.\n2) 버퍼 일종의 데이터 공간으로 메모리간, 컴퓨터와 사용자간의 속도차이로 생기는 병목현상을 줄이기 위한 공간\n데이터를 쌓아두고 한번에 찾을 수 있는 데이터 공간으로 이를 이용하여 데이터를 입출력하는 방식으로 속도향상을 꾀할 수 있다.\n3) 채널 스트림과 다르게 양방향 통신이 가능한 방법으로 non-blocking/비동기 방식 모두 지원한다.\n버퍼를 통해 데이터를 읽고 쓴다.\nSelector socket과 채널이 연결되어 클라이언트 연결시 스레드를 생성하는 대신 하나의 selector에 여러개의 채널을 생성하여 다수의 클라이언트를 대응할 수 있다.\n2. InputStream과 OutputStream Stream기반의 클래스의 최상위 클래스(추상 클래스) 이다.\n바이트 스트림들이 갖는 메서드가 다음과 같이 존재한다.\n1) InputStream 메서드 메서드 기능 read() 입력 스트림으로부터 1바이트를 읽고 읽은 바이트를 리턴한다. read(byte[] b) 입력 스트림으로부터 읽은 바이트들을 매개값으로 주어진 바이트 배열b에 저장하고 실제로 읽은 바이트 수를 리턴한다. read(byte[] b, int off, int len) 입력 스트림으로부터 len개의 바이트만큼 읽고 매개값으로 주어진 바이트 배열 b[off]부터 len개까지 저장한다. 그리고 실제로 읽은 바이트 수인 len개를 리턴한다. 만약 len개를 모두 읽지 못하면 실제로 읽은 바이트 수를 리턴한다. close() 사용한 시스템 자원을 반납하고 입력스트림을 닫는다. 2) OutputStream 메서드 메서드 기능 write(int b) 출력 스트림으로 부터 1바이트를 보낸다. write(byte[ ] b) 출력 스트림으로부터 주어진 바이트 배열 b의 모든 바이트를 보낸다. write(byte[ ] b, int off, int len) 출력 스트림으로 주어진 바이트 배열 b[off]부터 len개까지의 바이트를 보낸다. flush() 버퍼에 잔류하는 모든 바이트를 출력한다. close() 사용한 시스템 자원을 반납하고 출력 스트림을 닫는다. 3. Byte와 Character 스트림 1) Byte Stream 데이터를 Byte단위로 전송하며 바이트로 구성된 파일인 오디오,이미지,동영상 등을 읽고 쓰는데 적합한 스트림이다.\nInput 종류 클래스 기능 AudioInputStream 오디오 포맷에 특화된 프레임 단위 스트림 입력 ByteArrayInputStream 바이트 배열을 바이트 스트림으로 변환 입력 BufferedInputStream 버퍼를 이용한 바이트 스트림 입력 FileInputStream 파일을 바이트 단위로 읽어들여 바이트 스트림 입력 FilterInputStream 버퍼와 같은 필터에 의한 바이트 스트림 입력 InputStream 바이트 스트림의 입력을 위한 추상 클래스 ObjectInputStream 자바 객체를 직렬화 시켜 읽어들여 스트림으로 변환 PipedInputStream 바이트 스트림을 읽어들여 연결된 PipedOutputStream으로 동시에 전달 SequenceInputStream 서로 다른 InpustStream을 순차적으로 입력하기 위한 클래스 StringBufferInputStream 문자열 스트림 입력을 위한 클래스, JDK 1.1 이후 StreamReader 클래스로 대체되었다. Output 종류 클래스 기능 ByteArrayOutputStream 바이트 스트림을 바이트 배열로 출력 FileOutputStream 바이트 스트림을 바이트 파일로 출력 FilterOutputStream 버퍼와 같은 필터가 추가된 바이트 스트림 출력을 위한 추상 클래스 ObjectOutputStream 바이트 스트림을 직렬화된 객체 형식으로 출력 OutputStream 바이트 출력 스트림을 위한 추상 클래스 PipedOutputStream PipedInputStream의 입력 스트림을 출력 void byteArrayTest(){ byte[] input = {0,1,2,3,4,5,6,7,8,9}; byte[] output = null; byte[] temp = new byte[4]; ByteArrayInputStream inputStream = new ByteArrayInputStream(input); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); int len; try { while ((len = inputStream.read(temp)) != -1){ outputStream.write(temp,0,len); //read함수를 통해 읽은 데이터를 outputStream에 write } output = outputStream.toByteArray(); //OutputStream의 데이터를 output배열에 저장 System.out.println(\u0026#34;output : \u0026#34;+ Arrays.toString(output)); inputStream.close(); outputStream.close(); }catch (IOException e){ e.printStackTrace(); } } inputStream의 read함수가 더이상 데이터를 읽지 못하면 -1을 리턴하는 것을 이용해서 while문을 통해 inputStream을 끝까지 읽을 수 있으며, ByteArray~ 스트림을 이용하여 4바이트 단위로 데이터를 읽고 쓸 수도 있다.\n2) Char Stream 자바는 char형도 2바이트이기 때문에 바이트단위 스트림은 문자열(text)를 전송하는데 적합하지 않을 수 있기 때문에 문자 기반의 스트림을 제공한다.\n클래스명도 뒤에 Stream이 아닌 Reader를 붙여 사용한다.\nInput 종류 (Reader) 클래스 기능 BufferedReader 버퍼를 이용한 문자 스트림 입력 CharArrayReader 문자 배열의 입력 FileReader 파일을 문자 스트림으로 변환해 입력 FilterReader 버퍼와 같은 필터에 의한 문자 스트림 입력 InputStreamReader 바이트 스트림을 문자 스트림으로 변환 LineNumberReader 버퍼를 이용한 문자 스트림 입력, 라인번호 저장 PipedReader 문자 스트림을 읽어들여 연결된 PipedWriter로 동시에 전달 Reader 바이트 입력 스트림을 문자 스트림으로 변환하기 위한 추상 클래스 StringReader 문자열 데이터를 문자 스트림으로 입력 Output 종류 (Writer) 클래스 기능 BufferedWriter 문자 스트림을 버퍼를 이용해 문자열 단위로 출력 CharArrayWriter 문자 스트림을 문자 배열 단위로 출력 FilterWriter 버퍼와 같은 필터가 추가된 문자 스트림 출력을 위한 추상 클래스 OutputStreamWriter 문자 스트림을 바이트 스트림으로 변환 출력 PipedWriter PipedReader에서 전달받은 문자 스트림을 바로 출력 PrintWriter 형식이 있는 Writer 객체를 문자 스트림으로 출력 StringWriter 문자 스트림을 문자열 데이터로 출력 4. 표준 스트림 표준 입출력 장치(콘솔)에 입출력을 위해 자바에서 제공하는 스트림이다.\njava.lang패키지에 System 클래스를 통해 제공한다.\n변수 입출력 기능 System.in Input 콘솔의 데이터를 입력받음 System.out Output 콘솔에 데이터를 출력 System.err Output 콘솔에 에러를 출력 1) 키보드문자 입력 방법 Scanner 이용 Scanner scanner = new Scanner(System.in); Scanner 클래스를 통해 표준입출력장치로 부터 데이터를 받아올 수 있으며 next(), nextLine(), nextByte(), nextDouble\u0026hellip;과 같은 메서드를 통해 읽어 올 수 있다.\nSystem.in.read() 이용 System클래스에서 제공하는 read함수를 이용하여 입력을 받을 수 있으며, 1byte씩만 데이터를 읽어 ascii코드에 해당하는 int형을 리턴하는 함수이다.\nBufferedReader 이용 한문자씩 스트림에서 읽어오는 InputStreamReader를 버퍼를 사용해서 문자열 처리를 편하게 해주는 방법이 있다.\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); String str = bufferedReader.readLine(); bufferedReader.close(); Scanner처럼 데이터 타입에 맞게 파싱해주는 메소드를 따로 제공하지 않기 때문에, Intger.parseInt()와 같은 메서드를 이용해서 형변환을 해주어야 하고 Scanner보다는 빠른 입력처리가 가능하다.\n2) 데이터 출력 방법 모두가 잘 아는 System.out.println(), System.out.print() 등과 같이 System의 메서드를 이용하는 방법이 있는데, 이를 남발하면 시스템 성능 저하의 원인이 될 수 있다.\n다른 방법으로는 BufferReader와 같은 방법으로 BufferedWriter를 이용한 방법이 있다.\nBufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(System.out)); bufferedWriter.write(\u0026#34;Hello\\n\u0026#34;); bufferedWriter.close(); println() 처럼 자동으로 줄바꿈을 해주는 메서드는 따로 존재하지 않기 때문에 개행문자 (\\n)를 직접 입력해주어야 하고, IOException의 예외처리를 해주어야 한다.\n5. 파일 읽고 쓰기 1) 바이트 기반 스트림 (FileStream) FileInputStream, FileOutputStream을 이용한 방법\nvoid FileOutputStreamTest(){ FileOutputStream fileOutputStream = null; FileInputStream fileInputStream = null; try{ fileOutputStream = new FileOutputStream(\u0026#34;src/test/IoTest/outputFile\u0026#34;); for(char ch=\u0026#39;a\u0026#39;; ch \u0026lt;=\u0026#39;z\u0026#39;; ch++){ fileOutputStream.write(ch); } File file = new File(\u0026#34;src/test/IoTest/outputFile\u0026#34;); fileInputStream = new FileInputStream(file); int c; while((c = fileInputStream.read()) != -1){ System.out.print((char) c); } fileInputStream.close(); fileOutputStream.close(); }catch (FileNotFoundException e){ System.out.println(\u0026#34;Not Found file\u0026#34;); }catch (IOException e){ System.out.println(\u0026#34;IO Exception\u0026#34;); } } 2) 문자기반 스트림 FileReader와 FileWriter를 이용하여 사용하는 방법\nvoid fileWriterTest(){ FileWriter fileWriter =null; FileReader fileReader = null; try{ fileWriter = new FileWriter(\u0026#34;src/test/IoTest/fileWriter.txt\u0026#34;); for(int i=0; i \u0026lt; 10; i++){ fileWriter.write(i); } fileWriter.close(); fileReader = new FileReader(\u0026#34;src/test/IoTest/fileWriter.txt\u0026#34;); int c; while((c = fileReader.read()) != -1){ System.out.print(c); } fileReader.close(); }catch (IOException e){ e.printStackTrace(); } } 3) 차이점 FileInputStream/FileOutputStream은 InputStream/OutputStream을 상속받고 있고 FileReader/FileWriter은 Reader/Writer를 상속받고 있다.\n때문에, FileReader/Writer은 바이트를 문자로 변환하여 입출력을 처리하고 FileInput/OutputStream은 1바이트 이상인 한글등을 처리하기 위해서 버퍼를 사용해서 처리해야 한다.\n파일 포인터의 시작 포인트가 다른데 byte방식은 outputStream을 close안해도 input에서 읽을 수 있고 char방식은 close를 안하면 reader로 읽을 수가 없다.\nvoid FileOutputStreamTest(){ FileOutputStream fileOutputStream = null; FileInputStream fileInputStream = null; try{ fileOutputStream = new FileOutputStream(\u0026#34;src/test/IoTest/outputFile.txt\u0026#34;); for(int i=0; i\u0026lt; 10; i++){ fileOutputStream.write(i); } fileInputStream = new FileInputStream(\u0026#34;src/test/IoTest/outputFile.txt\u0026#34;); int c; while((c = fileInputStream.read()) != -1){ System.out.print(c); } fileInputStream.close(); fileOutputStream.close(); }catch (FileNotFoundException e){ System.out.println(\u0026#34;Not Found file\u0026#34;); }catch (IOException e){ System.out.println(\u0026#34;IO Exception\u0026#34;); } } byte방식은 FileOutputStream으로 쓰고나서 close하지 않은 파일을 FileInputStream으로 처음부터 읽는게 가능하다.\nvoid fileWriterTest(){ FileWriter fileWriter =null; FileReader fileReader = null; try{ fileWriter = new FileWriter(\u0026#34;src/test/IoTest/fileWriter.txt\u0026#34;); for(int i=0; i \u0026lt; 10; i++){ fileWriter.write(i); } fileReader = new FileReader(\u0026#34;src/test/IoTest/fileWriter.txt\u0026#34;); int c; while((c = fileReader.read()) != -1){ System.out.print(c); } fileWriter.close(); fileReader.close(); }catch (IOException e){ e.printStackTrace(); } } char방식인 FileReader은 FileWriter로 작성후에 close하지 않은 파일을 읽으려고 하면 파일포인터가 끝을 가리키기 때문에 읽히지 않는다.\n6. 인코딩 byte단위로 입출력하는 FileInputStream/FileOutputStream에서 아스키코드가 아닌 그 외 문자들을 제대로 출력하기 위한 인코딩을 설정해주어야한다.\nReader의 클래스중 하나인 Input/OutputStreamReader를 이용할 수 있다.\n1) InputStreamReader / OutputStreamReader 파일의 인코딩 방식을 지정할 수 있고, 바이트입력 스트림에 연결되어 문자입력스트림인 Reader로 변환시킨다.\nvoid encodingTest(){ try { FileOutputStream fileOutputStream = new FileOutputStream(\u0026#34;src/test/IoTest/encoding.txt\u0026#34;); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream,\u0026#34;utf-8\u0026#34;); outputStreamWriter.write(\u0026#34;안녕하세요\u0026#34;); outputStreamWriter.close(); fileOutputStream.close(); FileInputStream fileInputStream = new FileInputStream(\u0026#34;src/test/IoTest/encoding.txt\u0026#34;); InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream,\u0026#34;utf-8\u0026#34;); int c; while((c = inputStreamReader.read()) != -1){ System.out.print((char) c); } inputStreamReader.close(); fileInputStream.close(); }catch (IOException e){ e.printStackTrace(); } } Reference https://velog.io/@godkimchichi/Java-7-IO-File https://hyeonstorage.tistory.com/248 "},{"section":"Blog","slug":"/blog/java/class/","title":"클래스","description":"Java의 클래스와 생성자, this에 대해 정리합니다.","date":"2021년 2월 1일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"객체 지향의 중심 객체를 정의하는 일종의 틀 같은 것으로 상태(변수) / 행동(메서드)이 있을 수 있다.\n이로 인해 추상화, 캡슐화, 상속, 다형성 등을 가능하게 하여 개발 / 유지보수를 쉽게 해준다.\n1. 클래스 정의하는 방법 class키워드를 통해 클래스를 새로 정의할 수 있다.\nclass Fruit{ private String name; Fruit(String name){this.name = name;} public String getName(){ return name; } } 1) 필드 변수를 뜻하며 두가지 종류가 존재한다.\n인스턴스 변수 : Fruit이라는 객체를 새로 생성할때마다 각각 독립적인 값을 갖는 변수로 heap 영역에 저장 된다. 클래스 변수 : 인스턴스 변수 앞에 static키워드를 붙여 선언한 변수이다. 딱 한번만 선언되는 변수로 static 영역에 할당되어 Fruit이라는 객체는 이 변수를 모두 공유한다. 2) 메서드 어떠한 행동을 정의한 형태로, 필드들을 수정하거나 참조, 반환을 할 수 있다.\n3) 생성자 객체를 생성했을때 사용되는 일종의 메서드로 필드들을 초기화하는데 사용된다.\n4) 접근 제어자 객체 내 정의된 필드, 메서드, 생성자들을 외부에서 접근을 제어하기 위한 키워드로 아래와 같이 4가지가 존재한다.\ndefault는 생략이 가능하다.\n접근 제어자 동일 클래스 동일 패키지 자손 클래스 그 외 public 접근 가능 접근가능 접근가능 접근가능 protected 접근가능 접근가능 접근가능 X default 접근가능 접근가능 X X private 접근가능 X X X 5) 키워드 종류 필드, 메서드, 클래스 앞에 붙을수 있는 키워드들로 해당 키워드의 종류에 따라 기능이나 권한이 달라진다.\n키워드 목적 static 메모리 할당을 한번만 한다. (클래스에 속한다.) final 클래스에 붙을 경우 상속이 불가능하고, 필드/메서드에 붙을 경우 상수로써 수정이 불가능하다. abstract 클래스 붙을 경우 객체 생성이 불가능하고, 이를 상속받아서만 이용이 가능하다. ( 메서드도 추상 클래스에서만 붙을 수 있고 선언만 가능하다.) synchronized 한개의 스레드만 접근이 가능하다. volatile 변수 접근을 캐시가 아닌 메모리로 접근한다. transient 객체 직렬화시 무시한다. 2. 객체 만드는 방법 public class ClassExample{ public static void main(String[] args){ Fruit apple = new Fruit(\u0026#34;apple\u0026#34;); } } new키워드를 이용하여 클래스의 생성자중 적절한 생성자로 객체를 만들어(heap 영역에 할당) 그 주소를 클래스 변수에 저장하는 방식으로 생성이 가능하다.\n이 과정을 인스턴스화한다고 하고 이 클래스 변수(객체)를 인스턴스라고 한다.\n3. 메소드 정의하는 방법 public String getName(){ return name; } 위 와 같이 접근 제어자 / (키워드) / 반환 타입 / 메서드 이름 / 매개변수로 선언 할 수 있고 코드 블럭( {} )를 통해 행동을 정의, 구현 할 수 있다.\n접근 제어자 : 위에서 설명한 접근제어자 4가지 중 한개가 올 수 있다. 키워드 : 이도 마찬가지로 위에서 설명한 키워드중 여러개가 올 수 있으며 없을 수도 있다. 반환 타입 : 함수의 구현부가 종료될때 반환하는 값의 타입을 지정해야 한다. 메서드 이름 : 메서드를 구분하는 이름 매개변수 : 함수에 사용할 매개변수를 정의 할 수 있으며 없을 수도 있고 여러개가 올수도 있다. 4. 생성자 정의하는 방법 class Fruit{ private String name; //Fruit(){} Fruit(String name){this.name = name;} } 반환타입을 빼고 클래스명을 이름으로한 메서드같이 정의할 수 있다.\n이를 정의 하지 않는다면 주석과 같은 기본생성자를 컴파일러가 자동으로 생성해주지만, 매개변수가 있는 타입만 정의시 매개변수가 없는 기본생성자를 자동으로 생성해주지 않으니 기본생성자도 직접 생성해주어야한다.\n5. this 키워드 이해하기 class Fruit{ private String name; private int price; Fruit(){} Fruit(String name){this.name = name;} Fruit(String name, int price){ this(name); this.price = price; } public String getName(){ return name; } public static exStaticMethod(){ System.out.println(this.name); //error } } this는 인스턴스된 객체 자기 자신을 가르키는 키워드로 Fruit이라는 생성자를 보면 name으로 변수명이 중복되지만 this키워드를 통해 객체내의 인스턴스 변수와 지역변수를 구분이 가능하게 한다.\n이런 이유로 static 메서드에서 this를 통한 접근은 불가능하다. static으로 선언하면 클래스에 종속되기 때문에 인스턴스를 갖지 않기 때문이다.\nthis()를 통해 클래스내의 생성자를 호출할 수도 있다.\n6. 과제 Binary Tree와 BFS, DFS 구현 int value, Node left, right를 가지고 있어야 합니다. BinrayTree라는 클래스를 정의하고 주어진 노드를 기준으로 출력하는 bfs(Node node)와 dfs(Node node) 메소드를 구현하세요. DFS는 왼쪽, 루트, 오른쪽 순으로 순회하세요. 코드 보기 Node.java package javaStudy.BinaryTree; public class Node { private int value; private Node left; private Node right; public Node(int value) { this.value = value; this.left = null; this.right = null; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } } BinaryTree.java package javaStudy.BinaryTree; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; public class BinaryTree{ private Node root; private List\u0026lt;Integer\u0026gt; bfsList; private List\u0026lt;Integer\u0026gt; dfsList; public BinaryTree(Node root) { this.root = root; this.bfsList = new ArrayList\u0026lt;\u0026gt;(); this.dfsList = new ArrayList\u0026lt;\u0026gt;(); } public void bfs(Node node){ Queue\u0026lt;Node\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(node); while(!q.isEmpty()){ Node n = q.poll(); bfsList.add(n.getValue()); if(n.getLeft() != null){ q.offer(n.getLeft()); } if(n.getRight() != null){ q.offer(n.getRight()); } } } public void dfs(Node node){ if(node == null) return; dfsList.add(node.getValue()); dfs(node.getLeft()); dfs(node.getRight()); } public void addNode(int value){ Node node = root; Node newNode = new Node(value); if(node == null){ root = newNode; return; } Node p = node; while(node != null){ p = node; node = (node.getValue() \u0026gt; value) ? node.getLeft() : node.getRight(); } if(p.getValue() \u0026gt; value){ p.setLeft(newNode); }else{ p.setRight(newNode); } } public List\u0026lt;Integer\u0026gt; getBfsList() { return bfsList; } public List\u0026lt;Integer\u0026gt; getDfsList() { return dfsList; } } BinaryTreeTest.java package test.BinaryTree; import javaStudy.BinaryTree.BinaryTree; import javaStudy.BinaryTree.Node; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import java.util.Arrays; import java.util.List; public class BinaryTreeTest { BinaryTree binaryTree; Node root; @BeforeEach void init(){ root = new Node(2); binaryTree = new BinaryTree(root); binaryTree.addNode(1); binaryTree.addNode(22); binaryTree.addNode(12); binaryTree.addNode(23); binaryTree.addNode(24); binaryTree.addNode(13); binaryTree.addNode(5); } @Test void bfsTest(){ binaryTree.bfs(root); List\u0026lt;Integer\u0026gt; arrayList = Arrays.asList(2,1,22,12,23,5,13,24); Assertions.assertEquals(arrayList,binaryTree.getBfsList()); } @Test void dfsTest(){ binaryTree.dfs(root); List\u0026lt;Integer\u0026gt; arrayList = Arrays.asList(2,1,22,12,5,13,23,24); Assertions.assertEquals(arrayList,binaryTree.getDfsList()); } } "},{"section":"Blog","slug":"/blog/java/annotation/","title":"어노테이션","description":"자바의 어노테이션과 리플랙션, 어노테이션 프로세서","date":"2021년 1월 31일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"메서드를 오버라이딩 할때 사용했던 @Override와 같이 @ 기호를 사용하는 문법 요소로 Java5부터 등장했다.\n단어의 의미인 주석과는 비슷하지만 다른 역할로써 사용되는데 메서드/클래스 등에 의미를 단순히 컴파일러에게 알려주기 위한 표식이 아닌 컴파일타임 이나 런타임에 해석될 수 있다.\n1) 장점 기존의 자바는 선언적 프로그래밍방식으로 개발을 하면서 각 계층별 설정 데이터들을 XML에 명시했었는데 서비스의 규모가 클 수록 설정양이 많아지고 도메인 처리의 데이터들이 분산되어 있어 수정이 힘들었다.\n어노테이션이 등장하면서 데이터 유효성 검사 등 직접 클래스에 명시해 줄 수 있게되어 수정이 필요할때 쉽게 파악할 수 있게 되었고 어토테이션의 재사용도 가능해졌다.\nAOP(관점 지향 프로그래밍) 을 쉽게 구성할 수 있게 해준다.\n2) 용도 크게 문서화, 컴파일러 체크, 코드 분석과 자동 생성,런타임 프로세싱 용도로 사용될 수 있다. 컴파일 타임에 에러를 발생 시켜 경고하는 목적으로 사용될 수 있고 문서화는 컴파일 시 어노테이션이 붙은 데이터를 수집하여 가능하지만 가장 비중이 낮은 사용법이다.\n유효성 검사와 같은 메타데이터로써 사용되고 reflection을 이용하여 특정 클래스를 주입할 수도 있다.\n메타 데이터\n\u0026ldquo;어떤 목적을 가지고 만들어진 데이터\u0026rdquo; -Karen Coyle-\n한마디로 어떤 데이터를 설명해주는 데이터\nReflection\n반사,투영이 라는 뜻으로 객체를 통해 클래스의 정보를 분석해내는 기법\nClassName, SuperClass, Constructors, Methods, Fields, Annotations \u0026hellip;\n3) 사용 방법 @Override public ListNode remove(int position) { //생략... } //... @Test void removeTest() { //생략... } 사용할 클래스, 메서드, 매개변수등 앞에 붙여주기만 하면 된다.\n4) 분류 Maker 어노테이션 : 멤버 변수가 없고 컴파일러에게 의미를 전달하기 위한 표식으로 사용되는 어노테이션 (ex. @Override ) Single-value 어노테이션 : 멤버로 단일변수를 갖고 데이터를 전달할 수 있는 어노테이션 Full 어노테이션 : 둘 이상의 변수를 갖는 어노테이션으로 데이터를 키 = 값 형태로 전달한다. 1. 빌트인 어노테이션 Java에 내장되어 있는 어노테이션으로 컴파일러를 위한 어노테이션\n1) Override 현재 메서드가 슈퍼 클래스의 메서드를 오버라이드한 것임을 컴파일러에게 명시해준다.\n메서드가 슈퍼클래스에 없다면 에러를 발생시기 때문에 오타와 같은 실수도 잡을 수 있다.\n2) Deprecated 마커 어노테이션으로 다음 버전에 지원되지 않을 수도 있기 때문에 앞으로 사용하지 말라고 경고를 알린다.\n@Deprecated를 붙인 메서드는 IntelliJ에서 사진과 같이 알림을 띄워준다.\n3) SuppressWarning 경고를 제거하는 어노테이션으로 개발자가 의도를 가지고 설계를 했는데 컴파일은 이를 알지 못하고 컴파일 경고를 띄울 수 있기 때문에 이를 제거하는 목적이다.\n4) SafeVarargs Java 7이상에서 사용가능하고 제네릭같은 가변인자 매개변수 사용시 경고를 무시한다\n제네릭?\n사용할 클래스,메서드 내부에서의 데이터타입을 외부에서 지정하는 기법\n5) FunctionalInterface Java 8이상에서 사용가능하고 컴파일러에게 함수형 인터페이스라는 것을 알리는 어노테이션이다.\n함수형 인터페이스?\n1개의 추상 메서드만을 갖고 있는 인터페이스로 10주차에 배운 Runnable이 그 예이다.\n2. 메타 어노테이션 어노테이션에 사용되는 어노테이션으로 어노테이션을 정의(설명)하기 위해 사용된다.\n1) @Retention 어노테이션이 유지되는 기간(Life Time)을 설정하는 어노테이션\npublic enum RetentionPolicy { SOURCE, CLASS, RUNTIME } SOURCE : 소스파일에만 존재하고, 클래스파일에는 존재x, 컴파일러에 의해 버려진다. CLASS : 클래스파일에는 존재하지만 런타임 시에 유지할 필요 없다는 것을 알리고 이 값이 default이다. RUNTIME : 클래스파일에도 존재하고 런타임애 VM에 의해 유지되어 리플랙션을 통해 클래스 파일의 정보를 읽어 처리 가능하다. 2) @Target 어노테이션이 적용가능한 대상(동작 대상)을 지정한다.\n만약 다른 타입이 온다면 컴파일 에러를 띄운다.\n아래와 같은 ElmentType이라는 enum을 통해 지정한다. ( @Target(ElemntType.~)와 같이 사용 )\npublic enum ElementType { TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, ANNOTATION_TYPE, PACKAGE, TYPE_PARAMETER, TYPE_USE, MODULE, @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,essentialAPI=true) RECORD_COMPONENT; } 기존 TYPE : Class, Interface(어노테이션 타입 포함), enum, jdk14에 생긴 record FIELD : 필드 값(프로퍼티), enum 상수값 METHOD : 메서드 PARAMETER : 메서드 파라미터 (매개 변수) CONSTRUCTOR : 생성자 LOCAL_VARIABLE : 지역 변수 ANNOTATION_TYPE : 어노테이션 PACKAGE : 자바 패키지 jdk 1.8 이후 추가 TYPE_PARAMETER : 위의 어노테이션들과는 다르게 선언 주석이 아닌 TYPE 주석이다.\n선언 주석 : 주의사항, 사용방법, 사용처 등 설명 TYPE 주석 : 정수 값이 0보다 커야 한다, null이 아니다 와 같은 값에 대한 정보 제공함으로써 implements, thorws, new 구절에 사용하거나 제네릭에 사용함으로써 외부의 프로젝트에도 적용할 수 있도록 확장한 범위 타입 선언부에 사용이 가능\n//annotation @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_PARAMETER) public @interface ParmeterEx { } //class에 사용 public class AnnotationStudy \u0026lt;@ParmeterEx T\u0026gt; { public void print( T t){} } //method에 사용 public class AnnotationStudy { public \u0026lt;@ParmeterEx T\u0026gt; void print( T t){} } //method에 사용 public class AnnotationStudy { public \u0026lt;@ParmeterEx T\u0026gt; void print(T t) throws @ParameterEx SomthingException{} } //BYTE CODE public class study/AnnotationStudy { // compiled from: AnnotationStudy.java @Lstudy/ParmeterEx;() : CLASS_TYPE_PARAMETER 0, null // access flags 0x0 Ljava/lang/String; name // access flags 0x1 public \u0026lt;init\u0026gt;()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.\u0026lt;init\u0026gt; ()V L1 LINENUMBER 4 L1 ALOAD 0 LDC \u0026#34;default\u0026#34; PUTFIELD study/AnnotationStudy.name : Ljava/lang/String; RETURN L2 LOCALVARIABLE this Lstudy/AnnotationStudy; L0 L2 0 // signature Lstudy/AnnotationStudy\u0026lt;TT;\u0026gt;; // declaration: this extends study.AnnotationStudy\u0026lt;T\u0026gt; MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x1 // signature \u0026lt;R:Ljava/lang/Object;\u0026gt;()V // declaration: void print\u0026lt;R\u0026gt;() public print()V @Lstudy/ParmeterEx;() : METHOD_TYPE_PARAMETER 0, null 컴파일하면서 해당 타입이 무슨 타입인지 분석하여 CLASS_TYPE_PARAMETER / METHOD_TYPE_PARAMETER 로 변환하는 것을 볼 수 있다.\n타입 선언부에 사용이 가능한 Target이므로 아래와 같이 실제 사용하는 부분에는 적용할 수 없다.\npublic class AnnotationStudy { public \u0026lt;T\u0026gt; void print(@ParmeterEx T a){} } MODULE : 모듈\njdk 1.9 이후 추가 TYPE_USE : 선언부 뿐만이 아닌 타입 사용되는 모든곳에 적용이 가능(클래스/인터페이스/내부필드/파라미터/제네릭/지역변수 등)\n@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE) public @interface ParmeterEx { } @ParmeterEx public class AnnotationStudy \u0026lt;@ParmeterEx T\u0026gt;{ @ParmeterEx String name = \u0026#34;default\u0026#34;; @NonNull public \u0026lt;@ParmeterEx R\u0026gt; void print(@ParmeterEx String t, @ParmeterEx R r){ @ParmeterEx int a=1; } } //byte code // class version 61.0 (61) // access flags 0x21 // signature \u0026lt;T:Ljava/lang/Object;\u0026gt;Ljava/lang/Object; // declaration: study/AnnotationStudy\u0026lt;T\u0026gt; public class study/AnnotationStudy { // compiled from: AnnotationStudy.java @Lstudy/ParmeterEx;() @Lstudy/ParmeterEx;() : CLASS_TYPE_PARAMETER 0, null // access flags 0x0 Ljava/lang/String; name @Lstudy/ParmeterEx;() : FIELD, null // access flags 0x1 public \u0026lt;init\u0026gt;()V L0 LINENUMBER 4 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.\u0026lt;init\u0026gt; ()V L1 LINENUMBER 5 L1 ALOAD 0 LDC \u0026#34;default\u0026#34; PUTFIELD study/AnnotationStudy.name : Ljava/lang/String; RETURN L2 LOCALVARIABLE this Lstudy/AnnotationStudy; L0 L2 0 // signature Lstudy/AnnotationStudy\u0026lt;TT;\u0026gt;; // declaration: this extends study.AnnotationStudy\u0026lt;T\u0026gt; MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x1 // signature \u0026lt;R:Ljava/lang/Object;\u0026gt;(Ljava/lang/String;TR;)V // declaration: void print\u0026lt;R\u0026gt;(java.lang.String, R) public print(Ljava/lang/String;Ljava/lang/Object;)V @Lstudy/ParmeterEx;() : METHOD_TYPE_PARAMETER 0, null @Lstudy/ParmeterEx;() : METHOD_FORMAL_PARAMETER 0, null @Lstudy/ParmeterEx;() : METHOD_FORMAL_PARAMETER 1, null L0 LINENUMBER 10 L0 ICONST_1 ISTORE 3 L1 LINENUMBER 11 L1 RETURN L2 LOCALVARIABLE this Lstudy/AnnotationStudy; L0 L2 0 // signature Lstudy/AnnotationStudy\u0026lt;TT;\u0026gt;; // declaration: this extends study.AnnotationStudy\u0026lt;T\u0026gt; LOCALVARIABLE t Ljava/lang/String; L0 L2 1 LOCALVARIABLE r Ljava/lang/Object; L0 L2 2 // signature TR; // declaration: r extends R LOCALVARIABLE a I L1 L2 3 LOCALVARIABLE @Lstudy/ParmeterEx;() : LOCAL_VARIABLE, null [ L1 - L2 - 3 ] MAXSTACK = 1 MAXLOCALS = 4 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 15 L0 RETURN L1 LOCALVARIABLE args [Ljava/lang/String; L0 L1 0 MAXSTACK = 0 MAXLOCALS = 1 } 바이트 코드를 보면 TYPE_USE를 사용해도 컴파일 결과는 컴파일러가 적절한 어노테이션 TARGET으로 바꾸는 것을 볼 수 있다.\n@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE, ElementType.TYPE_USE}) @Retention(RetentionPolicy.CLASS) @Documented public @interface NonNull { } Lombok의 NonNull 어노테이션으로 해당 어노테이션도 Target범위가 TYPE_USE가 포함되어 있다.\njdk 14이후 추가 RECORD_COMPONENT : Record 컴포넌트 3) @documented 어노테이션의 정보가 javadoc의 문서에 포함되도록 하는 어노테이션\n4) @Inherited 자식 클래스에게도 어노테이션이 상속되도록 하는 어노테이션\n5) @Repeatable 어노테이션을 반복적으로 선언할 수 있게 하는 어노테이션\n2. Java8 이후 추가된 특징 1) 중복 사용 가능 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE) public @interface Chicken { String value() default \u0026#34;후라이드\u0026#34;; } //error @Chicken @Chicken(\u0026#34;양념\u0026#34;) public class App() { } 기존에는 위와 같이 같은 어노테이션을 같은범위에 중복해서 정의할 수 없었는데 java8부터는 @Repeatable() 이 추가되어 중복해서 사용이 가능해졌다.\nReapetable은 한개의 value를 가지고 있는데 여기에 일종의 어노테이션 컨테이너 역할을 할 어노테이션 클래스를 넘겨주면 해당 컨테이너에 중복사용한 어노테이션들을 담는 방식으로 동작하게 된다. 이때 주의할 점이 Reapeatable의 value는 어노테이션의 컨테이너 역할이기 때문에 중복해서 사용할 어노테이션보다 생명주기(RetentionPolicy)가 길어야만 한다.\n@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE) public @interface ChickenContainer { Chicken[] value(); } @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE_USE) @Repeatable(ChickenContainer.class) public @interface Chicken { String value() default \u0026#34;후라이드\u0026#34;; } @Chicken(\u0026#34;양념\u0026#34;) @Chicken(\u0026#34;마늘간장\u0026#34;) public class App { public static void main(String[] args) { ChickenContainer chickenContainer = App.class.getAnnotation(ChickenContainer.class); Arrays.stream(chickenContainer.value()).forEach(c -\u0026gt; { System.out.println(c.value()); }); } } //print 양념 마늘간장 //bytecode // class version 59.0 (59) // access flags 0x21 public class javaStudy/Example { // compiled from: Example.java @LjavaStudy/ChickenContainer;(value={@LjavaStudy/Chicken;(value=\u0026#34;\\uc591\\ub150\u0026#34;), @LjavaStudy/Chicken;(value=\u0026#34;\\ub9c8\\ub298\\uac04\\uc7a5\u0026#34;)}) // access flags 0x19 public final static INNERCLASS java/lang/invoke/MethodHandles$Lookup java/lang/invoke/MethodHandles Lookup // access flags 0x1 public \u0026lt;init\u0026gt;()V L0 LINENUMBER 7 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.\u0026lt;init\u0026gt; ()V RETURN L1 LOCALVARIABLE this LjavaStudy/Example; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 9 L0 LDC LjavaStudy/Example;.class LDC LjavaStudy/ChickenContainer;.class INVOKEVIRTUAL java/lang/Class.getAnnotation (Ljava/lang/Class;)Ljava/lang/annotation/Annotation; CHECKCAST javaStudy/ChickenContainer ASTORE 1 L1 LINENUMBER 10 L1 ALOAD 1 INVOKEINTERFACE javaStudy/ChickenContainer.value ()[LjavaStudy/Chicken; (itf) INVOKESTATIC java/util/Arrays.stream ([Ljava/lang/Object;)Ljava/util/stream/Stream; INVOKEDYNAMIC accept()Ljava/util/function/Consumer; [ // handle kind 0x6 : INVOKESTATIC java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; // arguments: (Ljava/lang/Object;)V, // handle kind 0x6 : INVOKESTATIC javaStudy/Example.lambda$main$0(LjavaStudy/Chicken;)V, (LjavaStudy/Chicken;)V ] INVOKEINTERFACE java/util/stream/Stream.forEach (Ljava/util/function/Consumer;)V (itf) L2 LINENUMBER 13 L2 RETURN L3 LOCALVARIABLE args [Ljava/lang/String; L0 L3 0 LOCALVARIABLE chickenContainer LjavaStudy/ChickenContainer; L1 L3 1 MAXSTACK = 2 MAXLOCALS = 2 // access flags 0x100A private static synthetic lambda$main$0(LjavaStudy/Chicken;)V L0 LINENUMBER 11 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 0 INVOKEINTERFACE javaStudy/Chicken.value ()Ljava/lang/String; (itf) INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L1 LINENUMBER 12 L1 RETURN L2 LOCALVARIABLE c LjavaStudy/Chicken; L0 L2 0 MAXSTACK = 2 MAXLOCALS = 1 } ChickenConatiner 어노테이션을 생성하여 Chicken 어노테이션들을 value로 할당하는 것을 볼 수 있다.\nMethodHandles$Lookup라는 이름의 클래스로 innerClass가 만들어지는 것을 볼 수 있는데 이는 메서드 핸들을 생성하기위한 factory class로 ChickenContainer의 value()인 Chicken[]에 접근하기위한 class\n3. 커스텀 어노테이션 IntelliJ의 새로만들기에서 Annotation으로 지정하여 새로 만들수 있다.\n@Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface CustomeAnnotation { String name() default \u0026#34;홍길동\u0026#34;; } 만들게 되면 @interface의 형태로 만들어지고 위의 메타 어노테이션을 붙여 메타 데이터를 표시할 수도 있다.\n@interface 안에 매개변수가 없다면 Maker, 코드와 같이 한개만 존재한다면 Single-value, 두개이상을 갖는다면 Full 어노테이션으로 구분할 수 있고 매개변수의 default값을 다음과 같이 지정해줄 수 도 있다.\npackage javaStudy.CustomAnnotation; public class AnnotationExClass { @CustomAnnotation private String defaultName; @CustomAnnotation(name=\u0026#34;철수\u0026#34;) private String customName; public AnnotationExClass() { this.defaultName = \u0026#34;이름없음\u0026#34;; this.customName = \u0026#34;이름없음\u0026#34;; } public String getDefaultName() { return defaultName; } public String getName2() { return customName; } } 다음과 같이 매개변수 하나는 default로 길동을 하나는 철수를 어노테이션 값으로 갖게하고 생성자로 매개변수의 값은 이름없음으로 생성하는 클래스가 있다고 한다면 아래와 같이 reflect를 활용해서 어노테이션 값에 접근할 수 있다.\n@Test void annotationTest() { AnnotationExClass annotationExClass = new AnnotationExClass(); System.out.println(\u0026#34;defaultName : \u0026#34; + annotationExClass.getDefaultName() + \u0026#34;\\ncustomName : \u0026#34; + annotationExClass.getName2()); Field[] fields = annotationExClass.getClass().getDeclaredFields(); for(Field field : fields){ System.out.print(field.getName() +\u0026#34; : \u0026#34;); Annotation[] annotations = field.getDeclaredAnnotations(); for (Annotation annotation : annotations) { CustomAnnotation customAnnotation = (CustomAnnotation) annotation; System.out.println(customAnnotation.name()); } } } 결과물을 보면 매개변수의 값은 이름없음이지만 각 필드에 할당된 어노테이션의 필드 값은 다른 것을 볼 수 있다.\nhttps://gowoonsori.comimages/java/annotation/result.png does not exist\r만일, 어노테이션에 Retention을 RUNTIME으로 하지 않으면 아래와 같이 런타임시에 동작하는 reflection을 이용해서 값을 불러오지 못한다.\n4. 애노테이션 프로세서 런타임시에 리플랙션을 사용하는 어노테이션과는 달리 컴파일 타임에 이루어진다.\n컴파일 타임에 어노테이션들을 프로세싱하는 javac에 속한 빌드 툴로 어노테이션의 소스코드를 분석하고 처리하기 위해 사용되는 훅이다.\n보일러플레이트 코드를 제거하는데 도움이 된다.\n( AbstractProcessor 를 implements하여 구현체를 만들 수 있으며 Lombok의 @Getter, @Setter와 같은 어노테이션을 이용하는 것만으로도 컴파일 타임에 알아서 getter/setter를 만들어주는 방식으로 보일러플레이트 코드 제거 )\nReference https://hiddenviewer.tistory.com/88 https://stackoverflow.com/questions/2146104/what-is-annotation-processing-in-java http://hannesdorfmann.com/annotation-processing/annotationprocessing101/ https://medium.com/@jason_kim/annotation-processing-101-%EB%B2%88%EC%97%AD-be333c7b913 "},{"section":"Blog","slug":"/blog/projects/react-project/3/","title":"PointRee 프로젝트 3 - back 개발환경 셋팅과 db설계","description":"spring 개발환경 세팅과 db전체적인 설계","date":"2021년 1월 29일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"React","content":"IntelliJ를 이용해서 pointRee폴더 내에 back폴더를 생성해주고 여기에 spring boot 2.4로 프로젝트를 시작했다.\ndependencies { implementation group: \u0026#39;org.springframework.boot\u0026#39;, name: \u0026#39;spring-boot-starter-web\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; //db implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; implementation \u0026#39;org.springframework.boot:spring-boot-starter-validation\u0026#39; implementation \u0026#39;com.h2database:h2\u0026#39; implementation \u0026#39;mysql:mysql-connector-java\u0026#39; //lombok compileOnly \u0026#39;org.projectlombok:lombok\u0026#39; annotationProcessor \u0026#39;org.projectlombok:lombok\u0026#39; } dependency는 위와 같이 추가해주었다.\n1. db설계 포인트의 유효기간을 처음에 생각을 했었으나 db설계와 구현과정에 있어 많은 시간이 생각보다 소요될 것 같아 일단 유효기간이 없다고 생각하고 설계를 진행했다. 완성후 다른곳에 문제가 없다면 차차 추가할 생각이다.\nCREATE TABLE USER ( id bigint NOT NULL AUTO_INCREMENT, --사용자 PK name varchar(20) NOT NULL, --사용자명 email varchar(50) NOT NULL, --로그인 이메일 passwd varchar(80) NOT NULL, --로그인 비밀번호 phone_number varchar(20) NOT NULL, --전화번호 accumulation_rate int NOT NULL DEFAULT 5, --포인트 적립율 role varchar(20) NOT NULL, created_time datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), PRIMARY KEY (id), CONSTRAINT unq_user_email UNIQUE (email) ); CREATE TABLE CUSTOMER ( id bigint NOT NULL AUTO_INCREMENT, --고객 PK user_id bigint NOT NULL, --user FK phone_number varchar(20) NOT NULL, --전화번호 total_point int NOT NULL default 0, --총 포인트 purchase_cnt int NOT NULL default 0, --구매 횟수 created_time datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), PRIMARY KEY (id), CONSTRAINT fk_user_id FOREIGN KEY(user_id) REFERENCES USER (id) ON DELETE CASCADE ON UPDATE CASCADE ); CREATE TABLE ORDERS ( id bigint NOT NULL AUTO_INCREMENT, --구매기록 PK customer_id bigint NOT NULL, --customer FK price int NOT NULL, --가격 accumulation_rate int NOT NULL, --적립율(기본은 유저적립율) save_point int, --적립율과 가격에 따른 적립포인트 payment_type varchar(20) NOT NULL DEFAULT \u0026#39;CASH\u0026#39;, --결제 방법 created_time datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), PRIMARY KEY (id), CONSTRAINT fk_customer_id FOREIGN KEY(customer_id) REFERENCES CUSTOMER (id) ON DELETE CASCADE ON UPDATE CASCADE ); 기능은 많지 않다보니 table 3개로 모두 구현가능 할 것 같아 위와같이 설계를 해주었고 지금은 시작 초기데이터도 몇개 추가해 주었다.\n-- INSERT INTO user(id,name, email, password, phone_number,accumulation_rate,role) VALUES (1,\u0026#39;tester\u0026#39;, \u0026#39;test@test.com\u0026#39;, \u0026#39;$2a$10$mzF7/rMylsnxxwNcTsJTEOFhh1iaHv3xVox.vpf6JQybEhE4jDZI.\u0026#39;, \u0026#39;010-0123-1111\u0026#39;, 5,\u0026#39;ADMIN\u0026#39;); INSERT INTO user(id,name, email, password, phone_number,accumulation_rate,role) VALUES (2,\u0026#39;raon\u0026#39;, \u0026#39;raon@gmail.com\u0026#39;, \u0026#39;$2a$10$mzF7/rMylsnxxwNcTsJTEOFhh1iaHv3xVox.vpf6JQybEhE4jDZI.\u0026#39;, \u0026#39;010-1234-1234\u0026#39;, 10,\u0026#39;USER\u0026#39;); INSERT INTO customer(id,user_id, phone_number, total_point, purchase_cnt,created_time) VALUES (1,1,\u0026#39;010-1111-1111\u0026#39;, 3700, 3,\u0026#39;2021-04-10 20:41:10\u0026#39;); INSERT INTO customer(id,user_id, phone_number, total_point, purchase_cnt,created_time) VALUES (2,1,\u0026#39;010-2222-2222\u0026#39;, 600, 2,\u0026#39;2021-04-10 20:41:10\u0026#39;); INSERT INTO customer(id,user_id, phone_number, total_point, purchase_cnt,created_time) VALUES (3,2,\u0026#39;010-4444-4444\u0026#39;, 5000, 1,\u0026#39;2021-04-10 20:41:10\u0026#39;); INSERT INTO orders(price,save_point, accumulation_rate, payment_type,customer_id,created_time) values (12000, 600, 5, \u0026#39;CASH\u0026#39;, 1,\u0026#39;2021-04-10 20:41:10\u0026#39;); INSERT INTO orders(price,save_point, accumulation_rate,payment_type,customer_id,created_time) values (20000,1000,5, \u0026#39;CASH\u0026#39;, 1,\u0026#39;2021-04-12 20:41:10\u0026#39;); INSERT INTO orders(price,save_point, accumulation_rate,payment_type,customer_id,created_time) values (21000,2100,10, \u0026#39;CARD\u0026#39;, 1,\u0026#39;2021-04-13 20:41:10\u0026#39;); INSERT INTO orders(price,save_point, accumulation_rate,payment_type,customer_id,created_time) values (12000, 600, 5, \u0026#39;CASH\u0026#39;, 2,\u0026#39;2021-04-14 20:41:10\u0026#39;); INSERT INTO orders(price,save_point, accumulation_rate,payment_type,customer_id,created_time) values (100000, 5000, 5, \u0026#39;CARD\u0026#39;, 3, \u0026#39;2021-04-16 20:41:10\u0026#39;); 2. application.yml 설정 spring: application: name: pointree jpa: hibernate: ddl-auto: create-drop properties: hibernate: format_sql: true jdbc: lob: non_contextual_createion: true hikari: minimum-idle: 1 maximum-pool-size: 5 show-sql: true datasource: initialization-mode: always #Server server: port: 8999 http2: enabled: true servlet: encoding: charset: UTF-8 enabled: true force: true #Logging logging: level: org: hibernate: springframework: security: DEBUG type: descrptor: sql: BasicBinder: TRACE 우선은 개발단계이기 때문에 db생성규칙은 create-drop으로 해주었고 port, hibernate logging등 을 설정해 주었고 github에 올릴예정으로 db정보는 아래와 같이 별도의 jdbc.yml을 작성해서 .gitignore에 추가해주었습니다.\nspring: datasource: url: \u0026#34;jdbc:mysql://127.0.0.1:3306/pointree?useUnicode=true\u0026amp;useJDBCCompliantTimezoneShift=true\u0026amp;useLegacyDatetimeCode=false\u0026amp;characterEncoding=UTF-8\u0026amp;serverTimezone=Asia/Seoul\u0026amp;allowPublicKeyRetrieval=true\u0026amp;useSSL=false\u0026#34; username: pointree password: password driver-class-name: com.mysql.cj.jdbc.Driver jpa: database-platform: org.hibernate.dialect.MySQL8Dialect 그리고 test는 좀더 빠른 실행을 위해 임베디드 db로 설정을 해주었습니다.\nspring: datasource: username: sa password: url: \u0026#34;jdbc:h2:mem:pointree;MODE=MYSQL;DB_CLOSE_DELAY=-1\u0026#34; driver-class-name: org.h2.Driver jpa: database-platform: org.hibernate.dialect.H2Dialect h2: console: enabled: true 3. jdbc.yml설정 적용해 실행해보기 @SpringBootApplication public class PointreeApplication { public static void main(String[] args) { new SpringApplicationBuilder(PointreeApplication.class) .properties( \u0026#34;spring.config.location=\u0026#34; + \u0026#34;classpath:/application.yml,\u0026#34;+ \u0026#34;classpath:/jdbc.yml\u0026#34;).run(args); } } IntelliJ의 실행 환경변수로 추가해줄 수도 있지만, terminal로 실행시킬때 매번 해주기 귀찮아 main함수에 위와 같이 config 경로를 설정해주고 실행을 했습니다.\n그러면 실행터미널에 우리가 앞에 생성해주었던 schema대로 table이 만들어지고 data가 만들어지는 것을 볼 수 있다.\n"},{"section":"Blog","slug":"/blog/java/junit5/","title":"Junit5","description":"Junit 5의 개념, 기본 어노테이션과 예제를 통해 복습해봅니다","date":"2021년 1월 25일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"자바 프로그래밍용 Unit 테스트 프레임워크\n런타임시 Java 8이상이 필요하며 컴파일 타임시에 JAR로서 링크된다.\nSpring Boot를 이용하면 내부에 dependency가 포함되어 있다.\n1. 구조 JUnit Platform : 테스트를 발견하고 계획을 생성하는 TestEngine 인터페이스를 갖고 있다.\n이를 통해 테스트를 발견,실행,보고한다.\nJUnit Jupiter : TestEngine의 실제 구현체는 별도 모듈중 하나로 Juptier-API를 이용한 테스트 코드를 발견하고 실행\nJupiter API는 JUnit5에 새롭게 추가된 테스트 코드용 API\nJUnit Vintage : 기존 버전으로 작성한 테스트 코드를 실행할때 이 모듈을 이용\n2. Assertion Assertion은 기본적인것만 제공하기 때문에 AssertJ와 같은 것들을 추가로 사용할 수도 있다.\nassertThat / assertTrue : 전제조건 검증 assertAll() : 전체 실행 assertThrows/assertDoesNotThrow() : 예외상태 검증 assertTimeout() : 타 3. 어노테이션 1) @Ignore 테스트로 안쓰이는 클래스\n테스트내 중복 코드제거를 위해 클래스 상속을 이용하여 만들때 사용해주어야한다.\n2) @Test 테스트 메서드 임을 알리는 어노테이션\n3) @ParameterizedTest 매개 변수화 된 테스트\n4) @TestFactory 동적 테스트를 위한 테스트 팩토리\n5) @DisplayName 해당 테스트 클래스 or 메서드의 console에 보여지는 이름을 정의\n6) @DisplayNameGenration 테스트 클래스에 대해 사용자 정의 이름을 선언\n7) @Disabled 테스트 클래스 or 메서드를 비활성화\n8) @BeforeEach / @BeforeAll @Test, @RepeatedTest, @Parameterized, @TestFactory가 붙은 메서드 전에 실행되는 테스트\n9) @AfterEach / @AfterAll @Test, @RepeatedTest, @Parameterized, @TestFactory가 붙은 메서드 후에 실행되는 테스트\n10) @Nested 테스트 클래스안에서 내부 클레스를 정의\n11) @Repeated Test 반복 테스트를 위한 테스트 템플릿임을 알림\n12) @Tag 필터링을 위한 태그\n13) @TestInstance(TestInstance.LifeCycle.PER_CLASS) 테스트 메서드간의 상태를 유지해주는 어노테이션\n14) @TestMethodOrder(MethodOrderer.OrderAnnotation.class) @Order() : 메서드간 순서를 지정해줄 수 있따. Refernce https://reiphiel.tistory.com/entry/junit5-features "},{"section":"Blog","slug":"/blog/java/controlstatement/","title":"제어문","description":"자바의 제어문 (조건문, 반복문)을 공부하자","date":"2021년 1월 25일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"1. 조건문 1) Switch 특정 데이터의 값에 따라 수행할 작업을 선택하는 구문으로 switch를 사용한다.\n일반적인 사용법은 C/C++와 다르지 않다.\npublic class example { public static void main(String[] args) { String select = \u0026#34;ORANGE\u0026#34;; String fruit; switch(select){ case \u0026#34;APPLE\u0026#34; : fruit = \u0026#34;apple\u0026#34;; System.out.println(\u0026#34;사과\u0026#34;); break; case \u0026#34;BANANA\u0026#34; : fruit = \u0026#34;banana\u0026#34;; System.out.println(\u0026#34;바나나\u0026#34;); break; case \u0026#34;ORANGE\u0026#34; : fruit = \u0026#34;orange\u0026#34;; System.out.println(\u0026#34;오렌지\u0026#34;); break; default: fruit = \u0026#34;default\u0026#34;; System.out.println(\u0026#34;default\u0026#34;); break; } System.out.println(fruit); } } switch() 매개변수에 데이터 값을 입력하고 case : 를 이용해 값에 따라 구문을 구분하면 된다.\nString이나 ,Integer과 같은 Wrapper타입이 올 수 있다. case의 값에는 리터럴 이나 상수가 와야 하고 중복해서는 안된다. Java 12버전 이후에 case -\u0026gt; 를 이용하여 작업할 구문을 작성할 수 있게 되었고 break를 생략이 가능해졌다. 또한, -\u0026gt; 와 yield를 사용하여 switch도 값을 반환할 수 있게 되었다. case에 따라 특정 변수의 값을 바꾸는 경우에는 위의 코드와 같이 외부의 변수에 값을 할당해주는 방법으로 비슷한 코드를 반복작성해야하는 단점이 존재했는데 쉽게 값을 바꿀 수 있게 되었다.\npublic class example { public static void main(String[] args) { String select = \u0026#34;ORANGE\u0026#34;; String fruit; fruit = switch(select){ case \u0026#34;APPLE\u0026#34; -\u0026gt; { System.out.println(\u0026#34;사과\u0026#34;); yield \u0026#34;apple\u0026#34;; } case \u0026#34;BANANA\u0026#34; -\u0026gt; { System.out.println(\u0026#34;바나나\u0026#34;); yield \u0026#34;banana\u0026#34;; } case \u0026#34;ORANGE\u0026#34; -\u0026gt; { System.out.println(\u0026#34;오렌지\u0026#34;); yield \u0026#34;orange\u0026#34;; } default -\u0026gt; { System.out.println(\u0026#34;없음\u0026#34;); yield \u0026#34;default\u0026#34;; } }; System.out.println(fruit); //orange } } yield는 case문에서 키워드로 사용되지만 변수 명으로 사용이 가능하다.\nint yield = 10; //error가 나지 않는다. 2) if문 if() 괄호안의 오는 데이터(구문의 반환 값)은 boolean형으로 true일 때 수행하는 문법\nint i = 10; if(i == 1){ System.out.println(\u0026#34;1\u0026#34;); } else if( i \u0026gt; 1 \u0026amp;\u0026amp; i \u0026lt; 7) { System.out.println(\u0026#34;2이상 6이하\u0026#34;); } else { System.out.println(\u0026#34;7이상\u0026#34;); } 2. 반복문 1) for for(int i=0; i \u0026lt; 10; i++){ System.out.print(i+ \u0026#34; \u0026#34;); } //0 1 2 3 4 5 6 7 8 9 2) for-each문 기본 for문은 괄호 안에 구문은 3가지가 올 수 있으며 초기식, 조건 식, 증감 식 으로 제어가 가능하다.\nfor(int i : new int[]{0,1,2,3,4,5,6,7,8,9}){ System.out.print(i+ \u0026#34; \u0026#34;); } //0 1 2 3 4 5 6 7 8 9 조건식이 아닌 변수타입 변수명 : 배열/컬렉션 을 입력하면 해당 레퍼런스 데이터의 값을 처음부터 끝까지 조회가 가능하다. (컬렉션에 저장되어있는 요소들을 읽어오기 위한 Iterator를 통해 조회를 한다.)\n3) Iterator 반복문과는 밀접한 관련은 없는 내용일 수 있지만 나온김에 정리하려고 한다.\nCollection을 기반으로 각 자료구조들을 조회 하는 데 있어 데이터를 읽는 방법을 동일한 방식으로 가능하게 제공해준다. (다형성)\n메서드 hasNext() : 다음 요소가 있는지 체크 (있다면 true) next() : 다음 데이터 반환 remove() : next()로 읽은 요소를 삭제 배열/컬렉션에 데이터 타입이 명시되어있기 때문에 앞의 변수타입을 var 키워드를 사용하여 타입추론도 가능하다.\nC++의 for(auto : ) 구문과 비슷하다.\n4) while C/C++과 while문은 동일하고 while() 괄호안의 조건식이 true이면 반복문을 돌게된다.\n3. 분기문 1) break 기본 switch문에서 쓰인다면 각 case 구문을 중단하기 위한 구문으로 break가 없다면 다음 case가 이어서 실행이된다.\n반복문에서 쓰인다면 현재 코드 블럭( {} ) 에 해당하는 반복문을 탈출한다.\n2) continue while에서 사용하면 다음 구문을 실행하지 않고 다시 처음부터 반복문을 실행하게 되며 for 문에서 사용하면 마찬가지로 다음 구문은 실행하지 않고 처음부터 반복하게 되는데 증감 식을 한번 수행 후 시작한다.\n설명이 애매한데 한마디로 반복문 중 conitnue를 만나면 반복문의 가장 끝으로 가는 느낌이다.\n3) return 메서드 안에서 사용하며 메서드의 결과를 반환하는 구문\n"},{"section":"Blog","slug":"/blog/java/enum/","title":"Enum","description":"자바의 어노테이션과 리플랙션, 어노테이션 프로세서","date":"2021년 1월 24일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다.\nJava의 Enum도 기본적으로 c나 c++의 enum과 같은 목적을 위한 클래스로 JDK 1.5이후에 생긴 클래스이다.\n잠깐 C언어 얘기를 하자면 C언어의 C99 이전에는 boolean타입을 제공하지 않았기 때문에 다음과 같이 사용하고는 했었다.\ntypedef enum _boolean { FALSE, TRUE } boolean; #define FALSE 0 #define TRUE 1 1. Java에서의 Enum 특징 Enum 비교시에 값이 아닌 타입까지도 체크가 가능하고 Enum의 상수값이 재정의 되어도 다시 컴파일하지 않는다.\n2. enum 정의와 사용 enum Money { DOLLAR, WON, POUND, EURO, YEN, YUAN } enum 키워드를 이용하여 정의를 할 수 있고 정의를 어디에 하느냐에 따라 분류를 해보자면 3가지정도로 분류할 수 있다.\n1) 정의 방법 별도의 Java 파일로 정의 [Money.java] public enum Money { DOLLAR, WON, POUND, EURO, YEN, YUAN } [example.java] public class example { public static void main(String[] args) { Money dollar = Money.DOLLAR; System.out.println(dollar); } } 클래스 안에 정의 public class example { public enum Money { DOLLAR, WON, POUND, EURO, YEN, YUAN } public static void main(String[] args) { Money dollar = Money.DOLLAR; System.out.println(dollar); } } 클래스 밖에 정의 enum Money {DOLLAR, WON, POUND, EURO, YEN, YUAN} public class example { public static void main(String[] args) { Money dollar = Money.DOLLAR; System.out.println(dollar); } } 정의 위치 IDE에 표시되는 Enum객체 폴더 구조 별도 파일 클래스 내 클래스 외부 정의 위치에 따라 enum객체가 생성된 위치가 다른 것을 볼 수 있다.\n2) enum 사용 Money.DOLLAR 와 같이 Enum이름.상수명 으로 사용을 할 수 있으며 Money money = Money.DOLLAR 와 같이 변수에 할당 해줄 수도 있다.\n/*C에서의 enum*/ #include \u0026lt;stdio.h\u0026gt; enum Money { DOLLAR, WON, POUND, EURO, YEN, YUAN } int main() { enum Money dollar = DOLLAR; enum Money won = WON; if (dollar == 0) { printf(\u0026#34;출력1\u0026#34;); //출력 } if (won \u0026gt; dollar) { printf(\u0026#34;출력2\u0026#34;); //출력 } return 0; } 위와 같이 C의 enum은 각 상수가 int형으로 저장되어 산술연산도 가능하고 아래와 같이 상수리터럴과 비교해도 같게 나오는 문제도 생긴다.\n/*java에서 private final static 사용하여 상수 비슷하게 사용하기*/ public class example { private final static int DOLLAR = 0; private final static int WON = 1; private final static int POUND = 2; private final static int EURO = 3; private final static int YEN = 4; public static void main(String[] args) { System.out.println(DOLLAR == 0); } } Enum이 없을 때 Java에서도 이와 비슷하게 class에 private final static int를 이용해서 상수값을 정의 할 수 있었다.\n하지만 이 방법은 가독성에도 좋지 않고 변수명이 겹칠 수 있거나 상수리터럴과 비교가 된다는 문제점이 있다.\n/*enum 사용하여 상수 열거형 생성*/ public class example { enum Money {DOLLAR, WON, POUND, EURO, YEN, YUAN} public static void main(String[] args) { Money dollar = Money.DOLLAR; Money won = Money.WON; System.out.println(dollar \u0026gt; won); //error System.out.println(dollar == 0); //error } } Java의 Enum은 각 상수가 상수 그 자체로써 작동을 하고 자료형이 다르기 때문에 아래와 같이 비교하려고 하면 compile error가 뜬다.\n3) 상수에 다른 값 추가 enum Money { DOLLAR(\u0026#34;달러\u0026#34;), WON(\u0026#34;원\u0026#34;), POUND(\u0026#34;파운드\u0026#34;), EURO(\u0026#34;유로\u0026#34;), YEN(\u0026#34;엔\u0026#34;), YUAN(\u0026#34;위안\u0026#34;); private String hanguelName; private Money(){} private Money(String hanguelName){this.hanguelName = hanguelName;} public String getHanguelName(){ return hanguelName; } } public class example { public static void main(String[] args) { Money dollar = Money.DOLLAR; Money won = Money.WON; System.out.println(dollar.getHanguelName()); System.out.println(won.getHanguelName()); } } 클래스의 생성자와 같은 방법으로 값을 할당 해줄 수 있으며, getter를 정의해서 값을 참조 할 수도 있다.\n이때 생성자는 PRIVATE 속성으로 생성해주어야 한다.\nNote\nenum타입은 고정된 상수들의 집합이므로 컴파일 타임에 모든 값을 알고 있어야하기 때문에 다른 클래스에서 동적으로 값을 정해줄 수 없기 때문에 생성자를 private로 설정해야 하고 final과 다름이 없어진다.\n3. enum이 제공하는 메소드 1) values() Enum의 모든 상수를 배열로 만들어 반환해주는 함수\npublic class example { public static void main(String[] args) { for(Money money : Money.values()){ System.out.println(money); //차례대로 출력 } System.out.println(Money.values()[1]); //WON 출력 System.out.println(Money.values() instanceof Object); //true } } Money[] 형태의 타입으로 반환이 된다.\n2) valuesOf() 매개변수로 String형이 오며 이 매개변수와 동일한 이름의 상수를 찾아 상수를 반환 하고 없다면 IllegalArgumentException 예외를 발생시킨다.\npublic class example { public static void main(String[] args) { System.out.println(Money.valueOf(\u0026#34;WON\u0026#34;)); //WON 출력 System.out.println(Money.valueOf(\u0026#34;Rupee\u0026#34;)); //IllegalArgumentException error } } 3) ordianal() enum 상수가 0부터 시작하여 정의된 순서를 반환(int)하는 함수\npublic class example { public static void main(String[] args) { Money dollar = Money.DOLLAR; System.out.println(dollar.ordinal()); //0 } } ordinal은 Enum을 정의한 순서를 반환하기 때문에 c때처럼 상수라고 생각하며 사용하지 말자.\nordinal은 EnumSet이나 EnumMap, JPA에서 접근하기 위한 내부 함수로 개발자는 거의 사용할일이 없는 메서드이다.\n정의 순서가 바뀌거나 값이 추가 되면 전혀 다른 결과가 나오기 때문이다.\n그런 이유로 Spring Data JPA에서 default는 ordinal이기 때문에 Enum순서가 바뀐다면 값이 아예 달라진다. 컬럼으로 Enum을 사용하면 @Enumerated를 이용해 String으로 사용하자.\n4. java.lang.Enum enum 클래는 기본적으로 java.lang.Enum 라는 부모 클래스를 상속 받고 있고 이는 Object를 상속받고 Comparable과 Serializable를 implements하고 있다.\nprotected Enum(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } protected형으로 생성자를 하나 가지고 있는데 이는 개발자가 호출할 수 없고 컴파일러에 의해 enum 키워드에 반응하여 생성하기 위함이다.\npublic String toString() { return name; } 이 클래스 내에 있는 public 메소드 중 Override해서 사용할만한 메서드로 기본은 상수 이름을 반환하지만, enum을 생성시 추가 값을 지정하여 생성했다면 이를 Override해줄 수 있다.\n1) 컴파일 시의 객체 생성 final class Money extends Enum\u0026lt;Money\u0026gt; { private Money(String name, int ordinal) { super(name, ordinal); } public static final Status DOLLAR = new Status(\u0026#34;DOLLAR\u0026#34;, 0); public static final Status WON = new Status(\u0026#34;WON\u0026#34;, 1); public static final Status POUND = new Status(\u0026#34;POUND\u0026#34;, 2); public static final Status EURO = new Status(\u0026#34;EURO\u0026#34;, 3); public static final Status YEN = new Status(\u0026#34;YEN\u0026#34;, 4); private static final Status ENUM$VALUES[] = { DOLLAR, WON, POUND, EURO, YEN }; } enum 키워드를 사용하여 열거형을 생성하면 컴파일 시에 위와 같이 정의가 된다.\n5. EnumSet Set 인터페이스를 구현한 것.\nEnumSet은 abstract키워드가 앞에 붙어 객체 생성이 불가능하고 of() 와 같은 추상 팩토리 메서드에서 사용하는 noneOf(class elementType) 메서드가 존재하여 이를 통해 구현 객체를 받을 수 있다.\npublic static \u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt; EnumSet\u0026lt;E\u0026gt; noneOf(Class\u0026lt;E\u0026gt; elementType) { Enum\u0026lt;?\u0026gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + \u0026#34; not an enum\u0026#34;); if (universe.length \u0026lt;= 64) return new RegularEnumSet\u0026lt;\u0026gt;(elementType, universe); else return new JumboEnumSet\u0026lt;\u0026gt;(elementType, universe); } noneOf() 메서드를 보면 알겠지만 EnumSet 객체를 반환하는 것이 아닌 이를 상속받은 클래스들을 반환하고 있다.\n이 둘 클래스 모두 private속성이므로 직접 사용할 수 없다.\n사용할 크기에 맞게 적합한 구현 객체를 골라 준다. Enum의 상수들을 하나하나 Set에 담는 행위를 피할 수 있다. EnumSet 내부 표현은 비트 벡터로 표현된다. (상수 개수가 64개 이하라면 long변수 하나로 표현한다.) Enum 상수가 선언된 순서, 즉 ordinal() 메서드의 반환된 순서로 순회한다. EnumSet iterator는 약한 일관성을 유지하여 ConcurrentModificationException을 발생시키지 않는다. null 요소는 삽입이 되지 않는다. 동기화가 되지 않는다. 1) 메서드 EnumSet.allOf(Class elementType) : 매개변수의 타입의 모든 요소를 포함한 EnumSet을 반환 EnumSet.noneOf(Class elementType) : 매개변수의 타입의 비어있는 EnumSet반환 EnumSet.of(E e1, E e2 \u0026hellip;) : 지정한 매개변수를 포함한 EnumSet을 반환 그 외 java.util.AbstractSet, java.util.AbstractCollection, java.lang.Object, java.util.Set으로 부터 메서드들을 상속받고 있다. 중복 검사를 위한 equals(),hashCode() ,add(),remove(),size(), toArray() =\u0026gt; Object[] 반환, iterator()등 사용 가능 6. EnumMap Map 인터페이스를 구현한 것.\nEnum을 Key로 이용하는 Map이다. Enum 상수로 null을 갖을 수 없기 때문에 null을 key로 갖지 못한다. Enum은 정해진 상수를 사용하고 단일 객체이기 때문에 해싱하지 않고 이미 순서가 정해져있어 성능이 좋다. key와 value가 배열로 구성되어있다. EnumMap의 key는 ordianl로 관리 되기 때문에 iterator는 약한 일관성을 유지하여 ConcurrentModificationException을 발생시키지 않는다. 동기화가 되지 않는다. 1) 메서드 생성자 : new키워드를 이용해 생성할 수 있고 일반 Map들과 다르게 enum 타입을 파라미터로 넘겨주어야 한다. Map\u0026lt;Money,Integer\u0026gt; map = new EnumMap\u0026lt;\u0026gt;(Money.class); clear() : 모든 요소 삭제 get(Object key) : key에 해당하는 value 리턴 put(K key, V value) : map에 데이터 입력 remove(Object key) : 해당하는 key가 있다면 삭제 equals(Object object) : 기준 Map과 같은지 비교 containsKey(Object key) / containsValue(Object value) : 해당하는 key와 value 가 있다면 true 반환 size() : Map의 요소 개수 반환 keySet() : Map에 있는 모든 key들의 Set view를 반환한다. (모든 key들을 보여준다.) values() : Map에 있는 value들의 Collection view를 반환한다. (모든 값들을 보여준다.) 7. Enum을 사용하면서 얻을 수 있는 장점 그래 Enum이 좋은건 알겠어. 그런데 실제로는 어떻게 사용할 수 있을까 했는데 우아한 형제들 기술블로그 에 활용기를 통해 장점들을 설명해주셔서 좋았고 이펙티브 자바책을 사서 봐봐야겠다는 생각을 했다.\n8. 추가 내용 1) type safety Runtime이 아닌 Complie타임에 문제를 잡을 수 있는 것으로 JVM은 컴파일할때, 특정 데이터 타입을 알 수 있으나 RUN시에 특정 데이터가 존재 하지 않는다거나 하는 문제가 생길 수 있다.\nEnum을 사용하면 오타방지를 할 수 있고, 컴파일타임에 에러를 잡아주기 때문에 디버깅도 쉬워진다.\n2) Enum에서 값 셋팅 팁 Enum의 값을 추가해줄 때 1,2,3같이 좁은 숫자의 범위가 아닌 10,20,30 같이 범위를 두고 선언해주자.\n언제 어떤이유에서 Enum에 값을 사이에 추가 해줄지 모르기 때문이다.\n◾ Reference https://www.nextree.co.kr/p11686/ http://cris.joongbu.ac.kr/course/java/api/java/lang/Enum.html https://javarevisited.blogspot.com/2014/03/how-to-use-enumset-in-java-with-example.html#axzz6kSbFjAwM "},{"section":"Blog","slug":"/blog/projects/react-project/2/","title":"PointRee 프로젝트 2 - front 개발환경 셋팅과 전체적인 디자인","description":"React와 material Ui, Recoil을 사용하여 전체적인 디자인 구현","date":"2021년 1월 24일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"packet","content":"mkdir pointRee cd pointRee mkdir front cd front npm init -y npm install react-create-app 가장 먼저 vscode를 통해 wsl2에 접속하고 wsl2에 폴더를 만들어 주고 react-create-app으로 간단하게 react프로젝트를 시작했다. 그리고 npm run start로 시작해보면 정상적으로 프로젝트가 실행되는 것을 확인 할 수 있다.\n이때 나처럼 wsl2로 실행시킨 사람이라면 window의 브라우저에 localhost:3060을 타이핑해서 들어간다면 접속이 되지 않을 것이다.\nwsl2는 별도의 ip를 가지고 있기 때문인데, wsl2의 ip:3060으로 접속하거나 실행시킨 console창의 링크를 클릭하면 window의 브라우저에 포트번호가 변경되며 열릴 것이다.\n1. index.js 와 기본 route 구성 1) index.js import ReactDOM from \u0026#34;react-dom\u0026#34;; import { BrowserRouter } from \u0026#34;react-router-dom\u0026#34;; import * as serviceWorker from \u0026#34;./serviceWorker\u0026#34;; import App from \u0026#34;./App\u0026#34;; ReactDOM.render( \u0026lt;BrowserRouter\u0026gt;{\u0026lt;App /\u0026gt;}\u0026lt;/BrowserRouter\u0026gt;, document.getElementById(\u0026#34;root\u0026#34;), ); serviceWorker.unregister(); 2) route.js import { Navigate } from \u0026#34;react-router-dom\u0026#34;; import DashboardLayout from \u0026#34;src/components/layout/DashboardLayout\u0026#34;; import Account from \u0026#34;src/pages/Account\u0026#34;; import Customers from \u0026#34;src/pages/Customers\u0026#34;; import Points from \u0026#34;src/pages/Points\u0026#34;; import Dashboard from \u0026#34;src/pages/Dashboard\u0026#34;; import Login from \u0026#34;src/pages/Login\u0026#34;; import LogOut from \u0026#34;src/pages/LogOut\u0026#34;; import NotFound from \u0026#34;src/pages/NotFound\u0026#34;; import Register from \u0026#34;src/pages/Register\u0026#34;; import Introduce from \u0026#34;src/pages/Introduce\u0026#34;; const routes = [ { path: \u0026#34;/\u0026#34;, element: \u0026lt;DashboardLayout /\u0026gt;, children: [ { path: \u0026#34;404\u0026#34;, element: \u0026lt;NotFound /\u0026gt; }, { path: \u0026#34;/\u0026#34;, element: \u0026lt;Navigate to=\u0026#34;/pointree\u0026#34; /\u0026gt; }, { path: \u0026#34;*\u0026#34;, element: \u0026lt;Navigate to=\u0026#34;/404\u0026#34; /\u0026gt; }, ], }, { path: \u0026#34;pointree\u0026#34;, element: \u0026lt;DashboardLayout /\u0026gt;, children: [ { path: \u0026#34;/\u0026#34;, element: \u0026lt;Introduce /\u0026gt; }, { path: \u0026#34;account\u0026#34;, element: \u0026lt;Account /\u0026gt; }, { path: \u0026#34;logout\u0026#34;, element: \u0026lt;LogOut /\u0026gt; }, { path: \u0026#34;points\u0026#34;, element: \u0026lt;Points /\u0026gt; }, { path: \u0026#34;dashboard\u0026#34;, element: \u0026lt;Dashboard /\u0026gt; }, { path: \u0026#34;customers\u0026#34;, element: \u0026lt;Customers /\u0026gt; }, { path: \u0026#34;*\u0026#34;, element: \u0026lt;Navigate to=\u0026#34;/404\u0026#34; /\u0026gt; }, { path: \u0026#34;login\u0026#34;, element: \u0026lt;Login /\u0026gt; }, { path: \u0026#34;register\u0026#34;, element: \u0026lt;Register /\u0026gt; }, ], }, ]; export default routes; 3) App.js import { useRoutes } from \u0026#34;react-router-dom\u0026#34;; import routes from \u0026#34;src/routes\u0026#34;; const App = () =\u0026gt; { const routing = useRoutes(routes); return { routing }; }; export default App; 앞에서 계획한 기능에 따라 대략적으로 예상한 url경로마다 render할 컴포넌트를 설정해놓은 router를 따로 폴더에 설정을 해주었고, 후에 material-ui, recoil등 componenet depth가 늘어날텐데 index.js에 한번에 작성하는 것보다 별도의 app.js 를 작성하는 것이 보기 좋을 것이라고 생각되어 위와같이 별도로 작성을 해주었다.\n2. 각 컴포넌트 디자인 해주기 모든 page에서 사용할 header와 Sidebar등을 Materail-Ui를 이용해 디자인 해주었고, main page에는 사이트를 간단하게 소개하는 page로 작성하고 로그인page까지 작성을 해주었습니다.\n이 과정은 이렇다할 건 없고 material-ui의 docs를 살펴보면서 했고 생각보다 시간과 코드가 길어서 간단하게 완성된 모습만 기록을 남기려고 합니다.\n"},{"section":"Blog","slug":"/blog/java/operator/","title":"연산자","description":"Java 연산자에 대해 정리하고 Java12 이후 추가된 switch 연산자도 정리한 글","date":"2021년 1월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다.\n산술 연산자 두개의 피연산자를 갖는 이항 연산자로써, 기본적인 사칙연산을 다루는 연산자\n◾ 더하기 (+) 왼쪽의 피연산자에 오른쪽 피연산자를 더하는 연산자로 숫자+숫자, 문자열+문자열이 가능하고 문자열+숫자를 할 시 숫자를 자동으로 문자열로 변환하여 덧셈이 가능하다.\n문자+숫자를 할 경우에는 아스키 코드를 이용하여 문자로 결과가 출력 된다. 문자에 맞는 아스키 코드값과 숫자를 더한 결과값에 해당하는 아스키코드를 return하기 때문이다.\nint left = 2020; int right = 1; int year = left + right; char ch = A; System.out.println(year); //2021 System.out.println(\u0026#34;20\u0026#34;+\u0026#34;21\u0026#34;); //2021 System.out.println(\u0026#34;Hello \u0026#34;+ year); //Hello 2021 System.out.println(ch + 2); //C System.out.println( 9 + \u0026#39;0\u0026#39;); //9 ◾ 뺄셈 (-) 왼쪽의 피연산자에서 오른쪽 피연산자를 빼는 연산자로 숫자-숫자와 같이 사용가능하고 문자열은 불가능하다.\n◾ 곱셈 (*) 왼쪽의 피연산자에 오른쪽 피연산자를 곱하는 연산자로 숫자*숫자와 같이 사용가능하고 문자열은 불가능하다.\n◾ 나눗셈 (/) 왼쪽의 피연산자를 오른쪽 피연산자로 나누는 연산자로 숫자/숫자와 같이 사용가능하고 문자열은 불가능하다.\n정수/정수를 할 시 나머지는 버려진 몫만 구해지며 두 피연산자 중 하나라도 실수(부동 소수방식)가 존재한다면 결과는 실수가 나온다.\n오른쪽 피연산자가 0이 될 수 없다. (0으로 나눌 수 없고 나눈다면 컴파일 에러가 난다.)\n0이 아닌 정수를 0.0으로 나눈다면 Infinity, 0을 0.0으로 나눈다면 NaN이 반환된다.\nint left = 5; int right = 2; System.out.println(left/right); // 2 System.out.println(left/2.0); // 2.5 System.out.println(left/0.0); //Infinity System.out.println(0/0.0); //NaN ◾ 나머지 (%) 왼쪽의 피연산자를 오른쪽 피연산자로 나눈 나머지를 구하는 연산자로 숫자%숫자와 같이 사용가능하고 문자열은 불가능하다.\n왼쪽 피연산자를 0.0이나 0으로 나눈다면 NaN이 반환된다. (왼쪽 피연산자가 정수인데 0으로 나눈다면 컴파일 에러)\nSystem.out.println(5%0); //컴파일 에러 System.out.println(5.0%0); //NaN System.out.println(0.0%0); //NaN System.out.println(0%0); //컴파일 에러 System.out.println(5%0.0); //NaN System.out.println(5.0%0.0); //NaN System.out.println(0.0%0.0); //NaN System.out.println(0%0.0); //NaN 단항 연산자 피 연산자를 한개만 갖는 연산자\n◾ 부호 연산 (+/-) 숫자를 입력시 +는 형식적으로 제공을 하기 때문에 생략이 가능하다.\n-는 부호를 바꾸는 연산자로 2의 보수를 취하는 연산자이다.\nSystem.out.println(2);//2 System.out.println(+2);//2 System.out.println(-2);// -2 ◾ 증감 연산자 (++/\u0026ndash;) 증감 연산자 독립적으로 사용하는 경우에는 위치에 상관없이 같은 결과를 갖는다.\nint i=1; int j=1; i++; // i = 2 ++j; // j = 2 i--; // i = 1 --j; // j = 1 다른 명령문과 같이 쓰인다면 결과가 달라진다.\n전위 증감 연산\n피연산자를 참조하기전에 값을 증감 시키고 난 후에 피연산자를 참조한다.\nint i=1; System.out.println(++i); //2출력 System.out.println(--i); //1출력 후위 증감 연산\n피연산자를 먼저 참조하고난 후 증감 시킨다.\nint i = 1; System.out.println(i++); //1 출력 후 i=2 System.out.println(i--); //2 출력 후 i=1 비트 연산자 피연산자를 이진수로 생각하고 각 자리수(bit)단위로 계산하는 연산자\n◾ 비트 NOT (~) 1의 보수를 구하는 연산자로 각 bit를 반전 시키는 연산자\nbyte num1 = 10; System.out.println(num); //10 (00001010) System.out.println(~num); //-11 (11110101) ◾ AND (비트곱) (\u0026amp;) 두 피연산자의 각 bit들을 AND 연산\n1 \u0026amp; 1 = 1\n1 \u0026amp; 0 = 0\n0 \u0026amp; 1 = 0\n0 \u0026amp; 0 = 0\nbyte num1 = 10; //bit로 00001010 byte num2 = 20; //bit로 00010100 byte num3 = num1 \u0026amp; num2; System.out.println(num3); //비트 곱하면 00000000로 0이 나온다. ◾ OR (비트합) (|) 두 피연산자의 각 bit를 OR 연산\n1 | 1 = 1\n1 | 0 = 1\n0 | 1 = 1\n0 | 0 = 0\nbyte num1 = 10; //bit로 00001010 byte num2 = 20; //bit로 00010100 byte num3 = num1 | num2; System.out.println(num3); //비트 곱하면 00011110로 30이 나온다. ◾ XOR (^) 두 피연산자의 각 bit를 XOR 연산\n1 ^ 1 = 0\n1 ^ 0 = 1\n0 ^ 1 = 1\n0 ^ 0 = 0\nbyte num1 = 10; //bit로 00001010 byte num2 = 20; //bit로 00010100 byte num3 = num1 ^ num2; System.out.println(num3); //비트 XOR하면 00011110로 30이 나온다. ◾ 오른쪽 Shift 연산자 (\u0026gt;\u0026gt;) 왼쪽의 피연산자의 bit를 오른쪽 피연산자의 수만큼 오른쪽으로 이동시키고 밀린 오른쪽 끝의 비트는 삭제되며 새로 오는 가장 왼쪽의 bit는 원래 부호에 따라 0(양수) or 1(음수)로 채워진다.\nbyte num1 = 10; //00001010 byte num2 = -10; //11110110 System.out.println(num1 \u0026gt;\u0026gt; 1); //00000101 System.out.println(num2 \u0026gt;\u0026gt; 1); //11111011 ◾ unsigned 오른쪽 Shift 연산자 ( \u0026gt;\u0026gt;\u0026gt; ) 왼쪽의 피연산자의 bit를 오른쪽 피연산자의 수만큼 오른쪽으로 이동시키고 밀린 오른쪽 끝의 비트는 삭제되며 새로 오는 가장 왼쪽의 bit는 부호에 상관없이 0으로 채워진다.\nbyte num1 = 10; //00001010 byte num2 = -10; //11110110 System.out.println(num1 \u0026gt;\u0026gt; 1); //00000101 System.out.println(num2 \u0026gt;\u0026gt; 1); //01111011 ◾ 왼쪽 Shift 연산자 (\u0026lt;\u0026lt;) 왼쪽의 피연산자의 bit를 오른쪽 피연산자의 수만큼 왼쪽으로 이동시키고 밀린 왼쪽 끝의 비트는 삭제되며 새로 오는 가장 오른쪽의 bit는 0으로 채워진다.\nbyte num1 = 10; //00001010 byte num2 = -10; //11110110 System.out.println(num1 \u0026lt;\u0026lt; 1); //00010100 System.out.println(num2 \u0026lt;\u0026lt; 1); //11101100 관계 연산자 두 피연산자간에 값을 비교하기 위한 연산자\n◾ 동치 연산자 ( == / != ) 두 피연산자 값이 같은지 비교하는 연산자로 원시형 타입끼리 비교할때는 값을 비교하고 데이터 크기가 다른 데이터타입끼리의 비교라면 큰 데이터 타입으로 변환되어 비교한다.\n참조 타입 (String, Array, Class...)끼리의 비교라면 동일한 원본 데이터(객체)인지 비교한다.\n== : 두 피연산자 값이 같으면 false, 아니면 false 반환\n!= : 두 피연산자 값이 같지 않으면 false, 같으면 false 반환\n◾ \u0026lt; , \u0026lt;= 왼쪽 피연산자가 오른쪽 피연산자보다 작은지(작거나 같은지) 판단하여 맞다면 true, 아니라면 false반환\n◾ \u0026gt;, \u0026gt;= 왼쪽 피연산자가 오른쪽 피연산자보다 큰지(크거나 같은지) 판단하여 맞다면 true, 아니라면 false 반환\n논리 연산자 boolean 형(true/false)를 비교하는 연산자로 두 피연산자가 boolean형일때만 사용가능 하다.\n◾ 논리 NOT (!) 한개의 피연산자의 값을 바꾸는 연산자\nboolean t = true; System.out.println(!t); //false; ◾ 논리 AND (\u0026amp;\u0026amp;) 두 피연산자가 모두 true이면 true 아니면 false를 반환한다.\nboolean t = true; boolean f = false; System.out.println(t \u0026amp;\u0026amp; t); //true System.out.println(t \u0026amp;\u0026amp; f); //false System.out.println(f \u0026amp;\u0026amp; t); //false System.out.println(f \u0026amp;\u0026amp; f); //false ◾ 논리 OR (||) 두 피연산자중 하나라도 true이면 true 아니면 false를 반환한다.\nboolean t = true; boolean f = false; System.out.println(t || t); //true System.out.println(t || f); //true System.out.println(f || t); //true System.out.println(f || f); //false ◾ 단락 회로 평가 (Short Circuit Evaluation) 논리 연산자를 수행 중 true나 false조건이 만족된다면 오른쪽 피연산자는 참조안하고 바로 true 리턴하는 것\nSystem.out.println(f \u0026amp;\u0026amp; t); //왼쪽이 피연산자가 이미 false이므로 오른쪽 피연산자인 t 는 참조하지 않고 바로 false return System.out.println(t \u0026amp;\u0026amp; f); //왼쪽이 true이기 때문에 오른쪽피연산자 값에 따라 return값이 다르므로 오른쪽 피연산자 참조후 false return System.out.println(t || f); //왼쪽이 피연산자가 이미 true이므로 오른쪽 피연산자인 t 는 참조하지 않고 바로 truereturn System.out.println(f || f); //왼쪽이 false이기 때문에 오른쪽피연산자 값에 따라 return값이 다르므로 오른쪽 피연산자 참조후 false return ◾ \u0026amp; , | , ^ 비트 연산자를 논리형(boolean)에도 사용할 수 있으며 결과값은 동일하지만 단락 회로 평가가 되지 않는다. (양쪽 피연산자를 모두 참조후 결과 값 반환)\nboolean t = true; boolean f = false; System.out.println(t \u0026amp; t); //true System.out.println(t \u0026amp; f); //false System.out.println(f \u0026amp; t); //false System.out.println(f \u0026amp; f); //false System.out.println(t | t); //true System.out.println(t | f); //true System.out.println(f | t); //true System.out.println(f | f); //false System.out.println(t ^ t); //false System.out.println(t ^ f); //true System.out.println(f ^ t); //true System.out.println(f ^ f); //false instanceof 참조 타입의 변수가 특정 타입인지 검사하는 연산자로 같다면 true, 아니라면 false가 반환되고 null을 검사하려고한다면 false가 반환된다.\n참조 타입 변수가 초기화가 되지 않았다면 검사할 변수의 참조 값이 없으므로 컴파일 에러가 뜬다.\n자바의 모든 객체는 암시적으로 Object를 상속받고 있기 때문에 Object로 비교해도 true가 나오며 왼쪽 피연산자로 원시타입은 올 수 없다.\nint[] i; System.out.println(i instanceof int[]); //컴파일 에러 int[] i = new int[5]; System.out.println(i instanceof Object); //true System.out.println(i instanceof int[]); //true Object j = new int[5]; System.out.println(i instanceof int[]); //true System.out.println(j instanceof Object);//true System.out.println(null instanceof Object);//false System.out.println(\u0026#34;hello\u0026#34; instanceof Object);//true System.out.println(\u0026#34;hello\u0026#34; instanceof String);//true ArrayList arrayList= new ArrayList(); System.out.println(arrayList instanceof ArrayList); //true System.out.println(arrayList instanceof Object); //true assignment(=) 연산자 우리가 일반적으로 변수에 값을 할당하거나 참조할 데이터 주소를 할당할때 쓰는 연산자이다.\n◾ 복합 대입 연산자 연산을 실행 후 대입하는 연산자로 산술 연산자 or 비트 연산자 or 시프트 연산자와 대입연산자를 합친 형태이다.\nint i = 10; i += 1; // i = i + 1 i -= 2; // i = i - 2 i *= 3; // i = i * 3 i /= 4; // i = i / 4 i %= 5; // i = i % 5 i \u0026amp;= 1; // i = i \u0026amp; 1 i |= 2; // i = i | 2 i ^= 3; // i = i ^ 3 i \u0026lt;\u0026lt;= 1; // i = i \u0026lt;\u0026lt; 1 i \u0026gt;\u0026gt;= 2; // i = i \u0026gt;\u0026gt; 2 i \u0026gt;\u0026gt;\u0026gt;= 3; // i = i \u0026gt;\u0026gt;\u0026gt; 3 화살표(-\u0026gt;) 연산자 람다를 사용하기 위해 도입된 람다 표현식으로 익명 컬렉션이다.\n핵심은 간단하게 표현이다.\n컴파일러의 추론을 통해 지울수 있는 것은 모두 지우거나(생략하여) 표현하는 방법이다.\ninterface User{ void printUserName(String name); } User user = new User() { @Override public void printUserName(String name) { System.out.println(\u0026#34;User name is \u0026#34; + name); } }; 위의 코드와 같이 setUserName메서드 하나만을 갖고있는 User 인터페이스에서 이 메서드를 override하려고 한다고 한다면 아래와 같이 생략이 가능할 것이다.\nUser user = (name) -\u0026gt; { System.out.println(\u0026#34;User name is \u0026#34; + name); } 컴파일러는 User user를 통해 데이터 타입을 명시 했기 때문에 new User부분은 생략이가능할 것이고 메서드는 하나만 갖고있기때문에 메서드를 명시하지 않아도 추론이 가능하기 때문에 이렇게 표현이 가능하다.\n파라미터 인자가 한개라면 ()는 생략이 가능하고 {}안의 코드가 한줄이라면 {}또한 생략이 가능하다.\n3항 연산자 (?:) 말그대로 3개의 피연산자를 사용하는 연산자이다.\n조건문 (if/else)처럼 사용이 가능하다.\n조건문 ? 값1 : 값2와 같은 형태로 조건문이 참이라면 값1을 조건문이 거짓이라면 값2를 반환한다.\nboolean isTrue1 = (10 \u0026gt; 1) ? true : false; //10 \u0026gt; 1은 true이기 때문에 true를 isTrue에 반환한다. (10 \u0026gt; 1) ? true : false; //3항 연산자는 식으로써 값을 만들어내기 때문에 참조나 대입이 없다면 `Not a Statment`라는 컴파일 에러를 띄운다. ◾ if/else와 3항 연산자 차이 if/else는 statement로써 값을 만들어내지 못한다.\n3항 연산자는 expression으로써 값을 만들어 낸다.\n때문에 ?뒤에 오는 2개의 값에는 값만 넣고 코드를 넣지 말자!!\n가독성도 안좋아지고 엄연히 목적이 다르다.\nStatement와 Expression란? (if/else와 삼항연산자의 차이) 참고 글 연산자 우선 순위 우선순위 연산자 연산 방향 동작 내용 1 . 왼쪽 -\u0026gt; 오른쪽 객체 멤버 접근 [, ] 왼쪽 -\u0026gt; 오른쪽 배열 요소 접근 (args) 왼쪽 -\u0026gt; 오른쪽 메소드 호출 i++, i-- 왼쪽 -\u0026gt; 오른쪽 후위 증감 2 ++i, --i 왼쪽 \u0026lt;- 오른쪽 전위 증감 +, - 왼쪽 \u0026lt;- 오른쪽 단항 증감 ~, ! 왼쪽 \u0026lt;- 오른쪽 비트 보수, 부정 연산 3 new 왼쪽 \u0026lt;- 오른쪽 객체 생성 (datatype) 왼쪽 \u0026lt;- 오른쪽 캐스팅(형 변환) 4 *, /, % 왼쪽 -\u0026gt; 오른쪽 곱하기, 나누기, 나머지 5 +,- 왼쪽 -\u0026gt; 오른쪽 더하기, 빼기 6 \u0026lt;\u0026lt;, \u0026gt;\u0026gt;, \u0026gt;\u0026gt;\u0026gt; 왼쪽 -\u0026gt; 오른쪽 왼쪽 시프트, 오른쪽 시프트, 부호없는 오른쪽 시프트 7 \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 왼쪽 -\u0026gt; 오른쪽 작음, 작거나 같음, 큼, 크거나 같음 instanceof 왼쪽 -\u0026gt; 오른쪽 타입 비교 8 ==, != 왼쪽 -\u0026gt; 오른쪽 같음, 같지 않음 9 \u0026amp; 왼쪽 -\u0026gt; 오른쪽 AND 10 ^ 왼쪽 -\u0026gt; 오른쪽 XOR 11 | 왼쪽 -\u0026gt; 오른쪽 OR 12 \u0026amp;\u0026amp; 왼쪽 -\u0026gt; 오른쪽 논리 AND 13 || 왼쪽 -\u0026gt; 오른쪽 논리 OR 14 ?: 왼쪽 \u0026lt;- 오른쪽 3항 연산자 15 =, *=, /=, %=, +=, -=, \u0026lt;\u0026lt;=, \u0026gt;\u0026gt;=, \u0026gt;\u0026gt;\u0026gt;=, \u0026amp;=, ^=, |= 왼쪽 \u0026lt;- 오른쪽 대입 연산자 16 -\u0026gt; 왼쪽 -\u0026gt; 오른쪽 람다 표현식 switch 연산자 //Java 12 이전 int num = 1; int result = 0; switch(num){ case 1: result = 1; System.out.println(\u0026#34;1\u0026#34;); break; case 2: result = 2; System.out.println(\u0026#34;2\u0026#34;); break; case 3: result = 3; System.out.println(\u0026#34;3\u0026#34;); break; } //Java 12 var result2 = switch(num){ case 1 -\u0026gt; 1; case 2 -\u0026gt; System.out.println(\u0026#34;2\u0026#34;); //compile error case 3 -\u0026gt; 3; case 4 : //compile error System.out.println(\u0026#34;4\u0026#34;); break; default -\u0026gt; throw new IllegalStateException(\u0026#34;default\u0026#34;); }; //Java13 var result3 = switch(num){ case 1 : { System.out.println(\u0026#34;1\u0026#34;); yield 1; } case 2 : yield 2; case 3 : yield 3; default : throw new IllegalStateException(\u0026#34;default\u0026#34;); }; var result4 = switch(num){ case 1 -\u0026gt; { System.out.println(\u0026#34;1\u0026#34;); yield 1; } case 2 -\u0026gt; 2; case 3 -\u0026gt; { yield 3; System.out.println(\u0026#34;2\u0026#34;); //compile error } default -\u0026gt; throw new IllegalStateException(\u0026#34;default\u0026#34;); }; 기존의 switch문에서 외부 변수에 값을 대입하기 위해서는 위의 코드와 같이 result = 1과 같은 식으로 매 case마다 추가해주어야 했었다.\nJava 8이후에 람다식이 생기고 나서 Java에 많은 변화가 있었고 Java 12에는 case마다 결과값을 반환하는 switch문에 경우 람다 표현식(-\u0026gt;)을 사용 할 수 있게 되었다.\nJava 12의 람다 표현식의 경우 바로 대입값을 우항에 표현해주어야 했기 때문에 추가 작업을 못한다는 단점이 있어\nJava 13에 yield가 추가 되었다.\nyield를 사용하면 해당 값을 return하고 case문을 종료하기 때문에 yield다음 줄에 다른 구문이 온다면 compile error가 난다.\n◾ 특징 각 case마다 반환타입을 컴파일시에 추론이 가능하기 때문에 추론형 데이터 타입인 var이 가능하다.\n모든 case에 대해 반환 값이 있어야 error가 안나기 때문에 default문도 반드시 있어야 한다.\n람다 표현식(-\u0026gt;)과 기존 표현식 (:)은 혼용해서 사용이 불가능하다.\nbreak;구문 없이도 다음 case로 넘어가지 않는다.\nRefernece https://blog.baesangwoo.dev/posts/java-livestudy-3week/#%EB%B9%84%ED%8A%B8-%EC%97%B0%EC%82%B0%EC%9E%90 https://multifrontgarden.tistory.com/124 "},{"section":"Blog","slug":"/blog/java/thread/","title":"멀티 스레딩","description":"Thread와 프로세스, 동기화, 데드락에 대한 개념과 구현을 도와주는 패키지,클래스,메서드 정리","date":"2021년 1월 22일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다.\nThread란? 쓰레드라는 개념을 이해하기 위해서는 프로세스와 병행성(Concurrency)의 개념을 알면 더 좋을 것같다.\n◾ 프로세스란 프로세스의 사전적 의미는 컴퓨터에서 실행되고 있는 컴퓨터 프로그램을 말한다. 여러 개의 프로세서를 사용하는 것을 멀티 프로세싱이라고 하며, 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹 이라고 한다.\n특징 프로그램이 실행되는 단위 모든 프로그램은 실행 될 때 하나 이상의 프로세스를 갖는다. 각 프로세스는 다른 프로세스의 변수나 자료 구조에 접근할 수 없다. 각 프로세스는 별도의 주소공간에서 실행된다. 컴퓨터 메모리에 적재되어 실행되어 있는 프로그램을 말한다. 프로세스의 상태는 생성, 실행, 준비, 대기, 종료가 있다. ◾ 쓰레드 프로세스의 특정한 수행 경로로 프로세스가 할당 받은 자원을 이용하는 실행의 단위라고 할 수 있다.\n하나의 프로세스에서 여러개의 스레드를 사용하는 것을 멀티 스레딩이라고 한다.\n특징 프로세스 내에서 스택/레지스터만 각각 할당 받고 나머지 메모리 영역은 공유한다.\n스택은 각각 할당하는 이유 : 스레드는 한 기능을 수행하는 독립적인 단위로써 최소한의 메모리 영역(스택)은 각각 할당해야 독립적으로 수행이 가능하다.\n◾ 병행성(동시성) (Concurrency) 병렬성과 헷갈릴 수 있는데 병행성은 동시에 실행되는 것 처럼 보이는 것으로 싱글코어에서는 시분할기법으로 수행할 수 있고 멀티코어에서는 물리적으로 병렬로 동작할 수 있다.\n병렬성(Parallelism)은 실제로 동시에 작업이 처리되는 것으로 멀티코에에서만 동작이 가능하다.\nThread 클래스와 Runnable 인터페이스 자바에서 쓰레드를 작성하는 방법에는 Thread 클래스와 Runnable 인터페이스를 사용하는 두가지 방법이 있다.\n◾ Thread 클래스 extends public class Example { public static void main(String[] args){ ExampleThread th1 = new ExampleThread(); Thread th2 = new Thread(){ @Override public void run(){ System.out.println(\u0026#34;thread2\u0026#34;); } } th1.start(); th2.start(); } class ExampleThread extends Threads{ @Override public void run(){ System.out.println(\u0026#34;Thread 1\u0026#34;); } } } Thread 클래스를 확장하여 생성하는 방법으로는 thread클래스를 상속받아 생성하는 방법인 th1과 th2와 같이 익명 객체를 사용하여 생성하는 방법 2가지 가 존재하고 두번째방법인 익명 클래스를 이용하는 방법은 쓰레드가 오직 한번만 수행 될때 사용하는 방법이다.\n◾ Runnable 인터페이스 implements public class Example { public static void main(String[] args){ Runnable r = new ExampleThread(); Thread th1 = new Thread(r); //Thread th1 = new Thread(new ExampleThread()); Thread th2 = new Thread(()-\u0026gt;{ System.out.println(\u0026#34;thread2\u0026#34;); }); th1.start(); th2.start(); } class ExampleThread implements Runnalbe{ @Override public void run(){ System.out.println(\u0026#34;Thread 1\u0026#34;); } } } Runnable 인터페이스를 이용한 Thread생성방법도 두가지가 존재한다.\nRunnalbe 인터페이스를 implements한 class를 생성자 매개변수로 이용하여 생성하는 방법\nRunnable 인터페이스는 run메서드밖에 존재하지 않는 점을 이용하여 람다를 이용해 바로 run메서드를 정의하여 생성하는 방법\n◾ 차이점 Thread 클래스를 extends하는 방법은 class를 상속받는 것인 만큼 Thread의 다른 메서드들을 이용이 가능하지만 다른 class를 상속받지 못하지만, Runnable 인터페이스를 구현하는 것은 다른 class를 상속받을 수 있고 조금 더 객체 지향적이다.\nThread클래스를 상속받는 class는 run 메서드가 종료되면 가비지 컬렉션이 되기 때문에 재사용이 불가능하지만, Runnable 인터페이스를 구현한 방법은 Thread 클래스는 가비지 컬랙션이 되더라도 구현체는 가비지 컬랙션이 되지 않기 때문에 재사용이 가능하다.\nRunnable 인터페이스를 구현한 경우 Thread클래스의 메서드를 이용하고 싶다면 Thread 클래스의 static 메서드인 currentThread()를 호출하여 쓰레드의 참조를 얻어야 사용이 가능하다.\nclass ThreadA extends Thread { public void run() { System.out.println(getName()); } class ThreadB implements Runnable { public void run() { System.out.println(Thread.currentThread().getName()); } } 쓰레드의 상태 상태 열거 상수 설명 객체 생성 NEW 스레드 객체 생성 (start()메서드 호출 전) 실행 대기 RUNNABLE 스케줄링 되지 않아 실행을 기다리고 있는 상태 일시정지 WAITING 다른 스레드의 notify를 기다리는 상태 일시정지 TIMED_WAITING 주어진 시간 동안 기다리는 상태 일시정지 BLOCKED 사용하고자 하는 객체의 락이 풀릴 때 까지 기다리는 상태 ( 동기화 문제 ) 종료 TERMINATED 실행을 마친 상태 ◾ Start와 run start()는 NEW상태의 스레드를 RUNNABLE상태로 만들어주는 메서드로 실행될 수 있는 대기 큐에 넣어주는 역할(call stack 생성)\nrun()은 스레드가 스케줄러에 의해 실제로 실행될때 실행할 메서드이고 start()없이 run만 실행하게 된다면 override된 메서드를 그대로 호출할 뿐 해당 Thread는 RUNNABLE상태가 아니기 때문에 메타데이터가 실행대기 큐에 들어있지 않아 원하는 대로 동작하지 않는다.\n◾ 쓰레드 상태 제어 메서드 사진 출처 : https://widevery.tistory.com/28 Thread 클래스에 정의 메서드 설명 interrupt() 일시정지상태의 스레드에서 Interrupt 예외를 발생시켜 작업을 멈추라고 요청하는 메서드 interrupted() interrupt()가 호출되었는지 알려주는 메서드 (되었다면 true) join((long millis),(int nanos)) 동작중인 작업을 멈추고 다른 스레드가 지정 시간동안 작업 수행하도록 넘겨주는 메서드로 시간을 지정하지 않으면 다른 스레드가 작업을 마칠때 까지 기다린다. sleep(long millis, (int nonos)) 일정 시간동안 스레드를 멈추게 하는 메서드로 일시정지상태로 만들고 interrupt()가 호출되면 실행 대기상태로 만든다.\nsleep은 항상 실행중인 스레드에 대해 작동하기 때문에 static으로 선언되어 있어 Thread.sleep(1000)과 같이 사용해야 한다. yield() 스레드 자신에게 주어진 시간을 다음 스레드에게 양보하는 메서드 Object 클래스에 정의 특정 객체에 대한 것이므로 위의 메서드롸 다르게 Object클래스에 정의되어 있어 모든 객체에서 호출이 가능하고 동기화 블록내에서만 사용할 수 있다.\n메서드 설명 notify() 일시정지 상태의 스레드중 다른 스레드를 깨우는 메서드로 RUNNABLE상태로 만든다. notifyAll() waiting pool안에 있는 모든 스레드를 깨우는 메서드로 깨어난 스레드들은 다시 경쟁을 통해 실행된다.\n호출된 객체의 waiting pool내의 스레드들을 모두 깨우는 것 wait() notify()나 notifyAll()을 기다리는 메서드 wait(long timeout,(int nanos)) 지정된 시간동안만 기다리는 메서드 쓰레드의 우선순위 여러개의 쓰레드가 동작하며 병행성을 수행하기 위해 시분할을 하여 스케줄링을 통해 스레드를 동작 시키는데 이를 위해, 자바는 쓰레드 클래스에 어떤 쓰레드를 더 중요하게 생각하여 동작시킬지 지정하여 더 많은 작업시간을 갖도록 할 수 있게 해주는 멤버 변수를 갖고 있다.\n우선순위의 범위는 1~10이며 숫자가 높을수록 우선순위가 높고, 메인 메서드를 수행하는 쓰레드의 우선순위가 5이므로 main메서드 내에서 생성하는 쓰레드의 우선순위는 기본값이 5가 된다.\n쓰레드의 우선순위는 상대적인 값으로 절대적이 값이 아니다\n◾ 메서드 thread.setPriority(1~10); thread.setPriority(Thread.MIN_PRIORITY); //1 thread.setPriority(Thread.NORM_PRIORITY); //5 thread.setPriority(Thread.MAX_PRIORITY); //10 ◾ 순환할당 (Round Robin) 방식 스케줄링 방식에는 우선순위방식 말고도 RR방식도 있는데 이 방식은 스레드마다 사용할 시간을 할당(Time slice)해서 정해진 시간만큼 돌아가며 실행하는 방식으로 JVM에 의해 결정되기 때문에 개발자가 임의로 수정할 수 없다.\nMain 쓰레드 우리가 자바프로젝트를 처음 시작했을때나 c,c++와 같이 처음 작성하는 main()메서드를 실행하면 시작되는 스레드로 main메서드의 코드 흐름이다.\nmain 쓰레드를 통해 다른 쓰레드를 생성하기 때문에 메인스레드가 없다면 멀티스레드는 당연히 구현할 수 없다.\nsingle process multi process single thread multi thread 동기화 멀티 스레드로 동작하는 프로그램에서 한 스레드가 작업하는 중에 사용하는 데이터들을 다른 스레드가 간섭하지 못하도록 막는 것이다.\n동기화를 시키지 않는다면 여러개의 스레드가 번갈아가며 동작할 경우, 어떤 스레드가 먼저 실행될지 알 수 없기 때문에 개발자가 의도하지 않는 동작이 발생할 수 있기 때문에 멀티스레드프로그래밍에서는 중요한 문제이다.\n주요 개념들\n임계 구역 (Critical Section) : 여러개의 스레드가 공유하는 데이터 블럭으로 하나의 스레드만 접근가능하도록 지정하는 것이 목표이다.\n상호 배제 (Mutual Exclusion,Mutex) : 임계 구역을 헌 시점에서 한개의 스레드만 사용할 수 있도록 다른 스레드의 접근을 제어하는 기법\n동기화 : 상호배제의 한 형태로 상호배제를 수행하기 위해 프로세스의 처리 순서를 결정하는 기법 (Semaphore)\n기아 상태 (starvation) : 다른 쓰레드에게 우선순위가 밀려 자원을 계속 할당받지 못하는 상태\n공정성(fairness) : 모든 쓰레드가 공평하게 작업을 수행하는 것\n◾ Synchronized 이용 임계영역을 설정하는데 사용하는 키워드로 메서드 전체를 임계영역으로 지정하거나 특정한 영역을 임계영역으로 지정하는 방법이 있다.\n1. 메서드 전체를 임계 영역으로 지정 public synchronized void cal() { ... } 2. 특정한 영역을 임계 영역으로 지정 synchronized(객체의 참조변수) { ... } 쓰레드는 synchronized가 호출된 시점부터 해당 코드블럭이 포함된 객체의 lock을 얻어 작업을 수행하다가 종료되면 lock이 반환되고 이는 모두 자동으로 이루어지기 때문에, 개발자는 임계영역만 설정 해주면된다.\n객체는 lock을 하나씩 가지고 있고 설정한 객체의 lock을 가지고있는 쓰레드만 임계영역에 접근이 가능하고 다른 스레드는 대기 상태에 들어가기 때문에 임계영역은 좁히는 것이 좋다.\n메서드에 synchronized를 걸면 그 메서드가 포함된 객체(this)에 lock을 거는 것과 같다.\n객체 없이 호출하는 static 메서드의 경우 해당 class에 lock을 걸면서 함수간에 lock이 공유되어 동시에 호출되는 것을 막아 동기화문제가 해결된다.\n◾ Locks Java 5에 추가된 패키지로 java.util.concurrent가 있는데 이 패키지에서 동기화를 위해 다양한 클래스들을 제공한다.\n주요 기능 Locks : 상호 배제를 사용할 수 있는 클래스\nSynchronizers : 동기화를 처리하는 클래스 제공 (Semaphore, CountDownLatch, CyclicBarrier, Phaser, Exchanger)\nAtomic : 동기화가 되어있는 변수 제공\nExecutors : 쓰레드 풀 생성, 쓰레드 생명주기 관리와 같은 기능 제공\nQueue : Thread-safe한 Queue 제공\njava.util.concurrent.locks 해당 패키지에 상호 배제를 위한 Lock API들이 정이 되어있고, synchronized 도 lock을 이용한 동기화인만큼 동일한 메커니즘으로 동작한다.\n내부적으로 synchronized를 사용해 구현되었고, 더욱 더 유연하고 정교하게 처리하기 위해 사용되고 직접 lock을 걸고 푸는 작업을 수행해야 한다.\nInterface\nLock : 공유자원에 한번에 한 쓰레드만 read/write를 수행 가능\nReadWriteLock : 공유 자원에 여러개의 쓰레드가 read할 수 있지만 write는 한 쓰레드만 수행 가능\nCondition : wait()과 notify()를 쓰레드의 종류로 구분하지 않고, 공유객체의 waiting poll에 몰아 넣고 각 쓰레드를 위한 Condition을 만들어 각각의 waiting pool에서 따로 기다리도록 한다.\nwait(),notify(),notifyAll() 대신 await(),signal(),signalAll()을 사용한다.\nInterface의 구현체\nReentrantLock : Lock의 구현체로 임계영역의 시작,졸료 지점을 명시 할 수 있게 해준다.\nReentrantReadWriteLock : ReadWriteLock의 구현체\nStampLock : JDK 1.8부터 추가되었고, 다른 lock과 달리 Lock인터페이스를 구현하지 않고 lock을 걸거나 해지할때 스탬프(long타입 정수값)를 사용한다.\n주요 메서드\nlock() : Lock 인스턴스에 lock을 건다.\nlockInterruptibly() : 현제 쓰레드가 interrupted 상태가 아닐때 Lock 인스턴스에 잠금을 걸고 interrupted상태라면 Exception을 발생시킨다.\ntryLock() : 즉시 Lock인스턴스에 잠금을 시도하고 성공여부를 boolean 타입으로 반환한다.\ntryLock(long timeout, TimeUnit timeUnit) : 잠금 실패시 false를 반환하는 것이 아닌 주어진 시간동안 기다린다.\nunlock() : Lock인스턴스의 잠금을 해제한다.\nnewCondition() : 현제 Lock 인스턴스와 연결된 Condition 객체를 반환한다.\n◾ Synchronized 와 Lock의 차이점 Synchronized는 암시적인(implicit) lock이라고 하여 불공정 문제가 발생 할 수 있어 쓰레드 순서를 보장하지 않지만 Lock은 순서를 지정할 수 있어 명시적인(explict) lock이라고 한다.\nSynchronized는 lock을 자동 획득/반환해주기 때문에 코드가 간결하다는 장점이 있고, Lock은 ReentrantLock을 이용하면 생성자 인자를 통해 공정/불공정을 설정 할 수 있어 공정한 lock을 사용할 경우 자원 할당을 위해 경쟁이 발생했을 때 오래 기다린 스레드에게 lock을 제공하여 기아 문제를 해결할 수 있다.\n◾ volatile 멀티 코어 프로세서는 코어마다 별도의 캐시를 갖고 있는데 변수 앞에 volatile 키워드를 붙이면 코어가 변수의 값을 읽어올 때 캐시가 아닌 메모리에서 읽어오기 때문에 캐시와 메모리간의 불일치를 해결할 수 있다.\nJVM은 데이터를 4byte 단위로 처리하기 때문에 int나 이보다 작은 타입의 데이터는 한번에 읽거나 쓰는 것이 가능하나 그보다 큰 데이터 타입이라면 하나의 명령어로 값을 읽거나 쓸 수 없다. 때문에 변수의 값을 읽는 과정에서 다른 쓰레드가 끼어들 틈이 있기 때문에 변수를 읽고 쓰는 문장을 synchronized블럭으로 감싸거나 변수를 volatile을 붙여 선언하는 방법으로 캐시와 메모리간 불일치 문제를 해결 할 수 있다.\n상수에는 volatile를 붙일 수 없어 변수에 final을 같이 쓸 수 없다. (상수는 변하지 않는 값이기 때문에 thread-safe하기 때문에)\n데드락 교착상태라고도 하며 상호 배제에 의해 나타나는 문제로, 둘 이상의 스레드가 데이터를 점유한 상태에서 서로 다른 스레드가 점유하고 있는 데이터를 요구하게되어 끝없이 기다리는 상태\n데이터베이스 트랜젝션에서도 발생하는데 한 트랜잭션에서 한 레코드에 업데이트를 수행할 때, 이 레코드는 업데이트를 위해 다른 트랜잭션의 접근을 막도록 lock을 거는데 다수의 트랜젝션이 동시에 레코드를 업데이트하려한다면 데드락에 빠질 위험이 있다.\n◾ 데드락 발생 조건(이유) Mutual Exclusion(Mutex) : 자원에 동시 접근 불가능\nHold \u0026amp; Wait : 점유하고 기다리기 (자원을 점유한채로 다른 스레드의 자원을 반납받길 기다리는 것)\nNo Preemption : 자원을 강제로 뺐어오지 못함\nCircular Wait : 순환 형태로 대기\n◾ 데드락 해결 방법 데드락 예방 : 데드락 발생 조건 4가지를 원천 봉쇄하는 방법\n데드락의 회피 : 자원이 어떻게 요청될지에 대한 추가정보를 제공하도록 요구하는 것으로 자원 할당상태를 검사하는 방법\n데드락 탐지 \u0026amp; 회복 : 데드락이 발생했을때 해결하는 방법\n데드락 무시 : 아주 적은 확률로 데드락이 발생한다면, 무시하는 방법\n무시하거나 재실행하는 편이 자원적으로 더 이득을 볼 수도 있기 때문에 수행하는 방법\n◾ 데드락 방지 방법들 락 정렬 : 모든 락이 항상 같은 순서로 획득된다면 데드락은 발생하지 않기 때문에 효과적이나 락의 순서를 알고 있는 상태에서만 사용이 가능하다. (데드락 예방)\n락 타임 아웃 : 락을 획득하기 위해 기다리는 시간을 정해놓고 시간이 지난 후에는 락을 다시 시도하는 방법 (데드락 탐지\u0026amp;회복)\n같은 락을 획득하려는 다른 모든 쓰레드에게 기회를 주는 것이기 때문에 공정성 문제가 발생하게되고, 데드락 뿐만이 아닌 작업을 처리중에도 타임아웃이 발생할 수 도 있다.\n데드락 감지 : 자료구조를 이용하여 쓰레드가 락을 획득하면 저장하고 이를 이용해 데드락을 감지하고 데드락이 발생했다면, 락을 해제하는 방법\nAtomic Variable : volatile 키워드나 java.util.concurrent.atomic 클래스를 이용하여 원자 변수를 사용하는 방법\n쓰레드 풀 쓰레드를 미리 만들어 필요할때 사용하고 반납할 수 있도록 하는 풀장의 개념\njava.util.concurrent.Executors에서 스레드풀 관련 API를 제공한다.\n◾ 장점 스레드를 생성/수거하는데 비용이 적다. 위의 이유로 다수의 사용자 요청을 처리할때 빠르게 대응 가능하다. ◾ 단점 사용하는 양보다 많이 생성해두면 메모리 낭비가 된다. 노는 스레드가 발생할 수 있다. ◾ 쓰레드 풀의 구조 Task의 요청을 받는 Queue\n실제 쓰레드를 생성하고 관리하는 manager\nQueue 안에서 Task를 꺼내와 실제 쓰레드위에 동작시켜 결과를 얻는 부분\n◾ 생성 메서드 Executors.newFixedThreadPool(10) : 최대 쓰레드를 10개까지 만드는 풀\nExecutors.newCachedThreadPool() : 쓰레드 수의 제한을 두지 않는 풀로 쓰레드 시작 요청이 들어올때 생성하고 종료시에 바로 죽지않고 짧은 시간(1분)동안 살아있는 방법의 풀\nExecutors.newSingleThreadExecutor() : 하나의 쓰레드를 생성하는 풀로 쓰레드 작업중에 예외상황이 발생한 경우 예외처리를 위한 쓰레드용으로 많이 사용한다.\nExecutors.newScheduledThreadPool() : 일정 주기마다 반복해야하는 스레드를 여러개 생성하기 위한 풀\n적정 스레드풀의 사이즈는 어떻게 알까? Reference https://nesoy.github.io/articles/2018-09/OS-Concurrency-Parallelism https://ryan-han.com/post/java/java-thread/ https://zbomoon.tistory.com/12 https://widevery.tistory.com/28 https://goscala.tistory.com/171 https://tourspace.tistory.com/54 "},{"section":"Blog","slug":"/blog/java/datatype/","title":"DataType과 변수","description":"DataType과 변수,리터럴,타입 변환,타입 추론에 관하여 정리","date":"2021년 1월 22일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다.\n자바에서 데이터 타입은 크게 원시(Primitive) 타입 과 참조(Reference) 타입 이 있다.\n1. Primitive Type 정수, 실수, 문자, 논리 리터럴과 같은 실제 데이터 값을 저장하는 타입\n종류 데이터 타입 크기(byte) 기본 값 범위 논리형 boolean 1byte false true, false 문자형 char 2byte \\u0000 0 ~ 65,535 정수형 byte 1byte 0 -128~ 127 정수형 short 2byte 0 -2^15 ~ 2^15 - 1 정수형 int 4byte 0 -2^31 ~ 2^31 - 1 정수형 long 8byte 0L -2^63 ~ 2^63 - 1 실수형 float 4byte 0.0F 1.4E-45 ~ 3.4028235E38 실수형 double 8byte 0.0 4.9E-324 ~ 1.7976931348623157E308 1) boolean c와 같이 true와 false를 표현하는데 1bit만 있으면 될 것 같지만 Java는 데이터 최소범위가 1Byte이기 때문에 boolean도 1byte의 크기를 갖는다.\n2) char c의 경우 1byte의 크기를 같지만 Java는 유니코드를 표현하기 위해 기본 2byte를 갖으며, Java의 원시 데이터타입중 유일하게 unsigned형태이다.\n3) 정수형 JVM의 스택이 기본적으로 피연산자를 4byte 단위로 저장하기 때문에 int보다 작은 자료형의 값을 계산할때 int형으로 형변환되어서 연산이 수행되기 때문에 굳이 byte와 short형을 사용할 필요는 없어 보인다.\nJVM은 int형을 정수형의 기본 데이터 타입으로 사용하기 때문에 long을 사용하고자 한다면 뒤에 l or L을 붙여야 한다.\nNote\nJava8 이후부터는 Integer와 Long의 Wrapper클래스에 unsigned 관련 메소드가 추가되어 unsigned 형태도 이용이 가능하다.\n4) 실수형 double형이 기본 데이터 타입으로 float형을 사용하고자 한다면 뒤에 f or F를 붙여 주어야 한다.\n메모리 크기는 int,long과 같지만 실수형은 부동소수점 방식으로 저장하여 더 많은 범위를 저장 할 수 있다.\nfloat의 경우 부호(1bit)+지수(8bit)+가수(23bit), double의 경우 부호(1bit)+지수(11bit)+가수(52bit)로 나누어 저장하게 되어 표현범위가 고정 소수점방식보다 넓지만 실수 표현에 있어 근사치를 표현하기 때문에 오차가 존재하는 단점을 갖고있다.\n(0.1을 1000번 더하게 되면 100이 되어야 하지만 100.09999\u0026hellip; 와 같은 근사값이 출력된다.)\nfloat의 경우 소수점 아래 9자리, double의 경우 18자리까지 표현이 가능하다.\n같은 데이터 타입에서도 int,long / float,double형으로 나눈 이유는 메모리를 효율적으로 사용하기 위해서 이다.\n닭 잡는데 소 잡는 칼을 사용하는 것은 낭비이기 때문이다.\n2. Refrerence Type 영어 의미 그대로 참조 타입으로 저장되는 값이 원시데이터와 다르게 실제 값이 아닌 메모리 주소값이 저장되는 타입으로 문자열,배열,enum,class,interface등이 있다.\nJVM의 Runtime Data Area중 참조 타입 변수는 런타임 스택 영역에 실제 객체는 힙 영역에 저장되어 객체를 사용할때 마다 참조 변수에 저장된 객체의 주소를 불러와 사용한다.\n위에서 말한것과 같이 실제 데이터는 힙 영역에 저장되며 데이터 크기는 정해져있지 않고 동적으로 할당되며 참조하는 변수가 없다면 Garbage Collector가 제거하여 메모리를 관리한다.\n1) Boxing : 원시 타입을 참조 타입으로 변환시키는 것 2) Unboxing : 참조 타입을 원시 타입으로 변환 시키는 것 Auto Boxing기능으로 명시적으로 작성하지 않아도 자동으로 Boxing 을 해준다.\nint i= 1; Integer integer = i; //Auto Boxing 3) 특징 null을 포함할 수 있다.\nint example = null; //error Integer integer = null; 제네릭 타입에서 사용할 수 있다\nList\u0026lt;int\u0026gt; list; //error List\u0026lt;Integer\u0026gt; list; 데이터 접근 속도가 원시타입에 비해 느리다\n원시타입은 스택에서 바로 사용이가능하나 참조타입은 스택에서 메모리주소를 갖고 힙에 접근하는 방법으로 값을 필요할때마다 Unboxing을 거쳐야하기 때문에 접근속도가 느려지게 된다.\n하지만, 큰 크기의 데이터 접근이 아닌 전달,복사의 경우에는 원시타입보다는 참조타입이 좋을 수도 있다.\n3. 리터럴 메모리에 저장되어 변하지 않는 값을 뜻하며 컴파일 타임에 정의되어 그대로 사용하는 값\n대입 연산에서 모든 우항의 값들을 보통 리터럴이라고 부른다.\nboolean isTrue = true; char c = \u0026#39;C\u0026#39;; int i = 1001; long il = 1001L; float f = 1.1234F; double d = 1.1234; String str = \u0026#34;hello\u0026#34;; 와 같이 우항에 있는 내가 정의한 값들로 변하지 않는 값들을 의미한다.\nint i = 100_000_000; Java 8 이후에은 리터럴에 _ 를 구분자로 사용하여 큰 숫자사이에 , 을 찍어 보기편하게 하는 것처럼 이용을 할 수 있다.\n4. 변수 선언 및 초기화 방법 1) 변수 선언 (데이터 타입) (변수명1),(변수명 2)... ; --Example -- int i; int j,k,l; 위와 같이 하나의 변수를 선언이 가능하고 동시에 여러개도 가능하다.\n2) 변수 초기화 선언 후 초기화\nint i; i =10; 선언과 동시에 초기화\nint i=10; 5. 변수의 스코프와 라이프타임 변수의 스코프란 해당 변수에 접근할 수 있는 범위를 나타내는 것으로 중괄호 {} 를 통해 스코프를 나누는 블록 스코프이고 해당 변수가 언제까지 존재하는지가 라이프 타임이다.\n지역변수의 라이프타임과 스코프는 코드 블럭에 국한된다.\npublic class example { public static void main(String[] args){ int i =1; if(true){ int j=2; System.out.println(i); } System.out.println(j); //error } } 위의 코드에서 if내에서 i를 접근할때 if의 코드 블럭에서 i를 찾고 없으면 그보다 상위 블럭인 class 블럭에서 i를 찾아 접근이 가능하지만 j는 if내에 선언되어 if의 블럭({}) 에 국한되기 때문에 if밖에 나와서는 접근이 불가능하고 if의 블럭이 끝나면서 if에 국한되어있던 지역 변수들은 스택영역에서 소멸된다.\n레퍼런스 타입저장시에 저장되는 힙 영역데이터의 라이프 타임은 가비지 컬렉터가 관리한다.\npublic class example { public static void main(String[] args){ String str = \u0026#34;Test\u0026#34;; System.out.println(str); str = null; System.out.println(str); } } str은 Test라는 힙영역에 저장된 데이터를 참조하는 변수인데, str=null; 부분을 통해 Test를 가리키는 변수는 더이상 존재하지 않게 되어 가비지 컬렉터가 힙영역에서 Test라는 데이터를 제거하게 된다.\n이처럼 참조 타입의 힙 영역에 저장되는 데이터는 아무도 참조하지 않게 되었을때 소멸된다.\n6. 타입 변환, 캐스팅 , 타입 프로모션 특정 데이터 타입의 값을 다른 데이터 타입의 값을 변환 하는 것\n1) 타입 프로모션 자신의 표현범위를 모두 포함한 데이터 타입으로 변환\nbyte -\u0026gt; int, int-\u0026gt; long 와 같이 더 큰 범위를 갖는 데이터 타입으로 변환의 경우가 속하거나 int -\u0026gt; float 와 같이 같은 크기여도 표현범위를 모두 포함할 수 있다면 프로모션이다.\nfloat -\u0026gt; long 의 경우 데이터 크기로만 보면 프로모션이라고 생각할 수 있지만, long은 실수를 저장할 수 없기 때문에 데이터 손실이 일어나 프로모션이라고 할 수 없고 캐스팅이라고 볼 수 있다.\nlong l = 1234L; float f = l; 위 코드와 같이 프로모션의 경우 데이터 손실이 발생하지 않고 자동으로 형변환을 시켜준다.\n2) 타입 캐스팅 : 자신의 포현 범위를 모두 포함하지 못한 데이터 타입으로 변환 int-\u0026gt;byte, long -\u0026gt; int 와 같이 큰 데이터크기에서 작은 크기의 데이터 타입으로 변환할때나 float -\u0026gt; long 과 같이 데이터 표현범위가 달라지는 경우에 속하며 데이터 손실이 일어 난다.\nfloat f = 1.234f; long l = f; 위의 코드와 같이 자동으로 캐스팅을 하려고한다면 데이터 손실이 발생할 수 있기 때문에 컴파일타임에 오류를 발생 시킨다.\n그래도 형변환을 하고 싶다면 강제형변환을 사용할 수 있지만 데이터 손실이 발생하게 된다.\nfloat f = 1.234f; long l = (long)f; System.out.println(l); // 1 7. 1차, 2차 배열 선언 배열 변수 선언과 동시에 초기화를 통해 선언 하는 방식과 new를 이용하는 방식이 있다.\nclass ArrayExample { public static void main(String[] args) { //1차원 배열 int[] array1 = {1, 2, 3, 4, 5}; int[] array2; array2 = new int[5]; array2[0]=1; array2[1]=2; array2[2]=3; array2[3]=4; array2[4]=5; //2차원 배열 int[][] array3 = {{1, 2}, {3, 4}}; int[][] array4; array4 = new int[2][2]; array4[0][0] = 1; array4[0][1] = 2; array4[1][0] = 3; array4[1][1] = 4; } } 1) 1차원 배열 사진 출처: https://www.notion.so/2-38b5d67c7f5a48238529bb8f1617ea0d\r1차원 배열의 변수(array1,array2)는 스택영역에 존재하며 힙 영역의 주소값을 갖는다.\n힙 영역에는 데이터 타입 크기와 요소 개수에 맞게 할당되어 사용이된다.\n2) 2차원 배열 사진 출처 : https://www.notion.so/2-38b5d67c7f5a48238529bb8f1617ea0d\r2차원 배열의 변수(array3,array4)는 스택영역에 존재하며 힙 영역의 주소값을 갖는다.\n힙 영역에는 실제 데이터값들과 2차원배열의 각 행의 시작주소를 갖는 주소값들이 존재한다.\n8. 타입 추론 Java 10 이후부터 생겨난 기능으로 컴파일러가 값을 보고 데이터 타입이 무엇인지 추론하는 것으로 Js의 var,let와 비슷하다.\n1) 제네릭 public class example{ public static void main(String[] args){ HashMap\u0026lt;String,Integer\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); } } 위와 같이 우항의 \u0026lt;\u0026gt; 안에 값을 입력하지 않아도 좌항의 값을 보고 타입을 추론하여 생성하는 경우\n2) var JS의 var,let과 같이 추론형 데이터 타입으로 생각할 수 있는데, 다른점으로 지역 변수와 선언과 동시에 값이 할당 되어야 한다는 점에서 let과 const를 합친 느낌이다.\npublic class example{ var i = 10; //error public static void main(String[] args){ var j; //error } } Reference https://velog.io/@gillog/%EC%9B%90%EC%8B%9C%ED%83%80%EC%9E%85-%EC%B0%B8%EC%A1%B0%ED%83%80%EC%9E%85Primitive-Type-Reference-Type https://wikidocs.net/81917 https://www.notion.so/2-38b5d67c7f5a48238529bb8f1617ea0d https://blog.naver.com/hsm622/222144931396 "},{"section":"Blog","slug":"/blog/java/jvm/","title":"JVM과 자바 실행","description":"JVM과 자바 실행,컴파일,메모리에 관하여 정리","date":"2021년 1월 22일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"252\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_420x0_resize_q90_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/java/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/java\\/java_hud00de3ae5eccc240e6bde4fc25221cea_109236_100x100_fill_q90_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Java","tags":"Java","content":"백기선님의 유튜브 로 진행하시는 스터디를 진행하며 올리는 정리 블로그입니다.\n1. JVM Java Virtual Machine의 약자로 Java와 OS사이에서 중개자 역할을 하여 메모리 관리, GC(garbage collection)을 수행하는 스택기반의 가상머신으로 C++,C와 같은 언어들과 다르게 OS에 상관없이 동작이 가능하다.\nJava는 C나 C++과 같이 바로 컴파일되는 컴파일 언어가 아니다. 컴파일언어는 컴파일 환경에 따라 다르게 컴파일이 된다는 특징을 가지고 있기 때문에 Java의 가장 큰 특징인 os와 환경에 구애받지 않는 다는 점을 위반하기 때문이다. (파이썬이나, JS는 인터프리터 언어)\n컴파일러는 전체 소스코드를 통해 분석하여 오류가있는지 확인하며 재구성하여 기계어로 바꾸는 반면, 인터프리터는 한 행씩 실행하며 분석을하고(중간 코드로 변환) 중간에 에러가 발생시 그 이후의 코드는 확인하지 않는다.\nJava는 환경에 구애받지 않는다는 특징때문에 자바 컴파일러가 자바코드를 바이트 코드(.class파일)로 변환하고 이를 기계어로 번역해주는 과정을 거치는 인터프리터와 컴파일러를 모두 사용하는 언어이다.\n컴파일러는 기계어로 변환해주는 프로그램인데 기계어가 아닌 바이트코드로 변환해주는 프로그램을 자바 컴파일러라고 부르는 이유는 바이트코드는 기계어로 변환해주는 JVM을 위한 언어이고 JVM도 기계이기 때문에 자바 컴파일러라고 부른다.\n자바 인터프리터느 자바 컴파일러에 의해 변환된 바이트코드를 다른 환경의 JVM에서 실행할 수 있도록 기계어로 변환해주는 역할을 한다.\n환경에 구애받지 않는다는 인터프리터의 장점을 이용하기 위해 컴파일러로 중간언어로 변환 후 이를 기계어로 변환하는 방식을 이용한다.\n2. 컴파일 하는 방법 컴파일 이름 그대로 자바 컴파일러를 이용해 자바코드를 바이트코드(.class파일)로 변환하는 것으로 설치한 jdk의 bin폴더안에 javac이라는 자바 컴파일러가 존재하기 때문에 이를 이용하면 된다.\njavac hello.world.java 요즘은 IDE가 매우 똑똑해졌기 때문에 IDE에 코드를 작성하는 것만으로도 컴파일에러를 잡아낸다.\n1) 컴파일 과정 어휘 분석 : public, class, operator(연산자,괄호등), 리터럴(상수), 등으로 분석하여 나눈것을 어휘소라고 하며 이 어휘소들을 하나의 스트림(토큰 스트림)으로 만드는 과정 구문 분석 : 토큰스트림을 통해 문법에 맞는지 확인하고 틀렸다면 Syntax error를 띄운다. 의미 분석 : 타입검사나 자동 타입 변환을 수행하여 검사하고 에러를 띄운다. 중간 코드(바이트 코드) 생성 3. 실행방법 요즘 대부분은 IDE를 통해 실행하나 CLI의 java명령어를 이용하여 실행이가능하다.\ndefault 패키지라면 바로 파일명을 통해 실행이 가능하며 package를 명시하여 실행도 가능하다.\njava hello_world java java.me.example.hello_world 자바 상위버전의 class파일을 하위 버전으로 실행하려고 하면 대부분 에러가 발생하고 반대의 경우에는 하위 호환성(backward compatible)이라고 하여 실행이 가능하다.\njavac -source \u0026lt;version\u0026gt; -target \u0026lt;version\u0026gt; \u0026lt;java filename\u0026gt; 위와 같은 명령어로 컴파일시 호환성 옵션을 줄 수 있다.\n4. 바이트코드 위에서 설명것 처럼 JVM이라는 기계가 이해할 수 있는 언어이다.\n때문에 자바코드를 바이트 코드로 변환하는 것을 자바 컴파일러라고 부른다.\n5. JVM 구성요소 https://gowoonsori.comimages/java/jvm/jvm.png does not exist\r1) Class Loader 바이트 코드(.class 파일)를 JVM내로 로딩하고 링크를 통해 배치하는 작업을 수행\n런타임 시에 동적으로 클래스들을 로드하기 때문에 이때 클래스를 처음 참조한다.\n로딩시에 클래스가 존재하지 않는다면 클래스를 찾을 수없다고 에러가 발생한다.\n2) Execution Engine 클래스를 실행 시키는 역할로 JVM을 위한 바이트코드를 기계어로 변경하는 작업을 수행\nInterpreter : 바이트 코드를 명령어 단위로 읽어서 실행하고 한 줄씩 수행하기 때문에 속도가 느리다는 말이 나온다.\nJIT (Just In Time) : 인터프리터의 단점을 보완하기 위한 컴파일러로 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 기계어로 바꾸어 실행하는 방식\n기계어는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행이 가능하나 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅하는 것이 유리하기 때문에 JIT컴파일러를 사용하는 JVM들은 내부적으로 메서드의 빈도를 체크하고 정도를 넘었을 경우 수행하는 식으로 스케줄링한다.\nGarbage Collector : 사용하지 않는 메모리를 체크하고 제거하는 garbage Collection을 수행하는 스레드가 존재한다.\n6. Runtime Data Area JVM내의 메모리\nhttps://gowoonsori.comimages/java/jvm/memory.png does not exist\r1) PC Register 스레드가 어떤 부분을 어떤 명령으로 실행할지를 기록하는 부분\n현재 실행중인 메서드가 네이티브가 아니면 JVM명령어 위치에 저장되고 네이티브이면 저장되는 값은 정의 되지 않고 CPU의 Register와 다르게 연산을 위해 필요한 피연산자를 임시로 저장하기 위한 용도로 사용한다.\n현재 수행중인 JVM 명령의 주소를 갖는다.\n2) JVM Stack 매개변수, 지역변수, 리턴 값등 스레드나 메서드의 데이터들을 임시로 저장하는 공간으로 스레드마다 별도의 공간을 갖고있으며, 메서드가 호출될때마다 프레임이 생성되어 이곳에 임시 데이터공간으로 사용하고 메서드가 끝나면 프레임은 삭제되며 스레드가 종료시 스택공간도 제거된다.\n3) Native Method Stack 바이트 코드가 아닌 기계어로 작성된 프로그램을 실행시키는 공간으로 자바가 아닌 다른언어로 작성된 네이티브 메서드를 지원하기 위해 사용되는 스택이다.\n4) Heap 인스턴스화 된 모든 클래스와 배열, 객체를 저장하는 가상 메모리 공간으로 모든 JVM스레드가 공유하는 자원이고 GC에 의해서만 자원이 회수가능하다.\nPermanent Generation : 생성된 객체들의 정보 주소값이 저장된 공간으로 클래스 로더에 의해 로드되는 class,Method등의 메타정보가 저장되는 영역\nReflection(객체를 통해 클래스의 정보를 분석해내는 프로그램 기법)을 사용하여 동적으로 클래스가 로딩되는 경우에도 사용된다.\nYoung Generation\nEden : 객체들이 최초로 생성되는 공간\nSurvivor 0/1 : Eden에서 참조되는 객체들이 저장되는 공간\n대부분의 객체들이 금방 접근 불가 상태가 되기 때문에 많은 객체가 이 영역에 생성되었다가 사라지고 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 한다.\nOld Generation : 접근 불가능 상태로 바뀌지 않고 Young 영역에 남아 있는 객체가 여기로 복사되며, Young 영역보다 크게 할당되고 GC는 적게 발생한다.\n이 영역에서 객체가 사라질 때 Major GC가 발생한다고 한다.\nGarbage Collector의 자세한 내용 5) Static 패키지나 클래스 정보 적재되는데 실제로 호출될때 올라간다.\nstatic 필드/메서드인 클래스 멤버 적재\nJVM이 종료될 때까지 사라지지 않는다.\n6) Method Area 클래스 정보를 처음 메모리 공간에 올릴때 초기화 대상을 저장하기 위한 메모리 공간으로 런타임 상수 풀, 필드와 메서드 데이터, 생성자, 메서드의 코드 내용을 저장한다.\n(사실상 컴파일 된 바이트코드의 대부분이 메소드 바이트 코드이고 바이트코드에는 런타임 상수풀이 아니라 그냥 상수풀이 포함되어있기 때문에 거의 모든 바이트코드가 올라간다고 봐도 무방하다.)\n런타임 상수풀은 이 상수풀을 바탕으로 런타임(메서드 영역에 저장될때)에 만들어진다.\n런타임 상수풀 : 컴파일타임에 이미 알 수 있는 숫자 리터럴 값부터 런타임에 해석되는 메서드와 필드의 참조까지를 포괄하는 여러 종류의 상수가 포함 7. JDK와 JRE 차이 1) JDK Java Development kit의 약자로 컴파일러, 역 어셈블러, 디버거, 의존관계 분석등 개발에 필요한 도구를 제공\n2) JRE Java Runtime Envirmont의 약자로 Class Loader, 실행 명령(java)와 같이 실행에 필요한 라이브러리를 제공\n3) JVM Java Virtual Machine의 약자로 인터프리터, JIT등을 이용하여 바이트 코드를 OS에 맞게 기계어로 변경하여 OS에 독립적으로 실행 될 수 있도록 추상화를 제공\n8. OracleJDK 와 OpenJDK의 차이 JVM은 ORACLE이라는 기업이 JVM의 표준을 정의하면 Amazon이나 Oracle, Azul와 같은 기업들이 표준에 따라 실물을 만들어 제공하게 된다.\n이때, 스펙과 표준을 정의한 Oracle이 배포한 JDK가 OracleJDK이며, 가격 정책이 존재한다.\n다른 기업들이 무료로 배포한 JDK를 OpenJDK라고 한다.\nReference https://asfirstalways.tistory.com/158 https://m.blog.naver.com/ehcibear314/221228200531 https://catch-me-java.tistory.com/9 https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/ "},{"section":"Blog","slug":"/blog/books/cleancode/","title":"Clean Code","description":"Clean Code를 읽으면서 작성해나가는 내용 요약과 생각한 점 정리","date":"2021년 1월 22일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Books","tags":"책, 서평","content":"1장. 깨끗한 코드 코드 품질을 측정하는 유일한 척도 = 분당 내지르는 \u0026lsquo;WTF!\u0026rsquo; 횟수\n코드는 요구사항을 상세히 표현하는 수단 ( 기계가 실행할 정도로 상세하게 요구사항을 명시하는 작업 = 프로그래밍 ) 작성자가 아닌 사람도 읽고 고치기 쉽고 단순하고 직접적이다 중복을 피하고 한 기능만 수행하게 작제 추상화하기 프로그래밍은 코드를 읽는 시간 대 짜는 시간 비율이 9:1 잘 짠 코드도 시간이 지나면 레거시가 되니 조금씩 코드를 정리/개선하자 2장. 의미있는 이름 클래스/메서드 이름 클래스 : 명사, 명사구가 적합 메서드 : 동사, 동사구가 적합 의도를 명확하게 밝히자 ( 코드의 맥락이 코드자체에 명시적으로 드러내자) 잘못된 정보를 피하자 약어를 함부로 사용하지말자 0/O, l/1등과 같이 서로 헷갈리게 하는 변수명을 짓지말자 의미있게 구분하자 단순히 컴파일러나 인터프리터를 통과할 목적의 네이밍하지 말자 a1,a2와 같이 연속된 숫자나, 불용어를 지양하자 ex getAccount(),getAccounts(), getAccountInfo() 와 같은 메서드가 있다면 새로운 프로젝트 참가자는 메서드를 구분하기 힘들다 발음하기 쉬운 이름을 사용하자 검색하기 쉬운 이름을 사용하자 간단한 메서드에서 로컬 변수는 한 문자를 사용하더라도 상수나 대부분의 변수는 긴 이름이름이 검색하기에도 더 편하다 요즘 좋은 IDE들은 몇자 타이핑 안해도 자동 추천해주니 검색성능 면에서는 긴이름이 더 좋다 인코딩을 피하자 마찬가지로 요즘 IDE들은 코드를 컴파일하지 않고도 타입 오류를 감지할 정도로 똑똑하기 때문에 헝가리안 표기법을 지양 하자 한 개념에 한 단어를 사용하자 fetch/get/retrieve 나 controller/manager/driver와 같이 비슷한 의미의 단어를 혼용해서 사용하는 것을 지양하자 add/insert/append 와 같이 추가하는 메서드라고 하더라고 맥락이 다르면 다른 단어를 사용하자 ( 의도 를 명확하게 밝히는 것이 중요! ) 3장. 함수 가능한 한 작고 한가지 기능만 수행하도록 작성하자.\n함수 매개변수로 boolean형 플래그를 넘기는 순간 함수에서 여러가지 일을 하도록 하는 것이다\n4장. 주석 최대한 코드로 의도를 표현하자.\n법적인 내용이나, 정보 제공, 경고, TODO등에 주석을 사용할 수 있다.\n5. 코드 컨벤션 최대한 피해야할 형식들이 존재하고 개개인마다 다르지만, 팀의 컨벤션을 최우선시 하자.\n6. 객체와 자료구조 모든 부분이 객체지향으로 짤 수 없고 이것이 장점만 있는 것은 아니다. 자료구조,절차지향이 더 장점인 부분도 존재하기 때문에 적절히 사용하자.\n디미터의 법칙? 모듈은 자신이 조작하는 객체의 속사정을 몰라야한다\n7. 오류 if와 같은 코드보다는 예외처리를 사용하자.\nnull을 반환하지 말자 (Collection이라면 빈 Collection을 반환)\n8. 깔끔하게 외부 소스 사용하기 학습 테스트라고 하는 해당 라이브러리의 사용법에 대한 테스트 케이스를 작성해보면서 API의 사용법을 익히자. Adapter패턴을 이용해 원하는 인터페이스로 변환하는 방법도 있다.\n9. 테스트 코드 TDD가 핫하고 테스트가 중요하다고 해서 개수만 많이, 품질이 떨어지는 테스트 코드는 오히려 독이다. 테스트 코드도 깔끔하게 작성하자.\ngiven/when/then 으로 나누어 코드를 작성하거나 assert문 하나에 함수하나씩 작성하다 보면 보일러플레이트가 너무 많아지니 TEMPLATE METHOD 패턴을 이용하자\n깨끗한 테스트의 규칙 5가지\nF : Fast I : Independent R : Repeatable S : Self-Validating (로그 파일을 읽는 것이 아닌 true/false로 딱 끝나게하자. 주관적인 판단이 필요없게) T : Timely 10. 클래스 SOLID, 응집도, 캡슐화 등의 객체지향의 기본 개념들이 나온다.\n응집도를 유지하다보면 메서드내에 변수를 사용하지 않는 부분이 나오고 이부분을 메서드로 분리하고 이렇게 응집도가 낮아진 메서드, 변수가 늘어나다보면 여러 클래스로 쪼갤수 있어진다.\n11. 시스템 DI, AOP, Proxy, Factory Pattern 등 조금 더 객체지향적으로 자바를 작성할 수 있게 시작한 프로젝트인 스프링의 기본 개념들이 나온다.\n처음부터 완벽한 코드는 없다. 에자일/TDD/Refactoring과 같은 작업으로 매일매일 점진적인 코드를 작성하면 된다. (어제 작성한 코드로 Lagecy라는 말이 있다\u0026hellip;)\nSRP를 준수한다는 개념도 극으로 달하다보면 이도 오히려 독이다. 많아진 클래스와 메서드를 하나하나 관리하는 것이 더 일이다.\n큰 제목들은 지금까지 목차였고 각 목차에 관한 설명들이 있었고 이 이후부터는 Junit, Main의 args를 데이터 타입에 맞게 분석할 유틸리티, SerialDate와 같은 API를 리팩토링하는 과정을 보여주고 있다.\n내가 이 책을 읽으면서 좋았던 점이 바로 이점인데, 위의 개념설명들은 조금 공부를 진행하다보면 한번씩 들어본 개념들이다. 위 개념들을 실제 어떻게 적용하는지 팀원들간의 어떻게 사용하는지 자세하게 모르는 학생입장에서는 실제 뛰어난 개발자의 의식의 흐름대로 리팩토링하는 과정을 볼 수 있어서 너무 좋았다. (어떤 목적과 어떤 생각으로 왜 어떻게 리팩토링을 수행하였는가를 들을 수 있는점이 좋았다.)\n처음 테스트 코드는 배보다 배꼽이 더 크다고 생각도 했으나 현재는 완벽한 모든 모듈마다 테스트 코드를 작성하지는 못하지만, 프로젝트를 할 때 중요 기능과 실패하는 이유, 코딩 작성전 확인여부같은 것이 필요할때 작성을 하고있고 이것이 정말 도움이 많이 된다는 것을 느끼고 있다. (코드 리팩토링, 오류 수정을 하다보면 필연적으로 로직들이 깨질때가 있는 데 이때 기존의 기능들이 깨지지는 않았는가 아주 간단하게 확인해볼 수 있기 때문이었다.)\n이 책을 읽고 생각한 점은 프로젝트를 진행하면 혼자 진행할 수는 없기 때문에 이런 규칙들을 지켜야겠다는 고집보다는 팀원들의 규칙을 정하고 지키자는 것과 이런 클린 코드, 객체 지향은 결국 무조건 응집도를 강하게 하기 위해 작게 작게 나누는 것이 아닌 중복을 제거하고 의도를 깔끔하게 표현할 수 있을 정도로 유지하는 것이 클린 코드라고 말하는 것 같았다.\n"},{"section":"Blog","slug":"/blog/projects/react-project/1/","title":"PointRee 프로젝트 1 - 설계와 환경 구성","description":"프로젝트 설계와 환경 구성에 대한 기록을 남깁니다.","date":"2021년 1월 21일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"React","content":"웹 전반적인 흐름도 익히고 프레임워크들도 공부하기 위해 토이 프로젝트로 간단한 고객 정보를 관리하고 포인트 적립을 하는 웹을 구현해보고자 한다.\n사용할 스택으로는 크게 React와 Spring Boot를 사용해서 개발해보려고 한다.\nReact는 사용을 해본적이 있고 JS에 관심이 많기 때문에 선택을 하였고, 백을 JS 프레임워크가 아닌 굳이 Spring Boot를 사용하는 이유는 현재 졸업작품에서도 사용을 하고 있고 현재 흥미가 많은 프레임워크이기 때문에 더많은 공부를 위해 사용하기로 했다.\n또한 그런 Rest API로 괜찮은가? 를 꽤 감명깊게 봐서 Spring boot로 한번 Restful한 API를 만들어보고자 했고 이런 백엔드와 프론트영역을 완전히 분리하여 개발하려고 할생각이다.\n개발은 wsl2에서 IntelliJ와 vscode로 진행할 예정이고 React 17을 이용할 예정이다.\nState 관리는 Redux와 saga를 사용해본적이 있지만 현재는 많은 기능이 있는 것도 아니고 코드량이 많아지기 때문에 최근에 본 Recoil을 한번 공부할겸 사용해볼 예정이다. 아직 정식 버전이 나온것이 아니기 때문에 그렇게 추천은 못하겠다.\n전체적인 layout이나 기본 componenet는 Material UI를 이용할 생각이다.\n백엔드는 Java 11, JPA, Security 등을 이용할 생각이다.\n현재 생각 중인 기능 로그인 회원가입 로그아웃 내 정보 수정(포인트 적립율도 여기서 설정) 전화번호 검색 없으면 고객 추가 있다면 구매내역 입력(자동으로 포인트 적립) 고객 정보 조회 고객 정보 수정/삭제 "},{"section":"Blog","slug":"/blog/projects/react-project/start/","title":"포인트 적립을 위한 웹 제작기","description":"포인트 적립과 고객 관리 웹 제작기","date":"2021년 1월 19일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"React","content":"방학때 엄마집에 있으며 엄마 가게를 도와주다가 갑자기 엄마가 운영하는 꽃집에 포인트 적립을 한번 도입해보고 싶다고 하셨다.\n지류로 하는 도장형식은 하기 싫다고 하셨고 운영도 애매하다 하시면서 요즘 태블릿으로 전화번호만 입력하면 포스기랑 연동되어 적립이 된다더라라고 말을 하셨다.\n그런데 이는 년단위 계약에 적지 않은 돈을 지불하는 유료 서비스이고 우리 가게에는 포스기도 없었기 때문에 그럼 내가 만들어줄게라고 농담삼아 던저본 말이 씨가 되어 토이 프로젝트로 진행하게 되었다.\n포스기랑 연동할 생각도 없었기 때문에 간편하게 웹을 이용해 구현할 생각이고 휴대폰이나 태블릿을 사용하는 경우를 생각해서 반응형까지는 생각을 하고 있다.\n혼자하는 토이프로젝트이고 졸업작품도 준비해야하기 때문에 많은 기능을 만들지는 못하기도 하고 사용자는 내가 아니기 때문에 우선 엄마에게 기능 요구사항을 물어보았고 엄마도 요구하는 기능이 많지는 않아 다행이었다.\n엄마가 작성해준 요구사항을 기반으로 웹을 만들어 가며 문제가 되었던 부분, 해결한 방법, 사용한 라이브러리와 이유등을 기록하려고 한다.\n"},{"section":"Blog","slug":"/blog/etc/2020-restrospect/","title":"2020년을 보내며","description":"2020년을 보내며 회고록과 새해 다짐","date":"2021년 1월 5일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"기타","tags":"회고, 2020","content":"2019년도에 했던 2020년 다짐으로 3학년 복학을 하면서 웹 개발 전반적으로 공부도하면서 학점관리와 토익, 토이 프로젝트를 진행하고자 했었다.\n진행한 프로젝트 my-tech : 군휴학과 일반휴학포함 3년 휴학후에 다시 시작하는 컴퓨터과학 공부로써 기초부터 다시 공부하고 기록하기 위한 repository이고, 기본적인 markdown문법을 익히기 위해 md파일로 작성하였으며, git공부를 위해 블로그가 아닌 repo를 이용하여 기록한 글이다.\npacket capture program : 학교 프로젝트로 c의 raw socket을 이용해서 리눅스상에서 동작하는 패킷캡쳐프로그램이다.\n트위터 클론 : 인프런의 조현영님의 강의를 듣고 만든 클론 사이트로 react와 express를 이용한 프로젝트이다.\n포인트 적립 웹 : 포인트 적립의 메커니즘을 공부하고 react를 추가 공부하기 위해 혼자 진행해본 프로젝트\n20년 새로 공부를 시작하면서 마음만큼은 의욕이 앞섰는데, 이렇다할 결과물이 제대로 나온 프로젝트는 없는 것 같아 아쉽다.\n다른 팀프로젝트들도 있긴 했지만 결과가 좋지 않았다.\n팀원들과의 의사소통문제에서 내가 조금 예민하지 않았나 싶고, 작은 프로젝트 매니저의 역할을 수행함으로써 필요한 자질과 나에게 부족한점들을 배울 수 있었다고 좋게 생각하고 있다.\n그래도 24학점씩들으면서 올 한해 고생했다고 스스로에게 말해 주고 싶다.\n🙏 새해 목표 토익 공부 : 졸업을 위해서라도 올해는 토익을 공부해야한다.\nmy-tech : repo를 계속 업데이트하면서 이제 my-tech의 내용들을 blog에 옮겨보려고 생각중이다.\n포인트 적립 웹 : 실제 엄마의 사업에 사용할 포인트 적립 웹을 back을 spring boot, front를 react를 이용하여 만들어보고 실제 배포까지 하여 사용하게 할 예정이다.\n졸업작품 : 졸업작품으로 버스정류장 서버를 spring을 이용하여 완성할 예정\nkubernetes 공부\njava와 js공부\n알고리즘 공부 : 1주일에 최소 2문제씩 풀어볼 생각이다.\n2020년은 코로나로 학교생활도 가정생활도 힘든한해였는데 21년에는 얼른 코로나를 이겨내서 마스크없는 생활을 할 수 있기를 바래본다.\n"},{"section":"Blog","slug":"/blog/projects/packet-capture/","title":"Packet Capture Program 만들기","description":"tcpdump interface모방한 패킷캡쳐 프로그램(packet capture)","date":"2020년 12월 11일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/packet-capture/preview_hub33d495d686e8f776721ec1b1c64c7f6_3644_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"420\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/packet-capture\\/preview_hub33d495d686e8f776721ec1b1c64c7f6_3644_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/packet-capture/preview_hub33d495d686e8f776721ec1b1c64c7f6_3644_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/packet-capture\\/preview_hub33d495d686e8f776721ec1b1c64c7f6_3644_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"packet","content":"Linux환경에서 C를 이용해 raw socket을 이용한 tcpdump의 interface를 모방하는 패킷 캡쳐 프로그램 작성하는 것을 목표로 시작했습니다.\n캡쳐할 정보는 IPv4(이더넷 타입이 0x0800 (ip헤더의 버전이 4)를 기반으로 2계층인 Ethernet 정보부터 패킷을 수집하여 앞에서부터 잘라내면서, Ethernet header | ip header | TCP/UDP/ICMP header | data(payload) 캡쳐 하는 프로그램을 작성해보았습니다.\n응용계층의 http, dns와 네트워크 계층의 icmp에 대해서는 추가적으로 payload도 분석하는 프로그램입니다.\n사용시 주의사항 외부의 컴퓨터를 패킷캡쳐를 시도하려면, 첫번째로 sudo ifconfig eth0 promisc을 통해 무차별 모드로 네트워크를 설정해줘야 합니다.\n그 후에도 외부 컴퓨터는 패킷캡쳐가 진행이 되지 않는데 요즘 랜카드들은 보안문제 때문에 모니터링 모드를 지원하지 않기 때문에 따로 랜카드를 구매하거나 내컴퓨터의 패킷만 캡쳐하면서 공부목적으로 사용하는것이 좋습니다.\n사용방법 repo를 clone하던지 소스코드를 복사하고 Makefile 이용하여 make로 컴파일 후 프로그램을 sudo권한으로 실행시키면 됩니다.\ngit clone https://github.com/gowoonsori/linux_packetCaptureProgram.git make로 compile sudo ./captureProgram 실행 요약내용은 command에 표시되며, 상세 분석내용은 자동으로 현재 날짜T현재시간.txt파일 에 저장됩니다.\nstart 시 protocol port ip options 순으로 입력하여 실행.\nprotocol : * (all ) : tcp / udp / icmp 프로토콜 캡쳐 tcp : tcp 프로토콜 캡쳐 udp : udp 프로토콜 캡쳐 icmp : icmp 프로토콜 캡쳐 port : * (all) : 0~65535 모든 포트번호 캡쳐 0~65535 입력 [ http : 80 / dns : 53 ] ip : * (all ) : 0.0.0.0 ~ 255.255.255.255 모든 ip주소 캡쳐 0.0.0.0 ~ 255.255.255.255 입력 [ localhost : 127.0.0.1 ] options : s : 캡쳐 패킷 data 요약내용으로 출력 a : 캡쳐 패킷 data ascii로 출력 x : 캡쳐 패킷 data hex로 출력 소스 코드 Github으로 보러가기 "},{"section":"Blog","slug":"/blog/settings/port-fowarding/","title":"[WSL2] 포트포워딩과 window에서 workbench로 접속하기","description":"wsl2 포트포워딩과 window에서 workbench로 접속","date":"2020년 11월 29일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Settings","tags":"Wsl2, Port Fowarding","content":"WSL2를 이용하여 개발을 진행서 외부에서 접근하고 싶거나, 배포를 위해 접근하고 싶을 수가 있는데, 문제가 되는 것이 WSL2는 VM과 같은 환경이라 별도의 IP를 갖는다는 점이다.\n그러면 포트포워딩을 하면 되지 않느냐라고 할 수 있는데 맞다 포트포워딩을 하면된다 하지만 재부팅을 할때마다 변경되는 IP에 매번 포트 포워딩을 할 수 없는 노릇이기에 Powershell 파일을 이용하여 재부팅마다 wsl2의 ip를 잡아 특정 포트를 포트포워딩 하는 방법을 남기려고 한다.\n1. 사용자 생성 모든 db,table에 접근 가능한 root권한을 가진 사용자로 외부에서 db를 접근하는 것은 위험한 일일 수 있으니 외부에서 접근하고자 하는 db만 접근권한을 가진 사용자를 생성하여 이를 이용해 접근하자.\ncreate user 사용자이름@\u0026#39;ip주소\u0026#39; identified by \u0026#39;비밀번호\u0026#39;; 위와 같이 create user명령어를 이용하여 외부에서 접근할 사용자를 생성하자\ncreate user gowoonso@\u0026#39;%\u0026#39; identified by \u0026#39;1234\u0026#39;; 나는 위와 같이 입력하여 예제 사용자를 만들었고 \u0026lsquo;%\u0026lsquo;는 모든 외부 ip접속을 허용한다는 뜻이고 특정 ip에서만 접속하려면 ip주소를 입력해주면 된다.\n사진과 같이 mysql에 user가 추가된 것을 볼 수 있다.\n2. 접근 권한 부여 grant all privieges on DB이름.테이블이름 to 사용자이름@\u0026#39;ip주소\u0026#39;; 위와 같이 grant 명령어를 이용해 특정 db와 테이블이름에 접근 권한을 부여하자.\ngrant all privileges on earn_points_web.* to gowoonso@\u0026#39;%\u0026#39;; 나는 earn_points_web이라는 db의 모든 테이블(*)을 아까만든 gowoonso@\u0026rsquo;%\u0026rsquo; 의 사용자에게 접근권한을 부여했다.\nall privileges대신에 select,insert,update을 사용하여 특정 명령어에 대해서만 접근 권한을 부여할 수 도 있고, 모든 db에 대한 접근권한을 부여하고자 한다면 테이블명.* 대신 *.*을 이용하면 된다.\ngrant\r3. PowerShell명령 이용하여 포트포워딩 쉘 스크립트를 이용하여 Powershell파일을 작성해 재부팅시마다 자동으로 이 파일을 실행시키도록 할 것이다.\n파일은 Reference를 참조하였습니다.\n$remoteport = bash.exe -c \u0026#34;ifconfig eth0 | grep \u0026#39;inet \u0026#39;\u0026#34; $found = $remoteport -match \u0026#39;\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\u0026#39;; if( $found ){ $remoteport = $matches[0]; } else{ echo \u0026#34;The Script Exited, the ip address of WSL 2 cannot be found\u0026#34;; exit; } #[Ports] #All the ports you want to forward separated by coma $ports=@(22,80,3306,10000,3000,5000); #[Static ip] #You can change the addr to your ip config to listen to a specific address $addr=\u0026#39;0.0.0.0\u0026#39;; $ports_a = $ports -join \u0026#34;,\u0026#34;; #Remove Firewall Exception Rules iex \u0026#34;Remove-NetFireWallRule -DisplayName \u0026#39;WSL 2 Firewall Unlock\u0026#39; \u0026#34;; #adding Exception Rules for inbound and outbound Rules iex \u0026#34;New-NetFireWallRule -DisplayName \u0026#39;WSL 2 Firewall Unlock\u0026#39; -Direction Outbound -LocalPort $ports_a -Action Allow -Protocol TCP\u0026#34;; iex \u0026#34;New-NetFireWallRule -DisplayName \u0026#39;WSL 2 Firewall Unlock\u0026#39; -Direction Inbound -LocalPort $ports_a -Action Allow -Protocol TCP\u0026#34;; for( $i = 0; $i -lt $ports.length; $i++ ){ $port = $ports[$i]; iex \u0026#34;netsh interface portproxy delete v4tov4 listenport=$port listenaddress=$addr\u0026#34;; iex \u0026#34;netsh interface portproxy add v4tov4 listenport=$port listenaddress=$addr connectport=$port connectaddress=$remoteport\u0026#34;; } 위 파일에서 중간에 $ports=@(22,80,3307,10000,3000,5000); 안에 port forwarding할 포트번호를 넣어주면 된다.\n위 파일을 컴퓨터를 재부팅시마다 실행시키도록 설정해야하는 데 이는 앞에 작성한 글 에 비슷한 내용의 설명이 있기 때문에 생략하겠다.\n재부팅을 하면 파일이 실행되고 포트포워딩이 자동으로 설정되어 wsl2의 ip주소로 외부에서 접근하면 접근이 가능할 것이다.\n4. wsl2 mysql을 window에서 workbench로 접속 처음에 wsl2의 mysql에서 사용자를 localhost로 만들어 window에서 접근하려고 하니 서로 별도의 이더넷으로 분리되어 있기 때문에 localhost로 접속이 불가능했다.\nhttps://gowoonsori.comimages/settings/port-forwarding/error.PNG does not exist\r사용자를 \u0026lsquo;%\u0026lsquo;로 만들어 wsl2의 ip로 접근을 하면 window의 workbench에서 접근이 가능하다.\nsuccess\rwsl에서 mysql포트번호를 3306그대로 이용할 시 window의 mysql포트번호가 3306이라면 충돌이 일어나기때문에 ifconfig로 ip확인후 접속해야 한다.\n하지만 이러면 매번 ip를 입력하는게 귀찮기 때문에 wsl이나 window의 mysql의 포트번호를 바꿔 사용하면 간단하게 해결이된다.\n나는 wsl의 mysql의 포트번호를 3307로 하고 3307을 포트포워딩 설정을 해주었는데 그러면 window에서도 localhost:3307로 접속을 하면 잘 접속이되는 것을 볼 수 있다.\nsuccess2\rReference https://github.com/microsoft/WSL/issues/4150 "},{"section":"Blog","slug":"/blog/etc/2020-11-restrospect/","title":"2020년 11월 회고","description":"블로그 시작한지 2달째 작성해보는 회고","date":"2020년 11월 7일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"기타","tags":"2020, 회고","content":"블로그 시작한지 2달째 작성해보는 회고 (첫 작성한 블로그 후기 보러가기 ) 블로그 작성을 9월을 시작으로 벌써 2달이라는 시간이 지났다. 두달동안 나름 블로그를 열심히 작성해보겠다고 게시글들을 꽤 많이 작성했는데 지금 회고를 작성하면서 돌이켜 생각해보니 잘못 하고있었구나 생각이 든다.\n분명 블로그 작성을 처음 마음먹었을때는 좋은 글솜씨로 작성은 못해도 남들에게 도움이 되는(?) 그런 양질의 블로그를 작성하고자 했고, 글솜씨를 늘려가는 것을 목표로 했었기 때문에 한달에 3편의 블로그 작성을 목표로 시작했었다. 그런데 다른 많은 분들의 블로그 게시글 수가 부럽기도 하고 나도 빨리 방문자 수를 늘려야지하는 마음에 양질의 글이 아닌 게시글 수 채우기에 급급해 의미없는 블로그들을 작성하고 있는 나를 발견했다.\n이 회고를 계기로 마음을 새롭게 잡고 다음과 같이 계획을 수정했다.\n한달에 최소 한편의 블로그를 작성하되 할 수있는 만큼 작성하자.\n초짜 블로거인 나에게 3개라는 목표가 큰 부담감으로 다가왔었던 것 같고 한달에 3개라는 개수를 채우면 끝이라는 마음때문에 느슨해졌던 것 같다.\n공부하는 목적의 repo인 my-tech와 블로그는 분리해서 작성하자.\n위의 이유와 비슷하게 개수를 채우기위해 repo에 있는 내용을 긁어와 블로그를 작성하기도 했었는 데, 이것은 나에게도 도움이 되지 않고 남들에게도 도움이 전혀 안된다고 생각을 했다.\nmy-tech는 배운것을 정리하는 목적으로 작성하고 이를 바탕으로 블로그를 작성할때는 설명 자료 (그림,차트)를 만들고 정리하여 남들에게 도움이 되는 블로그를 작성하려고 한다. (한번 배운것을 남들에게 설명해주는 것이니 나도 한번더 깊게 공부할 수 있는 계기가 될 것 같다.)\n3달 간격으로 회고를 작성하자.\n지금 이렇게 회고를 작성하면서 스스로 반성도 하게되고 공부의욕도 다시 생기게 하는 것을 보아 자아 성찰이 중요하구나를 깨닫고 3달에 한번씩은 회고를 작성하려고 한다.\n좋은 개발자가 되는 것도, 좋은 블로거가 되는 것도 이세상에 어느것 하나 빠르게 되는 것은 없다는 것을 깨닫고 처음(기초)부터 차근차근 해나가볼 생각이다.\n"},{"section":"Blog","slug":"/blog/settings/wsl2-mysql/","title":"[WSL2] Mysql 자동실행 설정하기","description":"wsl2에서 service 자동실행 설정하기","date":"2020년 11월 6일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Settings","tags":"Wsl2, MySQL","content":"[wsl2 설치가 안된 분은 여기를 참고하자 ]\n나는 이번년도에 wsl2를 알게 되어 wsl2을 통해 편하게 개발을 진행하였다.\n그런데, wsl2가 아직 여럿 불편한 점이 있었고 그 중 하나가 wsl2의 자동 실행 미지원이다.\nwsl2는 컴퓨터 시작시 자동 실행을 지원하지 않아 수동으로 ssh나 mysql, nginx와 같은 프로그램들을 실행시켜줘야하는 불편함이 있었다.\n그래서 정말 많은 구글링과 삽질끝에 해결한 방법을 공유하고자 글을 썼다.\n1. 셋팅 방법 셋팅 방법은 생각보다 별거 없었고 원리는 window에서 컴퓨터 시작할때마다 스크립트 파일을 통해 자동으로 실행 시켜주는 것이다.\n방법은 여러 가지가 있는데 아래 방법중 한가지만 택해서 진행하면 된다.\n윈도우의 시작 - 모든 프로그램 - 시작 프로그램 폴더에 파일 등록 로컬 그룹 정책 (gpedit.msc)에 스크립트 파일 등록 작업 스케줄러 에서 작업 등록 1) 공통 작업 .bat파일 (스크립트 파일) 작성 우선 자동 실행을 위해 프로그램들을 실행시켜줄 명령어들을 모은 스크립트 파일을 작성해야한다.\n메모장을 열고 본인이 자동실행 시킬 프로그램 명령어를 아래와 같이 앞에 wsl을 붙여 입력하면 된다.\nwsl sudo service mysql start wsl sudo service ssh start wsl sudo service nginx start wsl sudo service docker start wsl sudo service apache2 start 그 후에 저장을 하는데 저장시 주의사항으로 아래 사진과 같이 모든 파일 형식에 파일이름뒤에 .bat을 붙여 저장하면 된다.\n파일 저장은 편한곳에 하면 되는데 나는 C바로 밑에 wsl2-setting 폴더를 하나 만들어 저장했다.\nsudo 권한 service 명령어 비밀번호 해제 해당 파일을 실행시키면 sudo권한 실행을 위해 비밀번호 입력때문에 자동실행이 막히게 되기 때문에 비밀번호를 해제해줘야 자동실행이 된다.\nwindow 검색창에 bash.exe를 검색하여 실행시키거나, wsl2를 실행시켜 sudo visudo 명령어를 입력하여 설정파일을 열면 nano편집기로 열릴텐데 아래 명령어를 추가하고 ctrl+s 로 저장하고 ctrl+x 를 눌러 빠져나오자.\nsudo ALL=NOPASSWD: /usr/sbin/service 모든 service명령어를 비밀번호 해제하는게 나는 두렵다(?)라고 생각하시는 분은 아래와 같이 해당 명령어만 비밀번호를 해제 해도 된다.\n%sudo ALL=(ALL) NOPASSWD: /usr/sbin/service mysql * %sudo ALL=(ALL) NOPASSWD: /usr/sbin/service ssh * Info\n여기서 중요한 점은 %sudo ALL=(ALL:ALL) ALL 명령어보다 아래에 작성해야 한다는 점이다.\n해당 명령어보다 위에 작성하면 해제해놓은것이 막히기 때문에 명령어보다 아래에 작성하거나 맘편히 맨 아래 작성하면 된다.\n여기서부터는 3가지 방법 중 한가지만 따라하면 된다.\n시작 프로그램 폴더에 파일 등록 로컬 그룹 정책 (gpedit.msc)에 스크립트 파일 등록 작업 스케줄러 에서 작업 등록 나는 gpedit.msc에 파일을 등록하는 방법으로 설정했다. 2) 1번방법 : 시작 프로그램 폴더에 파일 등록 window + R 을 눌러 shell:startup 을 입력하여 폴더를 열어 아까 만들어 두었던 .bat 파일을 이 폴더 안에 복사 해주면 된다.\n3) 2번방법 : gpedit.msc에 파일 등록 윈도우 검색창에 gpedit.msc 를 검색해서 클릭하면 아래와 같이 열릴 것이다.\ngpedit open\r사진을 보면 스크립트 (시작/종료) 가 있고 (로그온/로그오프가) 가 있는데 시작과 로그온은 컴퓨터가 켜졌을때 실행되는 것으로 동작은 비슷하나 시작이 속도가 조금더 빠르다고 한다.\n시작은 켜지면서 실행되고, 로그온은 컴퓨터가 다켜져 바탕화면이 보일때 동작한다고 한다. 하지만, 시작으로 설정해놓고 컴퓨터에 비밀번호가 걸려있으면 이상하게 작동이 잘 되지 않아서, 로그온으로 등록하였다.\nscript\r스크립트(로그온/로그오프)를 클릭하고 로그온을 더블클릭하면 위에와 같은 창이 열리는데 PowerShell 스크립트가 아닌 스크립트에 아까 만들어 두었던 .bat 파일을 넣어줄 것이다.\n추가버튼을 클랙 했으면 아래와 같은 창이 뜨는데 찾아보기버튼을 클릭하여 .bat파일을 넣어주면 되며 매개변수는 작성해줄 필요 없다.\nadd\r4) 3번방법 : 작업 스케줄러에 작업 새로만들기 schedule\r윈도우 검색창에 작업 스케줄러를 검색하여 스케줄러를 띄운 후 작업만들기를 클릭하고 설정들을 아래와 같이 해주면된다.\n일반 https://gowoonsori.comimages/settings/wsl2-mysql/1.png does not exist\r이름은 마음대로 지어도 상관없으며, mysql을 자동실행할 프로그램이라 mysqld라 지었고, 간단하게 설명도 작성해주면 된다.\nhttps://gowoonsori.comimages/settings/wsl2-mysql/system.png does not exist\rNote\n여기서 중요한 것이 사용자 또는 그룹 변경을 클릭해서 SYSTEM으로 실행을 시켜줘야 백그라운드로 동작한다.\n변경을 안해주면 부팅시마다 까만 cmd창이 꺼졋다 켜지는 것을 볼 수 있고, 안해줘도 무방하나 상당히 거슬리기에 SYSTEM으로 실행시키는 것을 추천드린다.\n트리거 start\r트리거는 새로만들기를 클릭하여 작업시작에서 로그온할 때를 클릭하고 확인을 누르면 된다.\n시작할 때가 로그온 할때보다 살짝 더 빠르다고 하는데, 노트북에 비밀번호가 걸려있는 경우에 trigger가 작동하지 않기도 해서 로그온 할때를 추천한다.\n동작 action\r찾아보기를 클릭하여 아까 만들어두었던 .bat파일을 등록시켜주면 된다\n기타 설정 조건 이나 설정등 보면서 필요없는 사항들은 체크,체크 해제 해주면된다.\n나는 조건에 충전기 연결 안되도 자동 실행 되게 전원부분은 모두 해제 했다.\n2. 재부팅 후 확인 재부팅 후 mysql 접속을 시도해보면 잘 접속이 되는 것을 볼 수 있다.\nconnect\rReference https://www.how2shout.com/linux/how-to-start-wsl-services-automatically-on-ubuntu-with-windows-10-startup/ "},{"section":"Blog","slug":"/blog/datastructure/avl-tree/","title":"AVL Tree","description":"AVL Tree의 개념을 공부하고 c++을 이용해 구현 해보고자 한다","date":"2020년 10월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"AVL Tree, Tree","content":"BST (이진 탐색 트리)를 기반으로 둔 Tree.\n어떤 노드를 기준으로 하더라도 왼쪽자식의 깊이와 오른쪽 자식의 깊이 차이가 1을 넘지 않는 트리\n1. 용어 개념 정리 균형치 (Balance factor) : 자식노드의 깊이 차이 ( 왼쪽 서브트리의 높이 – 오른쪽 서브트리의 높이 ) BF는 -1, 0, 1이 기준이며, 이 범위를 벗어난다면, 그 트리의 균형은 깨진것이다. 2. 특징 BST의 모든 특징을 갖는다.\n모든 노드를 기준으로 왼쪽자식의 깊이와 오른쪽 자식의 깊이 차이가 1을 넘지 않는다.\nAVL Tree가 Red Black Tree보다 더 엄격하기 때문에 더 빠른 조회가 가능하나 삽입 / 삭제가 RB Tree에 비해 느리다.\nRB Tree는 Red/Black을 표현할 때 1 or 0** 1비트**만 있어도 되나 AVL Tree는 깊이를 저장할 int타입의 저장이 필요하다.\n삽입, 삭제, 탐색의 시간복잡도는 O(log n)\n3. 사용 예 더 빠른 검색이 필요한 DB에 사용 4. 구현 1) Insert (삽입) BST의 일반 삽입 규칙에 맞게 삽입 후, 첫번째로 불균형한 노드를 찾는다. 이때 불균형한 노드를 z라고 할때, 자식노드가 y, 손자 노드를 x라 한다.\n해당하는 case에 따라 z를 기준으로 부분트리를 회전을 통해 재배열 시켜준다.(rotation , restructuring)\ncase 1 : y는 z의 왼쪽 자식, x는 y의 왼쪽 자식 ( left left ) z를 기준으로 right-rotate 시켜준다.\ncase 2 : y는 z의 왼쪽 자식, x는 y의 오른쪽 자식 ( left right ) y를 기준으로 left-rotate 시켜준 후,\nz를 기준으로 right-rotate 시켜준다.\ncase 3 : y는 z의 오른쪽 자식, x는 y의 오른쪽 자식 ( right right ) ➡ z를 기준으로 left-rotate 시켜준다.\ncase 4 : y는 z의 오른쪽 자식, x는 y의 왼쪽 자식 ( right left ) y를 기준으로 right-rotate 시켜준 후, z를 기준으로 left-rotate 시켜준다.\n2) Delete (삭제) BST의 일반 삽입 규칙에 맞게 삭제 후, 첫번째로 불균형한 노드를 찾는다. 이때 불균형한 노드를 z라고 할때, z의 자식노드중 깊이가 큰 자식 노드를 y, y의 자식노드중 깊이가 큰 자식 노드를 x라 하자.\n해당하는 case에 따라 z를 기준으로 부분트리를 회전을 통해 재배열 시켜준다.(rotation , restructuring) 재배열 과정은 삽입과 동일하다.\nNote\ncase 1 : y는 z의 왼쪽 자식, x는 y의 왼쪽 자식 ( left left )\n➡ z를 기준으로 right-rotate 시켜준다. case 2 : y는 z의 왼쪽 자식, x는 y의 오른쪽 자식 ( left right )\n➡ y를 기준으로 left-rotate 시켜준 후, z를 기준으로 right-rotate 시켜준다. case 3 : y는 z의 오른쪽 자식, x는 y의 오른쪽 자식 ( right right )\n➡ z를 기준으로 left-rotate 시켜준다. case 4 : y는 z의 오른쪽 자식, x는 y의 왼쪽 자식 ( right left )\n➡ y를 기준으로 right-rotate 시켜준 후, z를 기준으로 left-rotate 시켜준다.\n3) Search ( 탐색 ) AVL Tree도 BST의 일종이기 때문에 탐색의 밥법은 일반적인 Bianry Tree의 탐색 방법과 다르지 않다.\n찾는 값이 해당 노드보다 작다면 왼쪽으로 크다면 오른쪽으로 내려가며 값을 탐색\n5. 구현 코드 코드 보기 github에서 보기 /* * C++ 이용하여 AVL Tree 구현하기 * * 목적 : AVL Tree 공부 하기 위해 작성했으며, * C++ 이용하여 작성하시는 분들에게 도움이 되고자 했다. * * 설명 : key 값은 int만 가능 하며 중복 key는 허용 x * 단순 연결 리스트로 구현 * * class AVLTree * * 변수 : root =\u0026gt; root node * * 생성자 : RBTREE =\u0026gt; root 를 null로 초기화 * * 함수 : IsKey =\u0026gt; key값이 있는지 검사하는 함수 * * Insert =\u0026gt; 재귀를 이용한 삽입 함수 (최종적으로 root를 return) * Delete =\u0026gt; 재귀를 이용한 삭제 함수 (최종적을 root를 return) * Balancing =\u0026gt; 삽입 / 삭제후 BF 검사하여 규칙깨졌을시 재조정 함수 * Transplant =\u0026gt; 삭제 시 이용하며, 삭제할 노드의 자식 노드를 부모노드에 연결해주는 함수 * * getHeight(x) =\u0026gt; x의 높이 getter * getBalanceBacotr(x) =\u0026gt; x의 BF 계산하여 return * RotateRight(x) =\u0026gt; x기준 오른쪽으로 회전 * RotateLeft(x) =\u0026gt; x기준 왼쪽으로 회전 * * Inorder,Preorder,Postorder =\u0026gt; 순회 함수 * tree_minimum(x), tree_maximum(x) =\u0026gt; 노드 x 기준으로 가장 왼쪽, 오른쪽 return 함수 * * DisplayMenu, SelectMenu =\u0026gt; 초기 Menu판 print 함수 * Insert_helper,Delete_helper,order_helper,print_helper =\u0026gt; 각각 이벤트 수행시 입력받고 조건 에러 처리 위한 함수 와 tree print 해주는 함수 * * Balancing에서 각 case에 대한 설명은 github에 적어 놓았다. * * 작성자 : gowoonsori * github : https://github.com/gowoonsori/my-tech/tree/master/dataStructure/Tree */ #include \u0026lt;algorithm\u0026gt; // max() 함수 이용 #include \u0026lt;iostream\u0026gt; struct node { int key; node *left = nullptr; node *right = nullptr; int height = 1; }; typedef node *NodePtr; class AVLTREE { private: NodePtr root; //루트 노드 //key값이 있는지 없는지 검사 있으면 pointer 값, 없으면 nullptr NodePtr IsKey(int item) { NodePtr t = root; /*key값을 찾거나 없다면 break*/ while (t != nullptr \u0026amp;\u0026amp; t-\u0026gt;key != item) { t = (item \u0026lt; t-\u0026gt;key) ? t-\u0026gt;left : t-\u0026gt;right; } return t; } /*새로운 key 삽입함수로 root노드 반환*/ NodePtr Insert(NodePtr r, int item) { /*새로운 노드 삽입*/ if (r == nullptr) { NodePtr z = new node; z-\u0026gt;key = item; r = z; return r; } else if (r-\u0026gt;key \u0026lt; item) { //item이 key값보다 크다면 오른쪽으로 이동 r-\u0026gt;right = Insert(r-\u0026gt;right, item); } else { //item이 key값보다 작다면 왼쪽으로 이동 r-\u0026gt;left = Insert(r-\u0026gt;left, item); } r-\u0026gt;height = std::max(getHeight(r-\u0026gt;left), getHeight(r-\u0026gt;right)) + 1; Balancing(r, item); //새로운 노드가 추가되었으므로 재귀적으로 부모노드들 높이 1증가 시켜주고 //Balace Factor 측정하여 2이상이라면 재조정함수 return r; } /*key 삭제 함수*/ NodePtr Delete(NodePtr r, int item) { if (r-\u0026gt;key \u0026gt; item \u0026amp;\u0026amp; r-\u0026gt;left != nullptr) { r-\u0026gt;left = Delete(r-\u0026gt;left, item); } else if (r-\u0026gt;key \u0026lt; item \u0026amp;\u0026amp; r-\u0026gt;right != nullptr) { r-\u0026gt;right = Delete(r-\u0026gt;right, item); } else if (r-\u0026gt;key == item) { Transplant(r); } /*root를 지운게 아니라면*/ if (r != nullptr) { r-\u0026gt;height = std::max(getHeight(r-\u0026gt;left), getHeight(r-\u0026gt;right)) + 1; Balancing(r, item); } return r; } /* balance Factor 측정후 재조정*/ void Balancing(NodePtr \u0026amp;r, int item) { int bF = getBalanceFactor(r); //case 1 (left left) if (bF \u0026gt; 1 \u0026amp;\u0026amp; item \u0026lt; r-\u0026gt;left-\u0026gt;key) { r = RotateRight(r); } //case 2 (left right) else if (bF \u0026gt; 1 \u0026amp;\u0026amp; item \u0026gt; r-\u0026gt;left-\u0026gt;key) { r-\u0026gt;left = RotateLeft(r-\u0026gt;left); r = RotateRight(r); } //case 3 (right right) else if (bF \u0026lt; -1 \u0026amp;\u0026amp; item \u0026gt; r-\u0026gt;right-\u0026gt;key) { r = RotateLeft(r); } //case 4 ( right left) else if (bF \u0026lt; -1 \u0026amp;\u0026amp; item \u0026lt; r-\u0026gt;right-\u0026gt;key) { r-\u0026gt;right = RotateRight(r-\u0026gt;right); r = RotateLeft(r); } } /* 삭제시 자식 이식 함수*/ void Transplant(NodePtr \u0026amp;x) { NodePtr y = x; //y를 통해 노드 삭제 if (x-\u0026gt;left == nullptr) { x = x-\u0026gt;right; } else if (x-\u0026gt;right == nullptr) { x = x-\u0026gt;left; } else { NodePtr z = x-\u0026gt;right; //z : 삭제할 x의 다음으로 가장 작은 수 NodePtr pZ = x; //p[z] : z의 부모 노드 /* 오른쪽 자식중 가장 작은 값*/ while (z-\u0026gt;left != nullptr) { pZ = z; z = z-\u0026gt;left; } x-\u0026gt;key = z-\u0026gt;key; //successor과 key값 교환 /*오른쪽 자식이 가장 작다면*/ if (pZ == x) { x-\u0026gt;right = z-\u0026gt;right; // z의 오른쪽 자식 붙여주기 } else { pZ-\u0026gt;left = z-\u0026gt;right; // 오른쪽 자식의 왼쪽 자식이 있다면 } // 그 z(successor)의 오른쪽 자식 p[z]의 왼쪽에 붙여주기 y = z; //값 삭제를 위해 y \u0026lt;- z; } delete y; } /*높이 getter */ int getHeight(NodePtr r) { if (r == nullptr) return 0; else return r-\u0026gt;height; } /*좌우 자식 깊이 비교하여 Balnace Factor get*/ int getBalanceFactor(NodePtr r) { return getHeight(r-\u0026gt;left) - getHeight(r-\u0026gt;right); } /*x를 중심으로 왼쪽으로 회전*/ NodePtr RotateLeft(NodePtr x) { NodePtr y = x-\u0026gt;right; x-\u0026gt;right = y-\u0026gt;left; y-\u0026gt;left = x; //위치가 바뀌었으므로 높이 재조정 x-\u0026gt;height = std::max(getHeight(x-\u0026gt;left), getHeight(x-\u0026gt;right)) + 1; y-\u0026gt;height = std::max(getHeight(y-\u0026gt;left), getHeight(y-\u0026gt;right)) + 1; return y; } /*y를 중심으로 오른쪽으로 회전*/ NodePtr RotateRight(NodePtr y) { NodePtr x = y-\u0026gt;left; y-\u0026gt;left = x-\u0026gt;right; x-\u0026gt;right = y; //위치가 바뀌었으므로 높이 재조정 y-\u0026gt;height = std::max(getHeight(y-\u0026gt;left), getHeight(y-\u0026gt;right)) + 1; x-\u0026gt;height = std::max(getHeight(x-\u0026gt;left), getHeight(x-\u0026gt;right)) + 1; return x; } /*show tree*/ void print_helper(NodePtr root, std::string indent, bool last) { // print the tree structure on the screen if (root != nullptr) { std::cout \u0026lt;\u0026lt; indent; if (last) { std::cout \u0026lt;\u0026lt; \u0026#34;R----\u0026#34;; indent += \u0026#34; \u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;L----\u0026#34;; indent += \u0026#34;| \u0026#34;; } int height = std::max(getHeight(root-\u0026gt;left), getHeight(root-\u0026gt;right)) + 1; std::cout \u0026lt;\u0026lt; root-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; (\u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; print_helper(root-\u0026gt;left, indent, false); print_helper(root-\u0026gt;right, indent, true); } } /*중위순회*/ void Inorder(NodePtr target) { if (target == nullptr) return; Inorder(target-\u0026gt;left); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; Inorder(target-\u0026gt;right); } /*후위순회*/ void Postorder(NodePtr target) { if (target == nullptr) return; Postorder(target-\u0026gt;left); Postorder(target-\u0026gt;right); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } /*전위순회*/ void Preorder(NodePtr target) { if (target == nullptr) return; std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; Preorder(target-\u0026gt;left); Preorder(target-\u0026gt;right); } public: AVLTREE() { this-\u0026gt;root = nullptr; } //최솟값 찾기 NodePtr tree_minimum(NodePtr x) { while (x-\u0026gt;left != nullptr) { x = x-\u0026gt;left; } return x; } //최댓값 찾기 NodePtr tree_maximum(NodePtr x) { while (x-\u0026gt;right != nullptr) { x = x-\u0026gt;right; } return x; } void DisplayMenuBoard() { std::cout \u0026lt;\u0026lt; \u0026#34; ** AVL Tree ** \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; Menu \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 1. Insert Key \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 2. Delete Key \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 3. Show Tree \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 4. choose order \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 5. show Menu \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 6. clear Display \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 7. exit \u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::endl; } void SelectMenu() { DisplayMenuBoard(); int i = -1; while (i != 8) { std::cout \u0026lt;\u0026lt; \u0026#34;(show Menu : 5) --\u0026gt; select : \u0026#34;; std::cin \u0026gt;\u0026gt; i; switch (i) { case 1: Insert_helper(); break; case 2: Delete_helper(); break; case 3: print_helper(root, \u0026#34;\u0026#34;, true); break; case 4: Order_helper(); break; case 5: DisplayMenuBoard(); break; case 6: system(\u0026#34;cls\u0026#34;); DisplayMenuBoard(); break; case 7: return; default: std::cout \u0026lt;\u0026lt; \u0026#34; !!! Wrong entered !!!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; } } } void Insert_helper() { int item; std::cout \u0026lt;\u0026lt; \u0026#34;Key to insert : \u0026#34;; std::cin \u0026gt;\u0026gt; item; if (IsKey(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;!!! \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; is already exists !!!\\n\u0026#34;; return; } this-\u0026gt;root = Insert(this-\u0026gt;root, item); return; } void Delete_helper() { int item; std::cout \u0026lt;\u0026lt; \u0026#34;Key to delete : \u0026#34;; std::cin \u0026gt;\u0026gt; item; if (!IsKey(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;!!! \u0026#34; \u0026lt;\u0026lt; item \u0026lt;\u0026lt; \u0026#34; is not exists !!!\\n\u0026#34;; return; } this-\u0026gt;root = Delete(this-\u0026gt;root, item); return; } void Order_helper() { int i; std::cout \u0026lt;\u0026lt; \u0026#34; == Order Menu ==\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 1. PreOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 2. InOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 3. PostOrder\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; 4. exit\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34; --\u0026gt; select : \u0026#34;; std::cin \u0026gt;\u0026gt; i; switch (i) { case 1: Preorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 2: Inorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 3: Postorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case 4: return; default: std::cout \u0026lt;\u0026lt; \u0026#34; !!! Wrong enter !!!\\n\u0026#34; \u0026lt;\u0026lt; std::endl; break; } return; } }; int main() { AVLTREE tree; tree.SelectMenu(); return 0; } "},{"section":"Blog","slug":"/blog/etc/tukorea-sw-competition-final/","title":"KPU S/W 경진대회 본선 후기","description":"한국산업기술대학교 알고리즘 대회 본선 후기","date":"2020년 10월 18일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"기타","tags":"회고, 대회","content":"본선일정은 2020.10.14 (수)에 13:30 ~ 17:00까지로 예선 후 1주일 뒤에 잡혀있었다.\n수요일 본선 당일 12시 반까지 있던 수업을 마치고 기숙사에 들려 노트북을 챙겨 시험장소인 소강당으로 향했다.\n도착해서 점심으로 서브웨이와 스프라이트를 받고 자리를 잡자마자 샌드위치를 허겁지겁 먹어치웠다. (아침 점심을 안먹었더니 배가 너무 고팠었다\u0026hellip;😂)\n그런데, 사회적 거리 두기때문에 좀 넓은 곳에서 시험 보려고 소강당에서 시험을 봤으나, 소강당이 일반 책상이 아닌, 팔걸이에 간이 받침대가 숨어있는(?) 그런 의자라서 불편했다.\n시험 시작 전 OT 13:30분에 교수님과 인사하고 강당에서 시험을 보다보니 멀티탭 문제로 시간좀 지체하고 시험 룰 같은 거 이것 저것 설명하다보니 14:00쯤 되어서야 본격적인 시험이 시작되었다.\n시험 시작 시험은 총 8문제가 출제 되었고, 시작하자마자 1번 문제인 후위표기식 문제를 건너뛰고, 2번 문제부터 풀기 시작했다.\n1) Postfix 표현식 문제 보기 Description\n+및-연산자를 사용하여a,…z 알파벳 소문자로작성된 산술 표현식을 고려하십시오.다음은 예입니다. ((a + b)-(((c + d) -e) + a)) 완전히 괄호로 묶인 표현식은다음과 같은 간단한 규칙을 사용하여postfix라는 다른 형식으로 변환 할 수 있습니다. 변수는 그대로 유지됩니다.{a,…, z}의모든x에대해Translate [x] = x. (E1 +E2)형태의 식은Translate[E1] Translate[E2] + 로 변환된다. (E1 - E2)형태의 식은 Translate[E1] Translate[E2] - 로 변환된다. 예를 들어, 위의 표현식은 다음과 같이 번역됩니다. Translate[((a+b)-(((c+d)-e)+a))] = Translate[(a+b)] Translate[(((c+d)-e)+a)] - = Translate[a] Translate[b] + Translate[((c+d)-e)] Translate[a] + - = a b + Translate[(c+d)] Translate[e] - a + - = a b + Translate[c] Translate[d] + e - a + - = a b + c d + e - a + - 당신의 임무는 이 작업의 반대를 수행하는 것입니다. 접미사로 표현되는 postfix 표현식을괄호로 잘 묶인원래 표현식으로 재구성해야합니다. Input\n+,-및 문자a, b,…, z가포함된 postfix 표현식을 포함하는 단일 행 최대 80 개의 기호가 있습니다. Output\n위에서 설명한 번역을 통해 입력postfix 표현식을괄호로 잘 묶인원래 표현식을 출력합니다. Sample Input 1\nab+cd+e-a+- Sample Output 1\n((a+b)-(((c+d)-e)+a)) 2) 다음 순열 문제 보기 Description\n회문(Palindrome)은왼쪽에서 오른쪽으로 읽든, 오른쪽에서 왼쪽으로 읽든 똑같이 읽는 단어입니다. 다음과 같이 알파벳 소문자로만 이루어진 단어에서 회문을 생성하도록 합니다. 알파벳 소문자로 이루어진 단어 word가 있습니다. word를 오른쪽에서 왼쪽으로 읽는 반전 단어 reverse를 생성합니다. word와 reverse를 더합니다. 단어 덧셈은 아래 규칙을 따름니다. 덧셈을 한 단어가 회문이면 그 회문을 출력하고 아니면 단어 반전과 덧셈을 회문이 생성될 때 까지 계속합니다. 단어 덧셈 규칙 단어의 덧셈은 단어를 구성하는 알파벳을 26진수숫자로 (\u0026#39;a\u0026#39; = 0, \u0026#39;b\u0026#39;=1, \u0026#39;c\u0026#39;=2, ..., \u0026#39;z\u0026#39;= 25) 가정해서 숫자 덧셈을 한 후 다시 알파벳으로 변환해서 단어를 생성합니다.다음과 같이 단어 덧셈을 할 수 있습니다. \u0026#39;a\u0026#39; + \u0026#39;a\u0026#39; = \u0026#39;a\u0026#39; \u0026#39;a\u0026#39; + \u0026#39;b\u0026#39; = \u0026#39;b\u0026#39; \u0026#39;b\u0026#39; + \u0026#39;b\u0026#39; = \u0026#39;c\u0026#39; \u0026#39;a\u0026#39; + \u0026#39;z\u0026#39; = \u0026#39;z\u0026#39; \u0026#39;b\u0026#39; + \u0026#39;z\u0026#39; = \u0026#39;ba\u0026#39; 당신의 임무는 위에서 설명한 프로세스를 수행하고 결과 회문을 찾으면 출력하는 것입니다. 예를 들어 \u0026#39;see\u0026#39;가 주어지면 \u0026#39;see\u0026#39;의 반전 단어 \u0026#39;ees\u0026#39;를 생성해서 단어 덧셈을 하면 \u0026#39;wiw\u0026#39;를 얻습니다. 또한 \u0026#39;apple\u0026#39;이 주어지면 다음과 같은 시퀀스를 얻습니다. \u0026#39;apple\u0026#39; \u0026#39;fbfae\u0026#39; \u0026#39;jbkbj\u0026#39; 따라서 이경우에는 \u0026#39;jbkbj\u0026#39; 를 출력해야 합니다. 회문을 찾지 못하는 경우는 없습니다. Input\n알파벳 소문자로만 이루어진 길이 30이하의 단일 단어 Output\n위에서 설명한 프로세스에 의해 생성 된 회문인 단어 Sample Input 1\napple Sample Output 1\njbkbj 주어진 규칙대로 알파벳을 더해주고 조건 만족할때까지 while을 도는 쉬운 문제여서 쉽게 풀 수 있겠다. 하고 시작했는데, 중간에 **\u0026lsquo;p\u0026rsquo; + \u0026rsquo;l\u0026rsquo;**이 어떻게 f가 나오는 지 규칙을 이해를 잘 못해서 많이 헤맸던 문제였다.\n풀면서 머리속에서 너무 꼬여서 거의 다 풀었음에도 불구하고 결국 다음 문제로 넘어가는 것을 선택했다.\nNote\n규칙에서 \u0026lsquo;b\u0026rsquo; + \u0026lsquo;z\u0026rsquo; = \u0026lsquo;ba\u0026rsquo; 가 나온 것을 보고 \u0026lsquo;c\u0026rsquo; + \u0026lsquo;z\u0026rsquo; = \u0026lsquo;bb\u0026rsquo;가 아닌 \u0026lsquo;ca\u0026rsquo;가 될 것이라고 생각 했던 내 멍청함을 탓한다..ㅠㅠ😥\n아래는 시험이 끝난 후 차분히 코드 수정을 한 코드이다. cal함수에서 덧셈 규칙의 잘못 이해한 부분만 수정해주니 잘 돌아가는 것을 볼 수 있었다.\n코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //abcde/fghij/klmno/pqrst/uvwxy/z char out_alp(int num) { switch (num) { case 0: return \u0026#39;a\u0026#39;; case 1: return \u0026#39;b\u0026#39;; case 2: return \u0026#39;c\u0026#39;; case 3: return \u0026#39;d\u0026#39;; case 4: return \u0026#39;e\u0026#39;; case 5: return \u0026#39;f\u0026#39;; case 6: return \u0026#39;g\u0026#39;; case 7: return \u0026#39;h\u0026#39;; case 8: return \u0026#39;i\u0026#39;; case 9: return \u0026#39;j\u0026#39;; case 10: return \u0026#39;k\u0026#39;; case 11: return \u0026#39;l\u0026#39;; case 12: return \u0026#39;m\u0026#39;; case 13: return \u0026#39;n\u0026#39;; case 14: return \u0026#39;o\u0026#39;; case 15: return \u0026#39;p\u0026#39;; case 16: return \u0026#39;q\u0026#39;; case 17: return \u0026#39;r\u0026#39;; case 18: return \u0026#39;s\u0026#39;; case 19: return \u0026#39;t\u0026#39;; case 20: return \u0026#39;u\u0026#39;; case 21: return \u0026#39;v\u0026#39;; case 22: return \u0026#39;w\u0026#39;; case 23: return \u0026#39;x\u0026#39;; case 24: return \u0026#39;y\u0026#39;; case 25: return \u0026#39;z\u0026#39;; default: break; } return 0; } bool check(string str) { int i, j = str.length() - 1; for (i = 0; i \u0026lt; str.length() / 2; i++, j--) { if (str[i] != str[j]) return false; } return true; } void cal(string \u0026amp;str, string r_str, string \u0026amp;ans) { char a2, b2; for (int i = str.length() - 1; i \u0026gt;= 0; i--) { int a = (str[i] - \u0026#39;a\u0026#39; + r_str[i] - \u0026#39;a\u0026#39;) / 26; int b = (str[i] - \u0026#39;a\u0026#39; + r_str[i] - \u0026#39;a\u0026#39;) % 26; if (a == 1) str[i - 1] += a; ans += out_alp(b); } } void rule(string \u0026amp;str) { string ans = \u0026#34;\u0026#34;; string r_str = str; reverse(r_str.begin(), r_str.end()); cal(str, r_str, ans); str = ans; } int main() { string input; cin \u0026gt;\u0026gt; input; while (!check(input)) { rule(input); } cout \u0026lt;\u0026lt; input; return 0; } 3) 조이 스틱 문제 보기 Description\n조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다. ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로JAZ를 만들 수 있습니다. 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 \u0026#34;JAZ\u0026#34;를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 입력으로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 출력하세요. Input\n만들고자 하는 이름 name 이 첫번째 줄에 입력됩니다. 제한사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. Output\n이름에 대해 조이스틱 조작 횟수의 최솟값을 출력하세요. Sample Input 1\nJEROEN Sample Output 1\n56 Sample Input 2\nJAN Sample Output 2\n23 과거에 프로그래머스를 통해 풀어본 문제였기에 수월하게 풀이를 진행 했다.\ninput의 문자열 길이만큼 초기값 A로 세팅을 해주고, 알파벳의 중간값인 M을 기준으로 작으면 알파벳 순번을, 크다면 역으로 셀 경우가 작게 나오기 때문에 Z에서 char 번호만큼 빼준 값을 통해 각 알파벳을 선택하기위한 조이스틱 횟수를 answer에 더해줬다.\n또한, input2의 case처럼 JAN에서 첫번째 글짜를 J로 설정하고 다음 글자를 선택하려고 할때 두번째 글짜는 A가있는 오른쪽으로 이동하는 것보다 왼쪽으로 이동하는 것이 더 적은 횟수를 사용할 수 있기 때문에 조이스틱을 mov하는 과정도 왼쪽으로 이동하는 경우와 오른쪽으로 이동하는 경우를 비교하여 더 최선인 방향을 선택하는 식으로 풀이를 진행했다.\n코드 보기 #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int sol(string name) { int answer = 0; int i=0; string tmp(name.length(),\u0026#39;A\u0026#39;); while(1){ tmp[i] = name[i]; answer += (name[i] \u0026lt;= \u0026#39;M\u0026#39;) ? (name[i] - \u0026#39;A\u0026#39;) : (\u0026#39;Z\u0026#39; - name[i] + 1) ; if(!tmp.compare(name)) break; for(int mov = 1; mov \u0026lt; name.length() ; mov++){ if(name [(i + mov) % name.length()] != tmp[(i + mov) % name.length()]){ i = (i + mov) % name.length(); answer += mov; break; } else if(name [(i + name.length() - mov) % name.length()] != tmp[(i + name.length() - mov)% name.length()]){ i = ( i + name.length() - mov ) % name.length(); answer += mov; break; } } } return answer; } int main(){ string input; cin \u0026gt;\u0026gt; input; cout \u0026lt;\u0026lt; sol(input); return 0; } Note\n두 문제를 풀이하고 (정확히는 한문제다..) 남은 시간을 보니 모든 문제는 풀기에 가망이 없어 보였기 때문에 집중해서 풀어낼 문제를 선택해야 했다.\n현재 문제 상황을 보니 의외로 끝의 문제들이 합격률이 괜찮았고, 뒷 문제일수록 배점이 좋았기 때문에 이때부터 뒤의 문제부터 풀이를 해나갔다.\n4) 사회적 거리두기 2 문제 보기 Description\n전세계적으로 퍼진 신종 코로나-19 감염병 예방을 위해서 김교수는 일렬로 배치된 N명(1≤N≤1000) 학생들에게 사회적 거리두기를 시행하고 있습니다. 그러나 이러한 사회적 거리두기에도 불구하고 이미 코로나-19에 감염된 학생과 반경 R 이내에 있는 다른 건강한 학생은 코로나-19에 감염됩니다. 김교수는 R값은 정확히 모르지만 N명 학생들의 위치와 감염여부는 알고 있습니다. 전체 N명 학생들이 전부 감염될 수 있는 최소한의 감염 학생 수를 결정하십시오. Input\n입력의 첫번째 줄에는 학생 수 N 그 다음 N개 줄에는 각각 학생의 위치x(0≤x≤10^6)와 감염여부 s (0 : 건강한 학생, 1: 감염된 학생) 두 개의 정수를 갖습니다. 최소한 한명의 학생이 감염되면 반경 R이내의 학생들은 연속으로 코로나-19에 감염될 수 있습니다. Output\n코로나-19 감염병이 전체 학생 N명에게 퍼질 수 있는 최소 학생 수를 출력하십시오. 예를 들어서 입력이 다음과 같다고 가정하면, 9 7 1 1 1 16 1 3 1 15 1 10 0 6 1 18 1 21 1 이 경우에 우리는 R \u0026lt; 3 임을 알 수 있습니다. 그렇지 않다면 7번 위치 학생이 10번 학생을 감염 시켰을 것입니다. 따라서 이 경우에는 최소한 4명 학생이 (1과 3 위치에 학생 중에서 한명, 6과 7 위치에 있는 한명, 15와 16과 18 위치 학생 중에서 한명, 21위치 학생 한명) 감염되어야 전체 학생들에게 감염을 시킵니다. 따라서 이 경우 정답은 4 입니다. 4 Sample Input 1\n9 7 1 1 1 16 1 3 1 15 1 10 0 6 1 18 1 21 1 Sample Output 1\n4 5) 중요한 교차로 문제 보기 Description\n긴 장마철이 지나고 망가진 도로 보수를 위해서 시흥시는 시내의 모든 교차로를 재포장하기로 결정했습니다. 교차로를 포장하려면 해당 교차로를 통과하는 모든 교통을 통제해야 합니다. 그런데 교차로들 중에서 중요한 교차로는 교통 통제에 주의해야 합니다. 예를 들어서 교차로 J에서 교차로 K를 가려면 반드시 교차로 I를 통과해야 한다면, 교차로 I를 통제하면 J에서 K로 가는 길이 막히므로, 교차로 I를 중요한 교차로라고 합니다. 시흥시의 도로는모두 양방향 통행이 가능하며, 모든 교차로를 이용할 수 있다면 어느 교차로에서 든지 다른 교차로로 갈 수 있습니다.시흥시 도로의 이름은 오직 2개의 교차로를 연결하고 다른 교차로는 통과하지 않습니다. 예를 들어서5 개의 교차로I1,I2,I3,I4,I5가 있고 6개의 도로가있다고 가정합니다. 도로 1은I1과I2를연결합니다. 도로 2는I2와I3을연결합니다. 도로 3은I1과I3을연결합니다. 도로 4는I2와I4를연결합니다. 도로 5는I2와I5를연결합니다. 도로 6은I5와I4를연결합니다. 그러면 I2를 교통 통제하면 I4에서 I1 (혹은 I3)으로 가는 길이 없으므로 I2는 중요한 교차로 입니다. 또한 I5에서 I1 그리고 I5에서 I3로 가는 길도 끊깁니다. I2이외의 더 이상의 중요한 교차로는 없습니다. 당신이 할 일은 시흥시 교차로와 도로 정보를 살펴보고 중요한 교차로 목록을 결정하는 것입니다. Input\n입력의 첫 번째 줄에는 두 개의 정수N과M이있습니다. N은 시흥시의 교차로 수이고M은 도로 수입니다. 교차로의 번호는 1,2, ...,N이라고 가정합니다. 다음M개 줄(2, ...,M+1번째 줄)은 시흥시의 도로를 나타냅니다. i+1번째 줄은도로i로연결된 교차로 쌍을 나타내는1, ...,N범위의 두 정수를 포함합니다. N≤ 300, M≤ 50000 입니다. Output\n출력의 첫 번째 줄에는 중요한 교차로 개수를 나타내는정수C를 출력합니다. 다음C개 줄에는한 줄 당 하나씩 중요한 교차로 번호를 출력합니다. 중요한 교차로가 여러개 이면 교차로 번호 오름 차순으로 출력합니다. Sample Input 1\n5 6 1 2 2 3 1 3 2 4 2 5 5 4 Sample Output 1\n1 2 Hint\n- A 교차로가 중요한 교차로가 아니라면, A 교차로를 제외한 다른 임의의 교차로에서 시작해서 나머지 모든 교차로를 방문할 수 있다. - A 교차로가 중요한 교차로라면,A 교차로를 제외한 다른 임의의 교차로에서 시작해서 나머지 모든 교차로들을 방문하려고 할 때 하나라도 방문하지 못하는 교차로가 존재한다. 6️) 여행 경로 문제 보기 Description\n주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 ICN공항에서 출발합니다. 항공권 정보가 담긴 tickets가 입력으로 주어질 때, 방문하는 공항 경로를 출력합니다. 제한사항\n모든 공항은 알파벳 대문자 3글자로 이루어집니다. 주어진 공항 수는 3개 이상 10,000개 이하입니다. tickets의 각 행 a b는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다. 주어진 항공권은 모두 사용해야 합니다. 동일한 경로를 가지는 항공권이 있을 수 있습니다. 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 출력합니다. 모든 도시를 방문할 수 없는 경우는 주어지지 않습니다. 입력으로 첫번째 줄에는 ticket의 개수가 주어지고 그 다음 N개 줄에는 항공권 정보를 나타냅니다. 다음과 같은 3장의 ticket에 대한 정보가 주어진다고 합시다. 3 ICN JFK HND IAD JFK HND 그러면 방문 순서는 ICN JFK HND IAD 과 같습니다. 또 다른 예로 5장의 ticket에 대한 정보가 주어진다고 합시다. 5 ICN SFO ICN ATL SFO ATL ATL ICN ATL SFO 그러면 ICN SFO ATL ICN ATL SFO 순으로 방문할 수도 있지만 ICN ATL ICN SFO ATL SFO 가 알파벳 순으로 앞섭니다. Input\n입력의 첫째 줄에는 ticket의 개수를 나타내는 단일 정수 N 이 나타납니다. 그 다음 N개 줄에는 각줄 마다 출발 공항 a와 도착 공항 b가 나타납니다. Output\n방문 공항 순서대로 공항 이름을 한 줄에 하나씩 출력합니다. Sample Input 1\n3 ICN JFK HND IAD JFK HND Sample Output 1\nICN JFK HND IAD Sample Input 1\n5 ICN SFO ICN ATL SFO ATL ATL ICN ATL SFO Sample Output 1\nICN ATL ICN SFO ATL SFO 문제를 보고 dfs 나 bfs로 풀면 되겠다 생각하고 접근했으며, 도착하기까지의 경로가 여러개 일 수 있기 때문에 모든 경로를 저장하는 배열을 전역변수로 선언하여 경로를 구하고 알파벳순으로 sort하여 가장 앞의 경로를 답으로 제출하는 식으로 풀이를 진행했다.\nhttps://gowoonsori.comimages/etc/tukorea-sw-competition-final/timeLimit.png does not exist\r풀이를 진행하고 보니 4개의 case중 1개의 case가 time Limit으로 부분 통과 하였다.\nNote\n모든 경로를 계산 하는 것 때문이 아닐까 싶다\u0026hellip; 지금 생각해보니 먼저 input의 경로를 sort하고 dfs를 진행했다면 괜찮았을 것 같다.\n코드 보기 #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; all_routes; void dfs(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; tickets, vector\u0026lt;bool\u0026gt; \u0026amp;visited, int cnt, int start, vector\u0026lt;string\u0026gt; \u0026amp;route) { visited[start] = true; route.push_back(tickets[start][0]); if (cnt == tickets.size()) { route.push_back(tickets[start][1]); all_routes.push_back(route); route.pop_back(); return; } for (int i = 0; i \u0026lt; tickets.size(); i++) { if (!visited[i] \u0026amp;\u0026amp; tickets[start][1] == tickets[i][0]) { dfs(tickets, visited, cnt + 1, i, route); visited[i] = false; route.pop_back(); } } } vector\u0026lt;string\u0026gt; sol(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; tickets) { vector\u0026lt;string\u0026gt; route; vector\u0026lt;bool\u0026gt; visited; int cnt = 1; for (int i = 0; i \u0026lt; tickets.size(); i++) { if (tickets[i][0] == \u0026#34;ICN\u0026#34;) { visited.assign(tickets.size(), false); route.clear(); dfs(tickets, visited, cnt, i, route); } } sort(all_routes.begin(), all_routes.end()); return all_routes[0]; } int main() { int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; tickets(N, vector\u0026lt;string\u0026gt;(2, \u0026#34;\u0026#34;)); vector\u0026lt;string\u0026gt; answer; for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; tickets[i][0] \u0026gt;\u0026gt; tickets[i][1]; } answer = sol(tickets); for (auto n : answer) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } return 0; } 7️) 위성 이미지 문제 보기 Description\n기상청은 매일 기상 위성에서 이미지를 수신합니다.이 이미지는어두운 배경에구름을 나타내는 흰색 영역이 있습니다. 기상청은 폭풍에 대해 다소 단순화 된 모델이 있습니다. 특정 크기를 초과하는 흰색 영역은 폭풍이 되어야 한다고 결정했습니다. 위성 이미지는#과. 으로 이루어진 격자 이미지이며 . 은 구름을나타냅니다. 위성 이미지 각 포인트에는 최대 8 개의 이웃 (북동, 북, 북서, 동, 서, 남동, 남, 남서)이 있으며, 구름은 이웃과 연속으로 이어진 . 으로 이루어집니다. 아래 위성 이미지는 4개의 구름을 가지고 있습니다. #####.##### ####.####.# ###..##.#.# ##...###### ######..... ########### 만약 폭풍으로 간주할 임계 크기를 4라고 하면, 크기가 4를 넘어가는 구름은 2개가 있으며 아래와 같이 숫자 1과 2의 영역으로 표시할 수 있습니다. #####1##### ####1####.# ###11##.#.# ##111###### ######22222 ########### 당신이 할 일은위성 이미지와 폭풍으로 간주할 임계 값을 입력받아서,폭풍의 갯수와 가장 큰 폭풍의 크기를 결정하는 것입니다. Input\n입력의 첫 번째 줄에는위성 이미지의 행과 열 수를 나타내는두 개의 정수M과 N이포함됩니다. 그 다음에는 위성 이미지를 설명하는M개줄이 나옵니다. M+2번째 줄에는폭풍을 결정하는 임계 값K가 포함됩니다. 1 ≤M, N≤ 1000 입니다. 입력의 80 %에서1 ≤M, N≤ 60 입니다. Output\n한 줄에 공백으로 구분 된 정수n과s는 각각 폭풍의 갯수와 가장 큰 폭풍의 크기를 나타냅니다. Sample Input 1\n6 11 #####.##### ####.####.# ###..##.#.# ##...###### ######..... ########### 4 Sample Output 1\n2 7 7번 문제도 dfs/bfs를 이용하여 풀었으며, 단순히 개수만 세면 되기 때문에 6번 문제보다 더 쉽게 풀이할 수 있었다. bfs를 이용해서 문제를 풀이 했고, 미로 찾기같이 4방향으로만 움직이는 것이 아닌 대각선으로도 움직일 수 있기 때문에 총 8방향에 대해서 bfs를 수행했다.\n코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int M, N; int K; int answer = 0, answer_max = 0; int dir[8][2] = {{-1, 0}, {-1, -1}, {-1, 1}, {1, 1}, {1, -1}, {1, 0}, {0, -1}, {0, 1}}; void bfs(vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;map, int S_x, int S_y) { int r = 1; //구름 넓이 queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; map[S_y][S_x] = true; q.push(make_pair(S_x, S_y)); int x,y,next_x,next_y; while (!q.empty()) { x = q.front().first; y = q.front().second; q.pop(); for (int i = 0; i \u0026lt; 8; i++) { next_x = x + dir[i][0]; next_y = y + dir[i][1]; if (next_x \u0026gt;= 0 \u0026amp;\u0026amp; next_x \u0026lt; N \u0026amp;\u0026amp; next_y \u0026gt;= 0 \u0026amp;\u0026amp; next_y \u0026lt; M \u0026amp;\u0026amp; map[next_y][next_x] == false) { map[next_y][next_x] = true; q.push(make_pair(next_x, next_y)); r++; } } } if (K \u0026lt; r) { answer_max = (answer_max \u0026lt; r) ? r : answer_max; answer += 1; } } int main() { cin \u0026gt;\u0026gt; M \u0026gt;\u0026gt; N; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; arr(M, vector\u0026lt;bool\u0026gt;(N, true)); for (int i = 0; i \u0026lt; M; i++) { int j = 0; string str; cin \u0026gt;\u0026gt; str; for (auto c : str) { if (c != \u0026#39;#\u0026#39;) { arr[i][j] = false; } j++; } } cin \u0026gt;\u0026gt; K; for (int i = 0; i \u0026lt; M; i++) { for (int j = 0; j \u0026lt; N; j++) { if (arr[i][j] == false) { bfs(arr, j, i); } } } cout \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; answer_max; return 0; } 8️) 목재 총량 문제 보기 Description\n숲은 직사각형 모양이며 나무는 균등 한 간격으로 배열되어 있습니다. 나무의 높이와 둘레가 다르기 때문에 목재 값은 나무마다 다릅니다.산림청은 각 나무에 대한 데이터를 수집했으며 숲의 각 나무에서 사용할 수있는 나무의 양 (입방 피트)을 알고 있습니다. 산림청은 이 정보를 정수의M×N배열형태로 유지합니다. 여기서(i, j)항목은i번째 행의j번째 나무의 양 (입방 피트)입니다. 행은 위에서 아래로 번호가 매겨지고 열은 왼쪽에서 오른쪽으로 번호가 매겨진다고 가정합니다. 예를 들어 배열이 다음과 같습니다. 위 배열의 위치 (3,4)에 있는 나무의 양은 15 입방 피트 입니다. 산림청은 숲의 직사각형의 토지에 목재의 총량을 계산하여 토지 임대 자료로 활용하려고 합니다. 직사각형은 왼쪽 상단 모서리와 오른쪽 하단 모서리의 나무 위치로 나타냅니다. 예를 들어서 위치 (2,2) 와 (3,4) 모서리를 가지는 직사각형은 아래 그림과 같습니다. 이 직사각형 토지의 목재 총량은 76 입방 피트입니다. 마찬가지로 직사각형 모서리가 (4,2)와 (4,2)인 경우의 목재양은 하나 뿐인 나무의 양 20 입방 피트입니다. 당신의 임무는 삼림청에서 지정한 직사각형 토지의 목재 총량을 계산하는 것입니다. Input\n입력의 첫 번째 줄에는 숲의 나무 행과 열을 나타내는 두 개의 정수 M과 N 다음 M개 줄에는 각각 N개의 정수가 있습니다. 숲의 i행 j열 위치의 나무 양은 입력의 i+1번째 줄의 j번째 정수로 나타냅니다. M+2번째 줄에는 목재 총량을 계산해야 하는 직사각형 토지의 개수 C를 나타냅니다. 이어지는 C개 줄 (M+2+1번째 줄 ... M+2+C번째 줄)에는 4개의 정수 r1, c1, r2, c2 (r1≤r2, c1≤c2)가 직사각형의 2개 모서리를 나타냅니다. (r1,c1)은 좌측 상단 모서리, (r2,c2)는 우측 하단 모서리를 나타냅니다. 2 ≤M≤ 1000, 2 ≤N≤ 1000,C≤ 1000000입니다. 입력의 30% 는C≤ 100 입니다. 목재 총량을 계산해야 하는 직사각형 토지 개수 C가 매우 큰 수 입니다. Output\n출력의 C개 줄에는 각각 직사각형 토지의 목재 총량의 정수를 출력합니다. 즉 출력의 i번째 줄에는 입력의 M+2+i번째 줄에서 설명한 직사각형 토지의 목재 총량을 출력합니다. Sample Input 1\n4 4 3 4 15 23 14 20 12 9 3 8 12 15 12 20 7 5 2 2 2 3 4 4 2 4 2 Sample Output 1\n76 20 Hint\n단순한 알고리즘은 시간초과를 극복할 수 없습니다. 동적 계획법(Dynamic Programming) (https://ko.wikipedia.org/wiki/동적계획법) 일반적으로 주어진 문제를 풀기 위해서, 문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, 그것을 결합하여 최종적인 목적에 도달하는 것이다. 각 하위 문제의 해결을 계산한 뒤, 그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 그것을 간단하게 해결할 수 있다. 이러한 방법으로 동적 계획법은 계산 횟수를 줄일 수 있다. 특히 이 방법은 하위 문제의 수가 기하급수적으로 증가할 때 유용하다. 마지막 문제를 풀이하는 데 30분쯤 남아 있는 상태였다.\n그래서 아까 풀다 못풀었던 회문 생성기를 마저 풀까, 이 문제를 풀까 하다가 dp를 이용하는 문제이기에 쉽게 풀 수있을 거라 생각하고 마지막 문제를 택했는데 문제에서 친절하게 dp를 이용해서 풀이하라고 설명이 되어있다.\nNote\n각 행에 속한 값을 계속 뒤로 밀며 더해주어 dp 배열을 완성해주고, 값을 찾을 때는 각 행의 도착지점의 dp열의 값에서 시작지점의 앞의 dp배열 값을 빼는 식으로 규칙을 찾아 코드를 작성했다.\n하지만 시간이 얼마 남지 않았는데 답이 틀리게 나오는 것이 아닌가!! 💫\n2분이 채 안남았을 때, forest값을 입력 받으면서 dp값을 계산해 줄때 forest와 dp배열을 잘 못 입력한 것을 발견하고 수정을 했지만, 또 답이 틀리게 나왔다.\n포기안하고 틀린 부분을 찾다가 마지막 1분도 안남았을 때 쯤에 반복문 j \u0026lt; dy - 1 을 j \u0026lt; dy 로 작성한 것을 보고 고쳐 답을 제출하려는 찰나에 17:00가 되어 칼같이 마감이 되어 제출을 못했다.. 😭\n코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int M, N; int main() { cin \u0026gt;\u0026gt; M \u0026gt;\u0026gt; N; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; forest(M, vector\u0026lt;int\u0026gt;(N, 0)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(M, vector\u0026lt;int\u0026gt;(N, 0)); for (int i = 0; i \u0026lt; M; i++) { for (int j = 0; j \u0026lt; N; j++) { cin \u0026gt;\u0026gt; forest[i][j]; if (j != 0) { dp[i][j] += dp[i][j - 1] + forest[i][j]; } else{ dp[i][j] += forest[i][j]; } } } int C; cin \u0026gt;\u0026gt; C; vector\u0026lt;int\u0026gt; answer(C, 0); for (int i = 0; i \u0026lt; C; i++) { int sx, sy, dx, dy; cin \u0026gt;\u0026gt; sy \u0026gt;\u0026gt; sx \u0026gt;\u0026gt; dy \u0026gt;\u0026gt; dx; for (int j = sy - 1; j \u0026lt; dy - 1; j++) { if (sx - 1 != 0) { answer[i] += dp[j][dx - 1] - dp[j][dx - 2]; } else { answer[i] += dp[j][dx]; } } } for (int i = 0; i \u0026lt; answer.size(); i++) { cout \u0026lt;\u0026lt; answer[i] \u0026lt;\u0026lt; endl; } return 0; } 시험 결과 점수 집계는 바로 되어 시험이 끝나자마자 시상식을 진행 했는데 시상식은 간단하게 사진을 찍는 정도만 했다.\nNote\n나는 180점 만점에 72점으로 11등을 해서 장려상으로 10만원을 수상 했다.\n10만원의 목표는 달성을 했지만 사람 욕심이 끝이 없다고 30만원 커트라인인 8등 점수 80점을 보고 마지막 문제를 제출만 했으면 30만원 이었을 텐데 하는 아쉬움이 남았다. (핑계이기도 하고, 이건 다른 분들도 똑같지 않았을까 싶다. 더 공부해야겠다고 느꼈다.)\n17학번이 158점으로 1등을 했고 예선전에서 1등 했던 19학번은 120점으로 3등했다.\n은근 10만원 커트라인이 높지 않고 한문제 반 맞는 정도 였으며, 게임공학과가 참여도 많이 했고 점수도 평균적으로 높게 나온 거 같았다.\n제대로 된 책상이 아닌 무릎에 올려놓고 4시간을 코딩 했더니 끝나고 나서 허리와 목이 너무 아팠다.(이 부분은 교수님이 사회적 거리두기 때문에 장소가 마땅치 않았다고 미안하다고 계속 사과하시긴 했다..)\n마지막으로 퇴장하면서 기념품을 하나씩 주셨는데, 꽤 실용적이고 디자인도 나쁘지 않은 10,000mAh 보조 배터리가 들어있었다. 가지고 있는 20,000mAh 보조배터리가 무거웠는데 마침 잘됬다 싶었다.\n못 풀었던 3문제는 중간고사가 끝나고 다시 풀어보고 풀이를 업로드 할 생각이다.\n"},{"section":"Blog","slug":"/blog/etc/tukorea-sw-competition/","title":"한국공학대학교 S/W 경진대회 예선 후기","description":"한국공학대학교 알고리즘 대회 예선 후기","date":"2020년 10월 16일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"기타","tags":"회고, 대회","content":"\r학교공부에 치여 살다보니 알고리즘 문제 풀이를 안한지 3달정도가 지났는 데 학교 엘레베이터에 위와 같은 코테 포스터가 붙여진 것을 보았는데 실력 테스트도 해보고 상금도 노릴겸 해서 겸사겸사 신청을 했다.\n대회 시상관련은 본선 진출시 기념품과, 대상 1명 50만원, 우수상 7명 30만원, 장려상 15명 10만원이었다.\n사실 예선 통과후 본선에 들면 40명중 절반 이상인 23명안에만 들어도 10만원의 상금을 준다는 것을 보고 10만원을 목표로 신청했다.\n예선전은 2020. 10. 07. 수요일에 18:00 ~ 22:00 까지 온라인을 통해 이루어졌는데 나는 수요일 당일 20시까지 수업이 있어 늦게 시작해야했는데, 수업이 조금 일찍 끝나 20시쯤 부터 문제풀이를 시작했기때문에 두시간 밖에 없어 떨어질 생각하고 편하게 테스트 봤다.\n예선전 문제 1) 다음 순열 문제 보기 Description\n1, 2,…,n의 모든 순열을 출력하는 프로그램을 작성하는 것은 흥미로운 연습입니다. 그러나 1, 2,…, 13의 순열의 개수가 6227020800이므로 10보다 큰 크기의 입력에서 모든 순열을 출력하기는 어렵습니다. 그러나 여기에 또 다른 흥미로운 순열 문제가 있습니다. 사전 순서로 1, 2,…,n순열을 정렬 할 수 있습니다. 다음은 사전 순으로 1,2,3의 순열입니다. 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 1,2,…,n의 순열이 주어지면 사전 순으로 다음 순열을 생성합니다. 예를 들어2 3 1 4의경우 답은2 3 4 1입니다. Input\n입력의 첫 번째 줄에는 두 개의 정수N및K가 포함됩니다. 그 뒤에는각각 1, 2,…,N의순열을 포함하는K개줄이 이어집니다. 1 ≤N≤ 1000,K≤ 10 입니다. Output\n출력은K개줄로구성되어야합니다. i번째 줄은입력i+1번째순열에 해당하는 사전 식 다음 순열을 포함해야합니다. Sample Input 1\n3 2 3 1 2 2 3 1 Sample Output 1\n3 2 1 3 1 2 1번 문제는 다음 순서로 올 순열을 출력하는 쉬운 문제여서 next_permutation 함수를 이용하여 쉽게 풀 수 있었다.\n코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int N,K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; arr(K,vector\u0026lt;int\u0026gt;(N,0)); for(int i=0; i \u0026lt;K;i++){ for(int j=0; j \u0026lt; N; j++){ cin \u0026gt;\u0026gt; arr[i][j]; } } for(int i=0; i \u0026lt; K; i++){ next_permutation(arr[i].begin(),arr[i].end()); } for(int i=0; i \u0026lt; K; i++){ for(int j=0; j \u0026lt; N ; j++){ cout\u0026lt;\u0026lt;arr[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } } 2️) 베스트 앨범 문제 보기 Description\n스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 속한 노래가 많이 재생된 장르를 먼저 수록합니다. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다. 노래의 장르를 나타내는 문자열 genre와 노래별 재생 횟수를 나타내는 정수 play가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 출력하도록 하세요. Input\n입력의 첫번째 줄에서 노래의 갯수 N이 주어집니다. 그 다음 N개 줄에는 각 줄마다노래의 장르를 나타내는 문자열 genre와 노래별 재생 횟수를 나타내는 정수 play가 주어집니다. 제한사항\ni+1번째 줄의 문자열 genre는 고유번호가 i인 노래의 장르입니다. i+1번째 줄의 재생 횟수 play는 고유번호가 i인 노래가 재생된 횟수입니다. 1\u0026lt;=N\u0026lt;=10,000 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다. Output\n베스트 앨범에 들어갈 노래의 고유 번호를 한 줄에 하나씩 순서대로 출력하세요. 입력의 예가 다음과 같으면 5 classic 500 pop 600 classic 150 classic 800 pop 2500 classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다. 고유 번호 3: 800회 재생 고유 번호 0: 500회 재생 고유 번호 2: 150회 재생 pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다. 고유 번호 4: 2,500회 재생 고유 번호 1: 600회 재생 따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다. Sample Input 1\n5 classic 500 pop 600 classic 150 classic 800 pop 2500 Sample Output 1\n4 1 3 0 2번 문제는 블로그에도 한번 포스팅했던 프로그래머스의 베스트 앨범 문제였다.\n프로그래머스에서도 풀어보고 포스팅하면서 다시 풀어보고 여러번 풀어봤던 문제였기에, map(hash table) 을 이용하여 값을 더해주고 value를 기준으로 내림차순 정렬하여 값을 출력하는 방법으로 쉽게 풀이 했다.\nNote\nc++ 에서 map을 key가 아닌 value로 정렬을 쉽게 하는 방법은 pair을 갖는 vector로 옮겨 vector로 정렬 하는 방법이 있습니다.\n코드 보기 #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; bool compare(pair\u0026lt;int,int\u0026gt; a,pair\u0026lt;int,int\u0026gt; b){ return a.first \u0026gt; b.first; } bool compare_map_value(pair\u0026lt;string,int\u0026gt; a,pair\u0026lt;string,int\u0026gt; b){ return a.second \u0026gt; b.second; } int main() { int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;string\u0026gt; genres(N,\u0026#34;\u0026#34;); vector\u0026lt;int\u0026gt; plays(N,0); for(int i=0; i \u0026lt; N; i++){ cin \u0026gt;\u0026gt; genres[i] \u0026gt;\u0026gt; plays[i]; } unordered_map\u0026lt;string,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt; genre_playlist; unordered_map\u0026lt;string,int\u0026gt; genre_play_cnt; vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt; genre_play_cnt_v; for(int i=0; i \u0026lt; genres.size(); i++){ genre_playlist[genres[i]].push_back(make_pair(plays[i],i)); genre_play_cnt[genres[i]]+=plays[i]; } for(auto \u0026amp;k : genre_playlist){ sort(k.second.begin(),k.second.end(),compare); } genre_play_cnt_v.assign(genre_play_cnt.begin(),genre_play_cnt.end()); sort(genre_play_cnt_v.begin(),genre_play_cnt_v.end(),compare_map_value); for(int i=0; i \u0026lt; genre_play_cnt_v.size(); i++){ string genre_name = genre_play_cnt_v[i].first; for(int j=0; (j \u0026lt; genre_playlist[genre_name].size() ) \u0026amp;\u0026amp; (j \u0026lt; 2) ; j++){ cout \u0026lt;\u0026lt; genre_playlist[genre_name][j].second \u0026lt;\u0026lt;endl; } } } 3) 등교길 문제 보기 Description\n계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 너비 (m) x 높이 (n) 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m = 4, n = 3 인 경우입니다. 가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다. 입력으로 격자의 너비 m, 높이 n과 물이 잠긴 지역의 좌표 (x,y)를 담은 2차원 배열 puddles이 주어집니다. 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 출력하세요. 제한사항\n격자의 크기 m, n은 1 이상 100 이하인 자연수입니다. m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다. 물에 잠긴 지역은 0개 이상 10개 이하입니다. 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다. 입력의 예로써 너비 m=4, 높이 n=3이고 puddles 배열은 [[2,2]] 가 주어지면 최단 경로의 개수는 아래의 그림과 같이 4입니다. Input\n입력의 첫번째 줄에서는 격자의 너비 m과 높이 n이 주어집니다. 두번째 줄에는 puddles 배열의 개수 N이 주어집니다. 이어지는 N개 줄에는 각 줄마다 물웅덩이 x좌표와 y좌표가 주어집니다. Output\n집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 출력하세요. Sample Input 1\n4 3 1 2 2 Sample Output 1\n4 문제 설명 마지막에 친절하게도 hint로 dp를 이용하여 풀라고 설명이 되어 있어 dp를 이용해 풀었으며, 중학교 수학문제의 확률과 통계에서 최단 거리 경우의 수 문제를 풀듯이 풀었다.\n코드 보기 #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int m,n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; puddles(N,vector\u0026lt;int\u0026gt;(2,0)); for(int i=0; i \u0026lt; N; i++){ for(int j=0; j \u0026lt; 2; j++){ cin \u0026gt;\u0026gt; puddles[i][j]; } } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; map(n+1,vector\u0026lt;bool\u0026gt;(m+1,false)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dis(n+1,vector\u0026lt;int\u0026gt;(m+1,0)); for(auto puddle : puddles) map[puddle[1]][puddle[0]] = true; dis[0][1] = 1; for(int i = 1; i \u0026lt;= n; i++){ for(int j = 1; j \u0026lt;= m ; j++){ if(!map[i][j]) dis[i][j] = (dis[i-1][j] %1000000007 + dis[i][j-1] % 1000000007) % 1000000007; else dis[i][j] = 0; } } cout \u0026lt;\u0026lt; dis[n][m] % 1000000007; } 4️) 토큰 기계 문제 보기 Description\nM개의 서로 다른기계와 T 종류의 토큰이 있습니다. 각각의 기계는 다음과 같이 1개의 토큰을 입력받아서 1개의 토큰과 다음 기계 번호를 출력합니다. 기계 입력 : T 종류의 토큰 중에서 1개 토큰 기계 출력 : T 종류의 토큰 중에서 1개 토큰과 다음 기계번호 출력 이전 기계에서 출력한 토큰을 다음 기계에 넣으면 다음 기계도 토큰 1개와 다음 기계 번호를 출력합니다. 예를 들어, 3개의 기계와 2가지 종류의 토큰이 있고 기계에 대한 설명이 다음과 같다고 합니다. 당신이 처음에 토큰 T1을 기계 M1에 넣기 시작하면, 방문하는 기계의 순서는 M1, M2, M3, M1, M2, M3, ... 이다. 따라서 4번째 방문 기계는 M1이고 5번째 방문 기계는 M2 입니다. 당신이 할일은 M개 기계와 T종류 토큰이 있을 때, S 번호 기계에서 시작해서 N번째 방문하는 기계 번호를 출력합니다. 시작은 1번 토큰에서 시작합니다. Input\n입력의 첫번째 줄에는 M (기계 개수 1...M), T (토큰의 종류 1...T), S (시작 기계 번호), N (N번째 방문) 이 주어 집니다. 그 다음 M x T 개의 줄에는 각각 2개의 정수가 주어 집니다. M개 기계에 대해서 T개의 토큰의 입력에 대한 출력을 차례로 설명합니다. 즉 입력의 2번째 줄에는 1번 기계에 1번 토큰을 삽입하면 출력되는 토큰 번호와 다음 기계 번호가 주어집니다. 입력의 3번째 줄에는 1번 기계에 2번 토큰을 삽입하면 출력되는 토큰 번호와 다음 기계 번호가 주어집니다. (m-1)×T+i+1 (1 ≤m≤M, 1 ≤i≤T) 번째 줄에는 m번 기계에 i번 토큰을 삽입하면 출력되는 토큰 번호와 다음 기계 번호가 주어집니다. 1 ≤M≤ 200, 1 ≤T≤ 20,N≤ 1000000000 입니다. 입력의 50% 는N≤ 1000000 입니다. Output\nN번째 방문하는 기계 번호를 출력합니다. 시작은 1번 토큰에서 시작합니다 Sample Input 1\n3 2 1 4 2 2 1 2 1 3 2 3 1 1 2 1 Sample Output 1\n1 이때 시간이 40분도 채 남지 않았는 데, 문제는 3문제가 남아 있어 선택을 해야하는 상황이 왔었다.\n그래서 남은 세 문제중 한 문제만 더 풀자 하고 가장 통과율이 높은 마지막 문제를 선택했기 때문에, 4,5 번은 문제는 보지도 못했다..\n5️) 사회적 거리두기 1 문제 보기 Description\n전세계적으로 퍼진 신종 코로나-19 감염병 예방을 위해서 김교수는 중간고사에서 사회적 거리두기를 시행하려고 합니다. 일렬로 배치된 N (2≤N≤10^5)개의 책상에 중간고사를 보기위한 학생들이 중간 중간에 앉아 있습니다. 어떤 책상은 학생들이 앉아있고 어떤 책상은 비어 있습니다. 새로운 학생 2명이 중간고사를 보기 위해서 책상에 앉으려고 합니다. 김교수는 사회적 거리두기를 시행하기 위해서 가장 가까운 학생간의 거리, D가 최대가 되도록 신규 학생 2명의 배치를 하려고 합니다. 김교수는 이미 자리에 앉아 있는 학생들은 자리 이동을 허락하지 않습니다. Input\n입력의 첫번째 줄에는 책상 개수 N을 포함합니다. 두번째 줄에는 학생들의 책상 점유 상태를 나타내는 길이가 N인 0과 1로 이루어진 숫자의 나열이 나옵니다. 0은 학생이 없고 1은 학생이 앉아 있는 것을 나타냅니다. 2개 이상의 0을 포함하므로 2명의 신규 학생을 수용할 충분한 공간이 있습니다. Output\n새로운 학생 2명을 배치한 후에 가장 가까운 학생간 거리, D의 최대값을 출력하십시오. 입력의 예가 다음과 같다고 가정합시다. 18 100000100100000010 그러면 새로운 학생 배치를 x로 표시해서 다음과 같이 배치할 수 있습니다. 100x00100100x00010 이러한 배치의 경우에 D의 최대값은 3가 됩니다. 또 다른 입력의 예가 다음과 같다고 가정합시다. 6 000000 그러면 새로운 학생 배치를 x로 표시해서 다음과 같이 배치할 수 있습니다. x0000x 이러한 배치의 경우에 D의 최대값은 5가 됩니다. Sample Input 1\n18 100000100100000010 Sample Output 1\n3 Sample Input 2\n6 000000 Sample Output 2\n5 6️) 마우스 미로 문제 보기 Description\n미로는 사각형 격자 셀들로 구성되어 있습니다. 미로 안에 일부 셀은 차단되어 있고 나머지 셀들은 비어 있습니다. 마우스(Mouse)는 M으로 표시된 빈 셀 중 하나에서 시작하고 D로 표시된 목적지 셀까지 이동하려고 합니다. 셀에서 마우스는 아래 주어진 규칙에 따라 빈 이웃 셀로 이동할 수 있습니다. 당신의 목표는 마우스가 이 미로를 통과하여 목적지 셀(D)에 도달 할 수 있는지를 결정하는 것입니다. R 행과 C 열이있는 미로는 각각 C개의 문자가있는 일련의 R 행으로 표시됩니다. 문자 # 은 차단 된 셀을 나타내고 문자 . 은 빈 셀을 나타냅니다. 마우스 시작 셀(M)과 목적지 셀(D)는 별개의 빈 셀에 있습니다. 다음은 7 행 11 열의 미로입니다. #####..#### .M.#.#..D.# #.#..#....# ...#.#..#.. ....#.#.#.# ...##.###.# ........### 행과 열 위치로 셀을 참조합니다. 행은 위에서 아래로 번호가 매겨지고 열은 왼쪽에서 오른쪽으로 번호가 매겨집니다. 예를 들어, 위의 미로에서 마우스는 처음에 두 번째 행과 두 번째 열을 나타내는 위치 (2,2)에 배치되고 목적지 셀은 두 번째 행과 열 번째 열을 나타내는 위치 (2,9)에 있습니다. 마우스는 셀에서 셀 위쪽, 아래쪽, 왼쪽 또는 오른쪽으로 이동할 수 있습니다. 또한, 가장 왼쪽 열의 셀에서 마우스는 가장 오른쪽 열의 동일한 행에 있는 셀로 이동할 수 있으며 가장 오른쪽 열의 셀에서 가장 왼쪽 열의 같은 행에있는 셀로 이동할 수 있습니다. 마찬가지로 맨 위 행의 셀에서 마우스는 맨 아래 행의 동일한 열에있는 셀로 이동할 수 있고 맨 아래 행의 셀에서 맨 위 행의 같은 열에있는 셀로 이동할 수 있습니다. 따라서 위의 미로에서 마우스는 셀 (4,1)로 부터 (4,11)로 이동할 수 있고, 셀 (7,7)로 부터 (1,7)으로 이동할 수 있습니다. 위의 예에서, 마우스는 (2,2), (3,2), (4,2), (4,1), (4,11), (4,10), (3,10), (3,9), (2,9)와 같은 일련의 셀들을 통해 목적지에 도달 할 수 있습니다. 이 경로에는 아래에 x가 표시되어 있습니다. #####..#### .M.#.#..D.# #x#..#..xx# xx.#.#..#xx ....#.#.#.# ...##.###.# ........### 또한 다른 경로를 다음과 같이 나타낼 수도 있습니다. #####.x#### .M.#.#xxD.# #x#..#....# .x.#.#..#.. .x..#.#.#.# .x.##.###.# .xxxxxx.### 당신의 임무는 마우스가 목적지에 도달 할 수 있는지 여부를 결정하는 것입니다. Input\n입력의 첫 번째 줄에는 각각 행 및 열을 나타내는 두 개의 숫자 R과 C가 포함됩니다. 그 다음 줄 부터는 각각 C개 문자가 있는 R 행이 있으며, 각 줄은 # 또는 . 또는 M 또는 D 문자를 갖는다. M과 D는 정확히 한개 씩만 있습니다. R≤ 1000,C≤ 1000 로 가정합니다. Output\n마우스가 목적지까지 가는 경로가 없으면 NO라는 단어가 포함 된 한 줄을 인쇄하십시오. 마우스가 목적지까지 가는 경로가 있는 경우 출력의 첫 번째 행은 단어 YES로 구성되어야합니다. 그 뒤에는 각각 C 문자의 R 행이 있어야합니다. 여기서 각 문자는 # 또는 . 또는 x 또는 M 또는 D 입니다. 상기 예시 된 바와 같이 x 를 사용하여 M에서 D 로의 경로를 설명합니다. 많은 경로가 있을 수 있으며 하나의 경로를 설명하면 충분합니다. Sample Input 1\n7 11 #####..#### .M.#.#..D.# #.#..#....# ...#.#..#.. ....#.#.#.# ...##.###.# ........### Sample Output 1\nYES #####..#### .M.#.#..D.# #x#..#..xx# xx.#.#..#xx ....#.#.#.# ...##.###.# ........### Sample Input 2\n4 6 ##.#.. .M.#.# #.#.D. ...#.# Sample Output 2\nNO 시간안에 한두개 케이스라도 통과해보자는 마음으로 문제 풀이를 시작 했고, 최단 경로가 있는지 없는지 검사만 하는것이 아니라 최단 경로까지의 길을 x로 출력해야 해서 bfs로는 최단 경로에 포함되지 않은 길은 x표시를 제외하려고 하면 복잡해질 것 같아 dfs로 풀이를 시작했다.\nint dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; 을 이용했으며, 제일 끝 쪽 벽이 막혀있는 것이 아니라 다음 벽으로 이어져 있기 때문에 현재 위치에서 dir값과 총 배열 길이(x축이면 C,y축이면 R)을 더하고 배열 길이만큼 나눈 나머지를 이용하여 dfs를 풀이했다.\nint next_x = (x + dir[i][0] + C) % C; int next_y = (y + dir[i][1] + R) % R; 하지만, 마음이 급했는 지 **==**을 **=**로 잘못쓰는 등 잔실수들 때문에 버그 고치느라 타임아웃되어 제출을 하지 못하고 예선이 끝났다.\n코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int R, C; int M_x, M_y; int D_x, D_y; bool arrive = false; vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; answer; int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; void dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; map, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visit, int x, int y) { if (y == D_y \u0026amp;\u0026amp; x == D_x){ arrive = true; answer = map; return; } if (map[y][x] != \u0026#39;M\u0026#39;) map[y][x] = \u0026#39;x\u0026#39;; visit[y][x] = true; for (int i = 0; i \u0026lt; 4; i++){ int next_x = (x + dir[i][0] + C) % C; int next_y = (y + dir[i][1] + R) % R; if ((map[next_y][next_x] == \u0026#39;.\u0026#39; || map[next_y][next_x] == \u0026#39;D\u0026#39;) \u0026amp;\u0026amp; visit[next_y][next_x] == false){ visit[next_y][next_x] == true; dfs(map, visit, next_x, next_y); } } return; } int main() { cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; arr(R, vector\u0026lt;char\u0026gt;(C, \u0026#39;0\u0026#39;)); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visit(R, vector\u0026lt;bool\u0026gt;(C, false)); string str; for (int i = 0; i \u0026lt; R; i++){ int j = 0; cin \u0026gt;\u0026gt; str; for (auto c : str){ arr[i][j] = c; if (arr[i][j] == \u0026#39;M\u0026#39;){ M_x = j; M_y = i; } if (arr[i][j] == \u0026#39;D\u0026#39;){ D_x = j; D_y = i; } j++; } } dfs(arr, visit, M_x, M_y); if (arrive){ cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; answer.size(); i++){ for (int j = 0; j \u0026lt; answer[i].size(); j++){ cout \u0026lt;\u0026lt; answer[i][j]; } cout \u0026lt;\u0026lt; endl; } } else{ cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34;; } return 0; } 종료후에 제출하여 코드를 확인해보니 위의 코드도 완벽히 통과는 못하고 마지막 두개의 케이스가 메모리 초과로 실패가 뜨는 것을 확인했다.\n예선전 후기 10시에 칼같이 시험이 끝나고 바로 점수가 집계되었는데, 총 점 120점 만점에 40점으로 16등으로 통과했다.(생각도 못했는데 이게 웬 걸)\n늦게 시작했지만 예선 통과해서 좋았고, 1등은 108점으로 19학번이 한것을 보고 대단하다는 생각과 동시에 자괴감이 들었으며, 총원과 점수들을 보니 생각보다 많은 사람이 참여를 안했구나 싶었다.\nTip\n그래서 덕분에 40점을 받아 16등으로 예선을 통과했다. 😄\n본선 후기는 다음글에 이어서 포스팅 할 예정이다.\n"},{"section":"Blog","slug":"/blog/algorithms/counting-sort/","title":"Counting Sort ( 계수 정렬 )","description":"Non-Comparisions / Stable한 정렬, Counting Sort [계수 정렬]","date":"2020년 10월 13일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"Sort, Counting Sort","content":"계수 정렬은 삽입, 버블, 선택, 퀵, 합병 정렬들과 같이 비교를 수행하는 방식이 아닌 비교를 하지 않는 Non-Comparisions Sorting Algorithm 이다.\n그러면 여기서 값을 정렬하는데 어떻게 비교 없이 수행하나요? 와 같은 질문이 있을 텐데, 계수 정렬은 비교 대신 정렬할 수의 개수와 배열의 인덱스를 가지고 정렬을 수행하게 된다.\n1. 기본적인 흐름 2 1 2 4 5 3 6 5 3 을 정렬하고자 한다면\n1의 개수는 1개, 2의 개수는 2개, 3의 개수는 2개, 4의 개수는 1개, 5의 개수는 2개, 6의 개수는 1개 이기 때문에 작은 수 부터 개수만큼 차례대로 나열하게 되면\n1 2 2 3 3 4 5 5 6 으로 정렬이 된다.\n2. 정렬 과정 정렬할 배열 A, 추가 배열 C를 생성 배열 C는 모든 값을 0으로 초기화 배열 A의 값을 토대로 배열 C의 인덱스값을 참조하여 값을 1씩 증가 (예를 들어 배열 A의 값중 3이 있다고 한다면, C의 3번째 인덱스 값을 1더해준다.) 배열 c의 각 값들을 직전 값을 더해 업데이트\n(예를 들어, 배열 C가 1,0,2,2 였다면, 1,1,3,5로 업데이트) 배열 C는 배열 A의 값들의 인덱스 값이므로, 배열 A를 끝에서부터 역순으로 훑으면서 배열 B에 정렬. (이때, 한 값을 B에 옮겨주었다면, 해당하는 인덱스의 배열 C의 값은 1을 빼준다.) Note\n여기서 배열 A의 뒤의 값부터 역순으로 훑으면서 정렬하는 이유는 counting sort 는 stable한 특성을 갖고있는 정렬인데, 앞에서부터 정렬을 하게 되면 stable한 특성이 깨지기 때문이다.\n예를들어, 아래와 같은 배열 A가 있다면 원래 방법대로 뒤에서부터 훑게 되면 아래와 같이 정렬이 된다.\nA = { 3 5(a) 1 4 5(b) 2 } C = { 1 2 3 4 6 } 이 되어, A = { 1 2 3 4 5(a) 5(b) } 반대로 똑같은 A를 앞에서 부터 훑게 되면 아래와 같이 나오게 되면서 stable한 특성이 깨지게 된다.\n1 2 3 4 5(b) 5(a) 따라서 뒤에서 부터 훑으며 정렬을 하게 된다.\n3. c++ 구현 코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;string.h\u0026gt; //memset #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; #define MAX_ARRAY_SIZE 64 //정렬할 배열 숫자 개수 int maxValue=0; //가장 큰 값 clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 //배열의 item을 random으로 삽입 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%MAX_ARRAY_SIZE + 1; maxValue = (maxValue \u0026lt; array[i]) ? array[i] : maxValue; //가장 큰 값 찾기 } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(3); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } int* count_sort(int *array,int arrlen){ int *c = new int[maxValue+1]; int c_size = maxValue+1; int *b = new int[arrlen]; memset(c,0,c_size*sizeof(int)); //배열c 0으로 초기화 /*각 숫자 횟수 카운틱하며 c배열 인덱스 값 증가*/ for(int i = 0; i \u0026lt; arrlen ; i++){ c[array[i]]++; } /*배열 c의 인덱스 값 누적합 구하기*/ for(int i=1; i \u0026lt; c_size; i++){ c[i] += c[i-1]; } /*배열 A역순으로 훑으며, 배열 C참조하여 정렬*/ for(int i = arrlen-1; i \u0026gt;= 0; i-- ){ b[c[array[i]]-1] = array[i]; --c[array[i]]; } return b; } int main(){ int *array = new int[MAX_ARRAY_SIZE]; input_random(array,MAX_ARRAY_SIZE); //배열에 랜덤값 삽입 delete array; start = clock(); array = count_sort(array,MAX_ARRAY_SIZE); //계수 정렬 finish = clock(); display(array,MAX_ARRAY_SIZE); //show array CalcTime(); delete array; return 0; } 4. 특징 시간 복잡도는 O(n+k) 로 O(n) 또는 O(k) 를 갖는다. ( 여기서 n은 input의 개수, k는 input으로 들어온 n의 범위 == 추가 배열 c의 범위 )\nNote\n예를 들어 1,1,1,1,1,1,1,1 과같이 1이 10개로 n이 10이 들어왔다면, 이때 k는 2가 되고, 1 500 의 input이 주어진다면 n은 2에 불과하지만, k는 501이 된다.\n범위가 넓어지게 되면 추가 메모리 공간이 많이 필요해지고, 또 범위를 계산해서 가장 큰 수가 무엇인지 판별하는 추가 로직도 도는 등 추가 작업이 필요하다.\n따라서, 점수나 알파벳같은 좁은 범위의 데이터를 정렬할 때 유용하다.\nstable 한 정렬 방법으로 radix sort 시 사용되는 정렬이다.\n"},{"section":"Blog","slug":"/blog/projects/hugo/custom/","title":"Hugo theme Custom 하기","description":"Hugo theme Custom 하기 1 - shortcode 추가하기, css속성바꾸기, 방문자 수 표시하기","date":"2020년 9월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/hugo/preview_hu637364512dd31ad226a1f796bce6289e_49062_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"115\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/hugo\\/preview_hu637364512dd31ad226a1f796bce6289e_49062_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/hugo/preview_hu637364512dd31ad226a1f796bce6289e_49062_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/hugo\\/preview_hu637364512dd31ad226a1f796bce6289e_49062_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"Hugo, Github Page","content":"우선 theme 마다 파일 경로나 파일이름, 설정방법은 조금씩 다를 수 있다는 것을 알리고 시작하겠다.\n저는 theme-docport 를 사용하고 있고, 왼쪽에 카테고리 별로 구분할 수있는 기능과 오른쪽에 특정 header로의 이동기능이 있는 테마를 찾다가 이 테마를 선택했다.\n1. Code 태그 수정 1) 인라인 코드 해당 code 태그의 css가 정의된 파일을 찾아야 되는데 hugo는 적용방식이 theme폴더 내의 파일을 이용하고 그 위의 루트파일에 같은 이름의 파일이 있으면 덮어씌워 적용하는 방식이다.\n그래서 theme/테마이름/assets/sass안에 있는 main.css에 code태그 속성이 정의 되어있길래 이를 root에 옮겨와 고쳐봤는데 수정이 되지 않았다.\n찾다보니 root폴더에 resources/_gen/assets/scss/sass 폴더 내에 main.scss_9fd32d87d247ca96761d3cae485087fe.content 라는 파일에 code가 정의되어 있는데 여기서 바꿔주니 수정이 되었다. (아무래도 이 파일이 최종적으로 덮어지는 파일인 것 같다. 이 파일이 없으면 빌드가 되질 않는다.)\ncss가 정의된 파일은 테마별로 다른 것 같으니 vscode를 이용한다면 shift+ctrl+f 로 public폴더를 제외폴더로 놓고 찾아보면 수월하다. 나는 크롬 디버그모드로 code태그 색상값을 알아낸 후 색상값으로 검색하여 찾아냈다.\n2) 블록 코드 모든 테마 동일하게 hugo에서 코드 highlighting을 지원하고 있고 config.toml폴더 내의 내용을 수정하는 것으로 쉽게 변경이 가능하다.\n#중략 ... # Code highlight configuration [markup.highlight] codeFences = true guessSyntax = true hl_Lines = \u0026#34;\u0026#34; lineNoStart = 1 lineNos = false lineNumbersInTable = false noClasses = true style = \u0026#34;manni\u0026#34; #style = \u0026#34;native\u0026#34; tabWidth = 2 codeFences : 이를 true로 해주어야 div로 한번 감싸 블록 코드로 표현이 가능하다. guessSyntax : 해석 그대로 언어별로 문법을 추측하여 하이라이팅을 해준다. hl_Lines : 지정 라인에 색상을 더 진하게 하이라이팅 줄 수 있다. lineNoStart : 시작 라인 넘버를 지정해줄 수 있다. lineNos : 블록 코드 왼쪽에 줄 번호를 표시할지 정할 수 있다. lineNumbersInTable : 줄 번호 와 코드 사이에 간격을 지정할 수 있다. lineNos를 true로 했다면 이도 true로 해주는 게 좋은데, 이게 가시성도 문제지만 false로 하면 다른 사람이 코드를 복사해가려고 할 때 줄 번호도 같이 복사가 된다. noClasses : 클래스를 지정하는 것으로 코드 테마까지 커스텀할꺼 아니면 true로 하자. style : 이를 통해 테마를 선택할 수 있다. 다양한 테마 보러가기 tabWidth : 탭 크기 지정 위의 방법으로 테마를 설정해주고 css와 같은 방법으로 class명이 highlight인 부분을 가장 root css에서 찾아 border-radius를 조금 주고 margin-left가 -1.5em으로 되어있는 걸 없애 container크기에 맞추도록 해주었다.\n2. 링크 태그(a) 꾸미기 이 방법도 인라인 코드 수정 방법과 다르지 않다.\nroot css파일에서 dom 트리중 a 태그를 찾아 수정해주면 된다.\ntheme-docport는 article section.page div.content a 라는 깊이에 a의 css가 정의 되어있어서 이부분에서 color와 font-weight, cursor옵션을 추가해 주었다.\na태그 가 어딨는지 모르겠다면 색상 코드로 찾는 것도 꿀팁이다.\n3. shortCode 추가하기 1) details 간혹 코드가 길게 들어가는 글을 작성하다 보면 스크롤 내리는데 힘이 들어서 코드 접기/펴기 를 details태그를 이용해서 사용하곤 했는 데 조금 편하게 사용하고자 shortCode로 만들었다.\n{{ $_hugo_config := `{ \u0026#34;version\u0026#34;: 1 }` }} \u0026lt;details\u0026gt; \u0026lt;summary class = \u0026#34;detail-title\u0026#34; style=\u0026#34;font-Weight : bold; font-size : 15px; color : #3158ad;\u0026#34; \u0026gt; {{- if (.Get \u0026#34;summary\u0026#34;)}} {{- .Get \u0026#34;summary\u0026#34; -}} {{- else}} 📃 코드 ( 접기 / 펼치기 ) {{end}} \u0026lt;/summary\u0026gt; \u0026lt;div\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; \u0026lt;/details\u0026gt; detail.html을 root의 layouts/shortcodes에 새로 만들어주고 위의 코드와 같이 만들어 주었다.\n{{ %detail summary=\u0026#34;title\u0026#34;% }} 내용 {{ %/detail% }} 내용은 별거 없는데 만약에 detail사용시 summary 옵션을 주면 해당 title로 생성이되고 없다면 코드 (접기/펼기) 로 title을 지정하고 detail shortcode안의 내용을 details태그로 감싸라는 코드이다.\n예시 보기 이렇게 사용할 수 있습니다 😀\n2) gist \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://gist.github.com/{{ .Get 0 }}.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 코드가 있는 블로그를 작성할때 블로그에 코드를 그대로 붙여 넣는 것보다 Gist라는 곳에 코드 조각을 업로드하고 이를 붙여넣는 것이 수정에 있어 편할 수도 있다.\n코드에 수정이 생기면 원본코드도 수정하고 블로그도 수정하기 귀찮기 때문에 한곳만 수정해도 모두 수정이 되게 하기 위함이다.\n그래서 손쉽게 gist 코드를 붙여넣게 하기 위해 다음과 같이 shortCode를 만들어 주었다.\n사용방법은 {{\u0026lt; gist \u0026ldquo;붙이고자하는 gist url 뒷 해시코드\u0026rdquo; \u0026gt;}} 와 같이 사용하면 gist 코드가 삽입된다.\n4. 방문자 수 표시 보통 방문자 수 확인/분석은 구글 애널리스틱을 통해 할텐데 다른 사람들에게 현재 방문자수를 보여주고 싶을 수도 있을 것이다. 그때, 따로 db를 이용하지 않는 한 힘든데 오픈소스인 hits를 이용하면 비교적 쉽게 구현할 수 있다.\nhits 를 통해 이미지 링크를 만들고 이를 페이지에 삽입하면 다른사람이 해당 페이지에 접속할때마다 이 이미지를 불러올텐데 이때마다 count를 세는 방식이다.\n우선 저 홈페이지에 가서 본인의 루트 홈페이지(본인 도메인)를 입력해서 태그를 생성한 후, 본인 입맞대로 커스텀을 하면 아래사진과 같이 태그가 생성된다.\n이 링크를 아래의 코드와 같이 div로 한번 감싸주고 img 링크를 수정해주어야 사용이 가능하다.\n\u0026lt;div style=\u0026#34;text-align: center;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://hits.seeyoufarm.com\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgowoonsori.site\u0026amp;count_bg=%230DC276\u0026amp;title_bg=%23555555\u0026amp;icon=\u0026amp;icon_color=%23E7E7E7\u0026amp;title=+%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98+\u0026amp;edge_flat=false\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 그대로 붙여넣으면 어느 페이지를 가던지 루트 페이지의 방문자 수로 표시되기 때문에 제대로 된 페이지 방문자수 측정이 안되고, 위의 코드를 본인에 맞게 안고치고 그대로 사용하면 내 블로그의 방문자수가 집계될 것이다.\n위의 img태그의 src를 잘보면 url=https%3A%2F%2Fgowoonsori.site와 같이 본인의 사이트 도메인이 있고 \u0026amp;count_bg\u0026hellip; 가 있다. (여기서 %3A는 : 를, %2F는 /를 뜻한다.)\n이 사이에 {{ .Site.BaseURL }}{{ .RelPermalink }} 를 넣어주면 아래와 같은 코드가 된다.\n\u0026lt;div style=\u0026#34;text-align: center;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://hits.seeyoufarm.com\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://hits.seeyoufarm.com/api/count/incr/badge.svg?url={{ .Site.BaseURL }}{{ .RelPermalink }}\u0026amp;count_bg=%230DC276\u0026amp;title_bg=%23555555\u0026amp;icon=\u0026amp;icon_color=%23E7E7E7\u0026amp;title=+%EB%B0%A9%EB%AC%B8%EC%9E%90+%EC%88%98+\u0026amp;edge_flat=false\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 완성된 위 코드를 원하는 layout에 삽입해주면 되는데 나는 _layouts/partials/body-article-sidepage.html 에 삽입해 주었고, 다른 테마를 사용하거나 다른 곳에 넣고 싶다면 해당 문서를 잘 참고하여 원하는 layout안의 위치에다가 삽입해주면 된다.\n5. 그 외 head에 og와 같은 메타데이터들을 추가해주었고 nav, menubar, 링크 등에 cursor:pointer 가 없어서 클릭할 수 있는 것들이 구분이 가지 않아서 각 태그들에 hover 옵션으로 추가 해 주었다.\n또, content의 min-width가 없이 %로만 지정이 되어있어서 끝도없이 사이즈가 줄여지길래 아이폰에 맞춰서 min-width를 320으로 설정해 주었다.\n글꼴등 더 커스텀하고 싶은게 많은데 은근 시간을 많이 잡아먹어 이정도에 일단 만족하며 사용하고 있는 중이고, 또 좋은 shortCode나 팁이 생기면 공유할 예정이다. 😄\n"},{"section":"Blog","slug":"/blog/projects/hugo/start/","title":"Hugo와 Github page로 블로그 구축","description":"hugo와 github page 사용하여 블로그 만들기, github page와 도메인 연결하기, github page에 댓글기능 추가하기","date":"2020년 9월 23일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/hugo/preview_hu637364512dd31ad226a1f796bce6289e_49062_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"115\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/hugo\\/preview_hu637364512dd31ad226a1f796bce6289e_49062_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/projects/hugo/preview_hu637364512dd31ad226a1f796bce6289e_49062_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/projects\\/hugo\\/preview_hu637364512dd31ad226a1f796bce6289e_49062_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Projects","tags":"Hugo, Github Page","content":" Note\n블로그를 작성하기로 마음 먹은 후에 가장 먼저 할 일이 블로그를 만드는 것이었다.\nhugo와 github을 사용하면서 블로그를 open하는 과정과 겪었던 문제점들, 추가한 내용들을 정리하여 hugo를 선택하신분들에게 조금이나마 도움이 되고자 한다.\nhugo를 선택한 이유 github page를 이용하여 블로그를 운영하는데 다양한 generator가 존재한다.\n가장 유명한 generator로는 Ruby 기반의 Jekyll이 있다. Jekyll은 가장 github의 star 수가 많은 만큼 theme도 많고 한글 reference도 많다.\n하지만, page수가 많지도 않은 데 점점 build가 오래걸린다는 issue가 있다고 하고, 남들이 많이 하지 않는 거를 해보자!! 하는 마음과 Ruby 보다는 Go를 기반으로 한 Hugo 가 더 끌려 Hugo를 선택했다.\n1. 첫 시작! Hugo 설치 github page를 이용하여 블로그를 만드는 것이기 때문에 따로 git 설치 과정은 생략한다.\nHugo install에 관한 공식 문서 를 보고 자신의 OS환경에 맞게 설치를 해주면 된다.\n위의 링크를 통해 Linux나 macOS라면 명령어를 이용해서 쉽게 설치가 가능하다.\n나는 windows를 사용하고 있고 따로 package sw를 사용하지 않기 때문에 Hugo 공식 github 을 통해 windows의 최신 버전의 zip파일을 이용해 설치했고 C:\\Hugo\\bin 디렉토리를 생성해서 이 폴더안에 다운받은 압축파일 해제했다.\n1) 환경 변수 설정 윈도우 검색창에 시스템 환경 변수를 검색 하고 실행시키기\n시스템 속성의 환경변수 클릭\n시스템 변수의 Path 더블 클릭 새로 만들기를 클릭하여 아까 설치했던 C:\\Hugo\\bin 입력. 위와 같이 진행하거나 cmd를 통하여 $set PATH=%PATH%;C:\\Hugo\\bin 명령으로 환경변수를 추가하면 된다.\n제대로 완료되었는지 확인 하고 싶다면 cmd를 통해 hugo version 으로 동작 확인.\n2. 블로그 생성과 호스팅을 위해 Github repository를 2개 생성 repo를 두개 생성하게 되는데 한개는 hugo를 사용하여 블로그안에 채울 내용과 소스파일들을 저장하기 위한 repo를 만들어준다.\n이 repo는 소스가 보여지는 게 싫다하면 private로 만들어도 무관하며 이름도 편한대로 만들면 된다.\n다른 한개는 github page를 사용한 호스팅을 위해 USERNAME.github.io 라는 이름으로 생성하면된다.\n이때 USERNAME 은 본인의 github name을 적으면 되고 이 repo는 무료로 호스팅을 위해서는 public으로 생성해야하고 private으로 생성하고 싶다면 Github pro 이상을 구매해야 한다.\n3. 블로그의 컨텐츠들을 담을 파일 생성 hugo new site 파일명 왼쪽의 명령어를 사용하면 기본 hugo폴더의 뼈대가 자동적으로 생성이 되는데 원하는 파일 경로에 directory를 생성해주면 된다.\n현재 cmd의 위치가 C:/Hugo 라면 이 폴더 안에 생성될 것이고 특정 경로를 지정하고 싶다면 hugo new site ../Users/파일명과 같이 파일명 앞에 경로를 추가해주면 된다.\n나는 C:\\Hugo 안에서 hugo new site blog 명령어를 통해 blog라는 폴더를 생성해주었다.\n4. 테마 다운 및 설정 hugo 테마 둘러보기 사이트에 들어가서 마음에 드는 테마를 선택후 Download를 클릭.\n해당 테마의를 submodule에 추가한다. Download를 클릭하면 각 테마를 만든 사람의 github의 repo에 들어가지는데 repo에 어떻게 submodule를 추가하면되는지 나와 있다.\n나는 hugo-theme-docport 테마를 선택 했고 submodule 추가 과정은 git init \u0026gt; git submodule add https://github.com/vjeantet/hugo-theme-docport.git themes/hugo-theme-docport을 통해 추가했다.\nconfig.toml 파일 수정 나와 똑같이 진행을 했다면 blog폴더 안에 config.toml 파일이 있을 텐데 이 파일을 통해 title이나 baseUrl, google analytics, theme 기본 설정등 해주게 된다.\nbaseURL은 본인의 블로그 주소 ➡ Username.github.io를 설정 해주면 된다.\n5. 파일 관리와 호스팅을 위해 github repo와 연결시켜주기 1) 처음에 만든 blog repo 연결 cmd에서 C:\\Hugo\\blog로 이동한다. $ git remote add origin \u0026lt;본인의 첫번째만든 repo주소\u0026gt; github repo주소를 모르겠다 하면 github 홈페이지의 본인 repo에 들어 가보면 code버튼을 클릭하고 위의 빨간색 동그라미 부분을 클릭하면 repo주소가 복사가 된다.\n2) 두번째 만든 username.github.io repo 연결 git submodule add -b master \u0026lt;두번째 만든 githbu.io repo주소\u0026gt; public 을 입력해주면 blog폴더 안에 public 폴더가 만들어지는 데 이 public폴더가 username.github.io 저장소와 연결 될 것이다. 6. 컨텐츠 생성 hugo new \u0026lt;파일명\u0026gt; 을 사용하여 업로드할 컨텐츠를 만들어 볼 수 있는 데 기본 파일구조가 테마별로 다르니 꼭 꼭 본인이 사용하는 테마의 repo를 잘 참조하자!!\nWarning\n어떤 테마는 post/파일명.md 파일로 생성을 하는가 하면 내가 사용하는 테마는 파일명/_index.md를 통해 컨텐츠가 생성이 된다.\n컨텐츠가 생성이 되었다면 hugo server를 입력하면 http://localhost:1313/ 을 통해 확인해 볼 수 있다.\nNote\n여기서 나는 한번 고생을 했는데 보통 hugo 파일 구조가 theme 폴더 내의 소스파일을 이용해서 레이아웃을 구성하고 없다면, 루트파일의 레이아웃을 이용하거나 덮어씌워 구성을한다. 하지만 내가 사용한 테마는 기본 scss 파일들을 theme 파일안에 존재하지 않아 build가 되지를 않았다. docport 테마는 따로 exampleSite폴더 내에 기본 레이아웃을 구성하는 구조와 css,js파일들이 존재하기 때문에 이 파일을 꺼내 blog폴더에 옮겨주는 것으로 해결했다. 그러니 꼭 테마별 설명서를 잘 읽어보자 !!\n위의 명령어는 개발 모드로 실제 빌드는 되지 않고 배포를 위해 html 파일로 변환해주기 위해서는 아래와 같이 입력해주면 된다.\nhugo -t \u0026lt;테마이름\u0026gt; 테마 이름은 blog/themes/ 아래 폴더 이름이 테마 이름이고, 빌드를 하면 public폴더에 html문서들이 생성된걸 볼 수 있다.\n7. github page 이용해 업로드 개발모드가 아닌 실제 블로그를 업로드 해야하지 않겠는가?\n업로드 순서는 다음과 같다.\n1) username.github.io 에 push 하기 $ hugo -t 테마이름 명령을 통해 테마가 적용된 블로그 내용을 public 폴더 내에 build 해준다. $ cd public 을 통해 public 디렉토리로 이동한다. $ git add . 수정된 파일들을 index에 올린다. $ git commit -m \u0026ldquo;커밋메세지\u0026rdquo; 변경 내용을 commit하고 $ git push origin master commit을 통해 username.github.io에 upload 2) blog repo push 하기 위의 repo에만 올려도 포스팅은 되지만 코드 관리를 위해 이 repo도 push\n$ cd .. $ git add . $ git commit -m \u0026ldquo;커밋메세지\u0026rdquo; $ git push origin master 8. 컨텐츠 업로드 반 자동화 하기 github action을 이용하여 자동화를 하는 방법도 존재하는데, 나는 쉘스크립트를 이용하는 것이 더 편해 이방법으로 배포하고 있다.\n아래의 코드를 deploy.sh로 저장하여 blog폴더 내에 두면 다음 부터는 컨텐츠 업로드시 일일히 타이핑하지 않고 deploy.sh \u0026ldquo;커밋메세지\u0026rdquo; 를 통해 자동으로 편하게 업로드 할 수 있고 굳이 deploy라는 이름이 아니어도 된다.\n대신 .sh 확장자로 저장을 해야 쉘 스크립트로 저장이 되어 실행시킬 수 가 있다.\n#!/bin/bash # Build the project. hugo -t \u0026lt;테마이름\u0026gt; # github.io 레포 push위해 파일 경로 이동 cd public # 충돌 방지를 위해 한번 pull git pull origin master # git내용들 추가 git add . # Commit 바꾸기. git commit -m \u0026#34;원하는 커밋 메세지\u0026#34;를 입력하거나 # git commit만 입력시 커밋날짜를 메세지로 자동설정 msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # github.io 레포에 push git push origin master # 상위 폴더인 blog도 push위해 경로 변경 cd .. # blog 저장소 Commit \u0026amp; Push # 충돌 방지를 위해 한번 pull git pull origin master git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin master 이제부터는 custom하는 내용으로 skip해도 무방하다. 9. custom domain 연결하기 github page를 이용해도 username.github.io가 아닌 개인의 도메인을 연결하여 사용할 수 있다.\n나는 가비아를 통해 도메인을 구매했기 때문에 가비아 기준으로 설명한다.\n1) My 가비아에 들어가 도메인 관리를 클릭 후 DNS 정보의 도메인 연결의 설정을 클릭. 나는 지금 설정을 해놓은 상태라 이렇게 추가가 되어 있는 데 레코드 수정을 통해 사진과 같이 추가해주면 된다.\nTTL은 600!\n2) 설정 후 본인의 username.github.io repo 에 돌아와 Settings를 클릭한다. 스크롤을 내리다 보면 Github pages 항목에 custom domain에 자기의 domain을 입력해 주고 Save를 클릭해주면 된다.\n도메인이 적용되는 데 몇분의 시간이 소요 될 수 있고 Enforce HTTPS를 활성화 시켜주면 github 자체에서 Let\u0026rsquo;s Encrypt를 이용한 https를 무료로 적용 시켜 준다.\n그리고 마지막으로 blog 폴더 내 config.toml파일의 baseURL을 내 도메인으로 바꿔주면 된다.\n10. 댓글 기능 추가하기 github page는 정적 사이트 호스팅이다보니 자체적으로 댓글 기능을 제공하지는 않기 때문에 외부의 라이브러리를 사용해 추가를 해줄 수 있다.\n유명한 라이브러리로 disqus가 있는 데 나는 disqus의 인터페이스가 이쁘지 않아서 다양한 댓글 라이브러리들 에서 찾다보니 utterances가 제일 마음에 들어 이걸 사용하기로 했다.\nutterances 공식 문서 를 참고하면 theme도 설정가능하고 label도 설정가능 한데, 잘 모르겠다 싶으면 아래의 코드를 따라 해도 무방하다. (reop 경로는 바꿔주어야 한다.)\n내가 선택한 테마는 github-light로 밝은 분위기가 깔끔해 선택했다.\n댓글의 기능을 mapping 해줄 repo를 하나 생성 해준다. 나는 comments라는 repo를 생성했다. 그 후 본인의 theme 폴더 내의 layouts/partials 안의 contents의 내용을 포함하는 body-contents 역할의 html파일을 찾아 blog/layouts/partials에 복사해와서 편집기를 통해 연다. 코드가 길게 있을 텐데 contents 끝 자락 부분의 아래나 footer 바로 윗 부분에 코드를 추가 해주면 된다. \u0026lt;div style=\u0026#34;margin-top:200px;\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;gowoonsori/comments\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async \u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 이때 repo의 username과 repo이름은 바꿔줘야 한다!\n누군가 댓글을 달면 해당 url 인덱스의 이름으로 연결시켜준 repo에 issue가 생기고 이 issue의 댓글을 보여주는 방식으로 작동한다.\nNote\n테마별로 구조와 파일명이 조금씩 다를 수 있어 이도 공식 문서를 잘 참조하자.\n나는 공식문서에 이는 나와있지 않아 partials폴더 내에 contents를 담당할 것 같은 파일(.html)을 찾아 연뒤 hugo server명령어를 실행 시켜놓고 하나하나 붙여 넣어보며 적당한 위치를 찾았다. \u0026lt;div\u0026gt;로 \u0026lt;script\u0026gt; 를 한번 씌워 margin-top을 준것도 contents 바로 아래에 붙이니 contets들과 너무 붙어 있어 띄어 배치 시켰다.\nfooter의 윗부분에 배치시키거나 저 공간이 싫다하면 div를 제외하고 scirpt부분만 붙여넣으면 된다.\nHugo 후기 한글 레퍼런스가 많이 없어 삽질을 많이 하긴 했지만 덕분에 hugo의 전체적인 파일 구조를 파악할 수 있어 손쉽게 내 입맛에 맞게 커스터 마이징을 할 수 있을 것 같다.\nhugo를 처음 사용하시는 분들께 강조 하고 싶은 것은 본인이 선택한 테마의 문서 (설명서)를 잘 보자는 것이다.\n"},{"section":"Blog","slug":"/blog/algorithms/sorting-algorithm/","title":"Sorting Algorithm","description":"정렬 알고리즘들을 정리하여 한페이지로 보기 쉽게 포스팅 합니다","date":"2020년 9월 20일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Algorithm","tags":"Sort","content":"1. 종류 선택 정렬 ( Selection Sort ) 삽입 정렬 ( Insertion Sort ) 버블 정렬 ( Bubble Sort ) 셸 정렬 ( Shell Sort ) 퀵 정렬 ( Quick Sort ) 힙 정렬 ( Heap Sort ) 합병 정렬 ( Merge Sort ) 기수 정렬 ( Radix Sort ) 계수(카운트) 정렬 ( Count Sort ) 트리 정렬 큐브 정렬 팀 정렬 2. 시간 복잡도 ( Big-O ) 알고리즘 최선 평균 최악 선택 정렬 Ω(n^2) Θ(n^2) O(n^2) 버블 정렬 Ω(n) Θ(n^2) O(n^2) 삽입 정렬 Ω(n) Θ(n^2) O(n^2) 트리 정렬 Ω(nlogn) Θ(nlogn) O(n^2) 퀵 정렬 Ω(nlogn) Θ(nlogn) O(n^2) 셸 정렬 Ω(n) Θ(n^1.5) O(n^1.5) 힙 정렬 Ω(nlogn) Θ(nlogn) O(nlogn) 합병 정렬 Ω(nlogn) Θ(nlogn) O(nlogn) 큐브 정렬 Ω(n) Θ(nlogn) O(nlogn) 팀 정렬 Ω(n) Θ(nlogn) O(nlogn) 기수 정렬 Ω(nk) Θ(nk) O(nk) 계수 정렬 Ω(n+k) Θ(n+k) O(n+k) 3. 공간 복잡도 ( Big-O ) 알고리즘 최악 선택 정렬 O(1) 버블 정렬 O(1) 삽입 정렬 O(1) 셸 정렬 O(1) 힙 정렬 O(1) 퀵 정렬 O(logn) 합병 정렬 O(n) 큐브 정렬 O(n) 트리 정렬 O(n) 팀 정렬 O(n) 계수 정렬 O(k) 기수 정렬 O(n+k) 4. 정렬의 특성 1) 안정 정렬( stable sort ) 정렬되지 않은 상태의 같은 키값을 가진 원소의 순서가 정렬 후에도 유지 되는 정렬 상황에 따라서 객체나 키값이 여러개인 값들을 정렬 하려고 할때 원래의 순서가 바뀌게 되면 안될 수 있기 때문에 그때는 stable한 sort를 이용해야 한다. Bubble, Insertion, Merge, Counting, Bucket, Radix Sort가 해당된다. Note\n예를 들어, 같은 5이더라도 a가 앞에 있는 5, b가 뒤에 있는 5라고 한다면 3 5(a) 1 4 5(b) 2 이 정렬 후에\n1 2 3 4 5(a) 5(b) 와 같이 같은 키값의 원소의 순서가 유지 되는 것.\n2) 불안정 정렬 ( unstable sort ) 정렬되지 않은 상태의 같은 키값을 가진 원소의 순서가 정렬 후에 유지되는 것을 보장 할 수 없는 정렬 Selection, Shell, Heap, Quick Sort가 해당된다. Note\n예를 들어, 같은 5이더라도 a가 앞에 있는 5, b가 뒤에 있는 5라고 한다면 3 5(a) 1 4 5(b) 2 이 정렬 후에\n1 2 3 4 5(b) 5(a) 와 같이 같은 키값의 원소의 순서가 유지 되지 않는 것.\n5. Selection Sort Unstable sort 추가 메모리 생성할 필요 X 배열 쭉 탐색 후 가장 작은 값 왼쪽부터 차곡차곡 쌓는 방식 코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 //배열의 item을 random으로 삽입 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%100; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(3); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } //선택 정렬 void Selection_sort(int *array,int arrlen){ int min; /*배열을 순차 탐색하며 제일 최솟값을 왼쪽부터 정렬*/ for(int i=0; i\u0026lt;arrlen-1;i++){ min=i; for(int j=i+1;j\u0026lt;arrlen;j++) //최솟값이 들어있는 인덱스 search if(array[j]\u0026lt;array[min]) min=j; swap( array[i], array[min] ); //가장 작은값을 왼쪽으로 이동 } } int main(){ int array[64]; int arr_sz= sizeof(array)/sizeof(int); input_random(array,arr_sz); //배열에 랜덤값 삽입 start = clock(); Selection_sort(array,arr_sz); //선택 정렬 finish = clock(); display(array,arr_sz); //show array CalcTime(); return 0; } 6. Insertion Sort stable sort 추가 메모리 생성할 필요 X 인덱스값을 한개씩 늘려가며 해당 값이 맞는 위치에 삽입 상황에 따라 모두 비교하지 않으므로 best case 경우 O(n)으로 빠른 시간을 갖는다. 코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 //배열의 item을 random으로 삽입 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%100; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(3); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } void Insertion_sort(int *array,int arrlen){ int j,item; for(int i=1;i\u0026lt;arrlen;i++){ item=array[i]; /*배열의 첫번째 가 아니고, 앞의 값보다 작다면 교체*/ for(j=i-1;j\u0026gt;=0 \u0026amp;\u0026amp; item \u0026lt; array[j] ;j--) array[j+1]=array[j]; array[j+1]=item; } } int main(){ int array[64]; int arr_sz= sizeof(array)/sizeof(int); input_random(array,arr_sz); //배열에 랜덤값 삽입 start = clock(); Insertion_sort(array,arr_sz); //삽입 정렬 finish = clock(); display(array,arr_sz); //show array CalcTime(); return 0; } 7. Bubble Sort stable sort 추가 메모리 생성할 필요 X 배열을 모두 탐색하며 가장 큰 값을 오른쪽부터 쌓는다. 코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 //배열의 item을 random으로 삽입 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%100; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(3); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } void Bubble_sort(int *array,int arrlen){ /*한번 탐색할때마다 배열의 끝에 제일 큰 값이 채워지므로 배열의 길이-1만큼 반복문이 돈다*/ for(int i=arrlen-1;i\u0026gt;0;i--){ /*배열의 첫번째부터 다음 값과 비교해보면서 큰 값은 점점 뒤로 민다*/ for(int j=0;j\u0026lt;i;j++) if(array[j]\u0026gt;array[j+1]) swap(array[j],array[j+1]); } } int main(){ int array[64]; int arr_sz= sizeof(array)/sizeof(int); input_random(array,arr_sz); //배열에 랜덤값 삽입 start = clock(); Bubble_sort(array,arr_sz); //버블 정렬 finish = clock(); display(array,arr_sz); //show array CalcTime(); return 0; } 8. Merge Sort stable sort 분할과 정복 원리 ( Divide \u0026amp; Conquer ) 더이상 나누어지지 않을 때까지 반으로 분할하다가 더이상 나누어지지 않은경우, 원소(value)를 결합(combine)할 때,양쪽의 value를 비교 후 정렬방식대로 combine을 실행 재귀를 이용 ( recursion ) 추가 메모리가 필요 코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; int sorted[64]; clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 //배열의 item을 random으로 삽입 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%100; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(2); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } void Merge(int array[],int left,int mid,int right){ int l; int i=left; int j=mid+1; int k=left; /*왼쪽 배열과 오른쪽 배열 비교하며 sorted배열에 삽입*/ while(i\u0026lt;= mid \u0026amp;\u0026amp; j\u0026lt;=right){ if(array[i]\u0026lt;=array[j]) sorted[k++]=array[i++]; else sorted[k++]=array[j++]; } /*한쪽먼저 다 sorted에 삽입되어 남아있는 배열 값 모두 삽입*/ if(i\u0026gt;mid){ for(l=j;l\u0026lt;=right;l++) sorted[k++]=array[l]; } else{ for(l=i; l\u0026lt;=mid; l++) sorted[k++]=array[l]; } /*배열 복사*/ for(l=left; l\u0026lt;=right; l++){ array[l]=sorted[l]; } } void Merge_sort(int array[],int left, int right){ int mid; if(left\u0026lt;right){ mid = (left+right) /2; Merge_sort(array,left,mid); Merge_sort(array,mid+1,right); Merge(array,left,mid,right); } } int main(){ int array[1]; int arr_sz= sizeof(array)/sizeof(int); input_random(array,arr_sz); //배열에 랜덤값 삽입 start = clock(); Merge_sort(array,0,arr_sz-1); //합병 정렬 finish = clock(); display(array,arr_sz); //show array CalcTime(); return 0; } 9. Quick Sort Unstable sort 분할과 정복 이용 ( Divide \u0026amp; Conquer ) 분할시 기준 값 (pivot) 을 설정 후 해당 pivot을 기준으로 좌, 우로 작은, 큰 값을 배치 시킨 후 pivot보다 작은 숫자들, 큰 숫자들의 집합을 다시 재귀 함수를 이용하여 분할 정렬을 하는 방식 pivot은 기준점으로 중간값이기 때문에 재귀에 포함시키지 않는다. pivot을 계속 가장 작은 값 or 가장 큰 값을 설정시 worst case로 O(n^2)이 된다. 따라서 pivot을 어떻게 잡아서 partitioning할지가 중요 balanced partitioning : 좌우가 동일한 사이즈로 나누어지도록 pivot을 설정한 경우 =\u0026gt; 가장 좋은 경우 코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%100; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(3); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } void QuickSort(int array[],int pivot, int arrlen){ int left = pivot+1, right = arrlen-1; if(pivot\u0026gt;=arrlen-1) return; while(left\u0026lt;=right){ while(left \u0026lt;= arrlen-1 \u0026amp;\u0026amp; array[left]\u0026lt;=array[pivot])left++; //피벗보다 큰 값 왼쪽부터 찾기 while(right \u0026gt; pivot \u0026amp;\u0026amp; array[right]\u0026gt;=array[pivot])right--; //피벗보다 작은 값 오른쪽부터 찾기 if(left\u0026lt;right) swap(array[left],array[right]); else swap(array[pivot],array[right]); } QuickSort(array,pivot,right); QuickSort(array,right+1,arrlen); } int main(){ int array[64]; int arr_sz= sizeof(array)/sizeof(int); input_random(array,arr_sz); //배열에 랜덤값 삽입 start = clock(); QuickSort(array,0,arr_sz); //버블 정렬 finish = clock(); display(array,arr_sz); //show array CalcTime(); return 0; } 10. Shell Sort Unstable sort 삽입정렬을 보완한 알고리즘 ( 어느정도 정렬된 배열에서 속도가 빠른 것에서 착안 ) 삽입정렬은 삽입할 때, 이웃한 위치로만 이동이 가능하다는 단점 존재 -\u0026gt; 이를 보완하여 셀 정렬은 멀리 떨어진 곳을 삽입정렬을 이용하여 정렬 삽입정렬과 다르게 한 번에 정렬하지 않는다. 간격을 설정 하여 k번째 요소들을 추출하여 해당 숫자들을 삽입정렬로 정렬 후, k를 절반으로 줄여 1이 될 때까지 반복 간격(gap) : 초깃값 = 정렬할 값의 수/2 생성된 부분 리스트의 개수는 gap과 같다. 코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 //배열의 item을 random으로 삽입 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%100; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(3); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } /*기본은 삽입정렬 알고리즘 gap차이만큼의 숫자들을 삽입정렬로 정렬*/ void insertionSort(int *array,int first,int last,int gap){ int item,j; for(int i=first+gap; i\u0026lt;last ; i+=gap ){ item=array[i]; /*배열의 제일 왼쪽이거나 앞의 값이 해당 값보다 작다면 배열을 한 칸씩 뒤로 미룸*/ for(j=i-gap; j\u0026gt;=first \u0026amp;\u0026amp; array[j]\u0026gt;item; j-=gap) array[j+gap]=array[j]; array[j+gap]=item; } } void Shell_sort(int *array,int arrlen){ int gap; for( gap = arrlen/2 ; gap\u0026gt;0; gap/=2){ if(gap%2 == 0) gap++; //gap이 짝수라면 홀수로 맞추는 것이 더 좋은 것으로 분석이 됨 for(int i=0;i\u0026lt;gap;i++){ insertionSort(array,i,arrlen,gap); } } } int main(){ int array[64]; int arr_sz= sizeof(array)/sizeof(int); input_random(array,arr_sz); //배열에 랜덤값 삽입 start = clock(); Shell_sort(array,arr_sz); //삽입 정렬 finish = clock(); display(array,arr_sz); //show array CalcTime(); return 0; } 11. Heap Sort Unstable sort Heap 자료구조 ( Complete Binary Tree 의 일종 )을 이용한 정렬 방법 배열을 heapify( heap으로 만들어 주는 것 ) 을 거쳐서 value를 꺼내는 방식의 정렬 추가 메모리 생성이 필요 없다. 오름차순 정렬을 위해 최대 힙을 구성하고, 내림차순 정렬을 위해 최소 힙을 구성 코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; #define MAX_ARRAY_SIZE 64 int maxValue=0; //가장 큰 값을 담을 변수 clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 //배열의 item을 random으로 삽입 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%99 + 1; maxValue = (maxValue \u0026lt; array[i]) ? array[i] : maxValue; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(3); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } /*top-down*/ void top_down_heapify(int* array,int arrlen){ /*인덱스 0을 루트(부모 노드)로 삼고 인덱스 1(왼쪽 자식)부터 maxHeap형태로 *만들어 주기 위해 swap */ for(int i=1; i \u0026lt; arrlen ; i++){ int child = i; while(child \u0026gt; 0){ int parent = (child -1) /2; if(array[parent] \u0026lt; array[child]){ swap(array[parent],array[child]); } child = parent; } } } /*bottom-up*/ void bottom_up_heapify(int* array,int parent,int arrlen){ /*인덱스 0을 루트(부모 노드)로 삼고 인덱스 1(왼쪽 자식)부터 maxHeap형태로 *만들어 주기 위해 swap */ while(parent \u0026lt;= arrlen){ int largest = parent; int l = parent * 2 + 1; int r = parent * 2 + 2; if(l \u0026lt; arrlen \u0026amp;\u0026amp; array[largest] \u0026lt; array[l]){ largest = l; } if(r \u0026lt; arrlen \u0026amp;\u0026amp; array[largest] \u0026lt; array[r]){ largest = r; } /*largest가 값이 바뀌었다면 swap해야한다는 뜻 swap했다면 child로 내려가 아래 서브트리도 확인하기 위해 parent값 largest로 변환 */ if(largest != parent) { swap(array[parent],array[largest]); parent = largest; } else parent = l; } } void top_down_HeapSort(int *array, int arrlen){ top_down_heapify(array,arrlen); //maxHeap형태로 만들어준다. for(int i= arrlen-1 ; i\u0026gt;=0; i--){ swap(array[i],array[0]); //가장 큰 숫자(루트)를 맨 뒷 노드로 swap해준다. top_down_heapify(array,i); //swap한 마지막 노드를 제외하고 heapify를 해준다. } //결과적으로 큰 숫자들이 뒤에 오게 되며 오름차순으로 정렬이 된다. } void bottom_up_HeapSort(int *array, int arrlen){ /*build max-heap 루트 노드가 0 기준 ) n개의 노드를 가진 트리라면, 마지막 노드 n의 부모 인덱스 번호는 n/2 -1 이다. 루트 노드가 1 기준 ) n개의 노드를 가진 트리라면, 마지막 노드 n의 부모 인덱스 번호는 n/2 이다. leafnode들은 더이상 heapify를 안해줘도 되기 때문에 마지막 노드의 부모 노드 부터 heapify를 시작 --\u0026gt; heap sort의 초반 build heap부분에서 bottom-up방식은 n/2개만 큼만 수행하므로 top-down방식보다 bottom-up 방식이 조금 더 성능이 좋다. */ for(int i= arrlen / 2 - 1; i \u0026gt;= 0; i--){ bottom_up_heapify(array,i,arrlen); } for(int i = arrlen-1; i \u0026gt;= 0; i--){ swap(array[i],array[0]); //가장 큰 숫자(루트)를 맨 뒷 노드로 swap해준다. bottom_up_heapify(array,0,i); //swap한 마지막 노드를 제외하고 heapify를 해준다. } } int main(){ int *array = new int[MAX_ARRAY_SIZE]; input_random(array,MAX_ARRAY_SIZE); //배열에 랜덤값 삽입 start = clock(); bottom_up_HeapSort(array,MAX_ARRAY_SIZE); //계수 정렬 finish = clock(); display(array,MAX_ARRAY_SIZE); //show array CalcTime(); return 0; } 12. Radix Sort stable sort Non-Comparisions Sorting Algorithm ( 비교하지 않는 정렬 알고리즘 ) 기수 (Radix) : 데이터를 구성하는 기본요소 하나의 기수마다 버킷 (데이터 공간)을 생성하여 분류하여 버킷안에서 다시 정렬하는 방식 정렬 방식 LSD ( Least Significant Digit ) : 덜 중요한 기수부터 정렬 예를들어서 일의 자리수자부터 정렬하는 방식이다. 따라서 중간에 정렬 결과를 확인할 수 없다. MSD ( Most Significant Digit ): 가장 중요한 기수부터 정렬 예를들어서 백의 자리숫자부터 정렬하는 방식이다. 따라서 중간에 정렬 결과를 확인 할 수있으나 확인하는 과정에서 메모리를 더 사용하게 된다. 코드 보기 #include \u0026lt;iostream\u0026gt; #include\u0026lt;queue\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;time.h\u0026gt; //시간 측정 std::queue\u0026lt;int\u0026gt; q[10]; //10진수 정수형을 정렬하기 때문에 0-9의 버킷 int MAXVALUE=0; //정렬할 수 중 가장 큰 수 clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%1000; if(MAXVALUE\u0026lt;array[i]) MAXVALUE=array[i]; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ std::cout.width(3); std::cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; std::cout.width(2); std::cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; std::endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } void RadixSort(int *array,int arrlen){ int digit=1; int k; /*가장 큰 값의 자릿수 알아내기*/ while(digit\u0026lt;MAXVALUE) digit*=10; /*가장 큰 값의 자릿수 만큼 만큼 반복*/ for(int i=1; i\u0026lt;digit ; i*=10){ /*queue에 옮기기*/ for(int j=0;j\u0026lt;arrlen;j++){ k=(array[j]/i)%10; q[k].push(array[j]); } /*array에 옮기기*/ int idx=0; for(int j=0;j\u0026lt;10;j++){ while(!q[j].empty()){ array[idx]=q[j].front(); q[j].pop(); idx++; } } } } int main(){ int array[64]; int arr_sz= sizeof(array)/sizeof(int); input_random(array,arr_sz); //배열에 랜덤값 삽입 start = clock(); RadixSort(array,arr_sz); finish = clock(); display(array,arr_sz); //show array CalcTime(); return 0; } 13. Count Sort stable sort -Non-Comparisions Sorting Algorithm( 비교하지 않는 정렬 알고리즘 ) 좁은 범위의 데이터를 정렬할 때 유용 ( ex. Score ) 법위가 넓어지게 되면 추가 메모리 공간이 많이 필요해지기 때문에 비효율 정렬을 위해 추가 배열을 생성하는데 사이즈를 정렬할 배열의 가장 큰 값만큼 생성 과정 정렬할 배열 A, 추가 배열 C를 생성 배열 C는 모든 값을 0으로 초기화 배열 A의 값을 토대로 배열 C의 인덱스값을 참조하여 값을 1씩 증가 (예를 들어 배열 A의 값중 3이 있다고 한다면, C의 3번째 인덱스 값을 1 증가) 배열 c의 각 값들을 직전 값을 더해 업데이트 (예를 들어, 배열 C가 1,0,2,2 였다면, 1,1,3,5로 업데이트) 배열 C는 배열 A의 값들의 인덱스 값이므로, 배열 A를 끝에서부터 역순으로 훑으면서 배열 B에 정렬 (이때, 한 값을 B에 옮겨주었다면, 해당하는 인덱스의 배열 C의 값은 1을 빼기) 코드 보기 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; //time #include \u0026lt;ctime\u0026gt; //rand, srand #include \u0026lt;string.h\u0026gt; //memset #include \u0026lt;time.h\u0026gt; //시간 측정 using namespace std; #define MAX_ARRAY_SIZE 64 int maxValue=0; clock_t start, finish, used_time=0; //실행 시간 측정을 위한 변수 //배열의 item을 random으로 삽입 void input_random(int *array,int arrlen){ srand((unsigned int)time(NULL)); for(int i=0;i\u0026lt;arrlen;i++){ array[i]=rand()%99 + 1; maxValue = (maxValue \u0026lt; array[i]) ? array[i] : maxValue; } } void display(int *array,int arrlen){ for(int i=0; i\u0026lt;arrlen;i++){ cout.width(3); cout \u0026lt;\u0026lt; i+1 \u0026lt;\u0026lt;\u0026#34;. \u0026#34;; cout.width(2); cout \u0026lt;\u0026lt; array[i] \u0026lt;\u0026lt; endl; } } //실행 시간을 측정 및 출력하는 함수 void CalcTime(void){ used_time=finish-start; printf(\u0026#34;\\n*********** result **********\\n time : %lf sec\\n\u0026#34;, (double)(used_time)/CLOCKS_PER_SEC); } int* count_sort(int *array,int arrlen){ int *c = new int[maxValue+1]; int c_size = maxValue+1; int *b = new int[arrlen]; memset(c,0,c_size*sizeof(int)); //배열c 0으로 초기화 /*각 숫자 횟수 카운틱하며 c배열 인덱스 값 증가*/ for(int i = 0; i \u0026lt; arrlen ; i++){ c[array[i]]++; } /*배열 c의 인덱스 값 누적합 구하기*/ for(int i=1; i \u0026lt; c_size; i++){ c[i] += c[i-1]; } /*배열 A역순으로 훑으며, 배열 C참조하여 정렬*/ for(int i = arrlen-1; i \u0026gt;= 0; i-- ){ b[c[array[i]]-1] = array[i]; --c[array[i]]; } return b; } int main(){ int *array = new int[MAX_ARRAY_SIZE]; input_random(array,MAX_ARRAY_SIZE); //배열에 랜덤값 삽입 delete array; start = clock(); array = count_sort(array,MAX_ARRAY_SIZE); //계수 정렬 finish = clock(); display(array,MAX_ARRAY_SIZE); //show array CalcTime(); delete array; return 0; } "},{"section":"Blog","slug":"/blog/datastructure/tree/","title":"Tree","description":"트리의 개념과 종류들을 cpp을 이용한 예제 코드와 함께 정리합니다.","date":"2020년 9월 20일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Data Structure","tags":"Tree","content":"그래프의 일종으로, 여러 노드가 한개의 노드를 가리킬 수 없는 구조\n선형구조가 아닌 (비선형), 부모자식의 관계를 가지는 계층형 구조\n1. 용어 개념 (설명) Node (노드): 트리를 구성하고 있는 각각의 요소를 의미한다. Edge (= link, 간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다. Root Node (루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미한다. Sibling (형제 노드) : 같은 부모를 갖는 노드 Degree (차수) : 해당 노드의 자식노드 개수 Depth (깊이) : 루트 노드 부터 현재 노드까지의 간선의 개수 Level (레벨) : 같은 깊이를 갖는 노드들의 집합 루트 노드의 레벨을 1이 아닌 0으로 시작할 수도 있다. 편한대로 하면 된다. Height (높이) : 트리의 최대 레벨 Terminal Node (= leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다. Internal Node (내부노드, 비단말 노드) : 노드를 제외한 모든 노드로 루트 노드를 포함한다. https://gowoonsori.comimages/datastructure/tree/perfect2.png does not exist\r위의 트리로 예를 들어 설명하자면, 아래와 같이 된다.\n노드 : 10, 5, 15, 1, 7, 12, 20 루트 노드 : 10 차수 10 : 2 5,15 : 2 1,7,12,20 : 0 형제 노드 5의 형제노드 : 15 7의 형제노드 : 1 레벨 10의 레벨 : 1 5,15의 레벨 : 2 1,7,12,20의 레벨 : 3 깊이 5,15 의 깊이 : 1 1,7,12,20의 깊이 : 2 높이 해당 트리의 높이 : 3 Terminal Node (단말 노드) : 1, 7, 12, 20 Internal Node (내부노드) : 10, 5, 15 2. 종류 Binary tree (이진 트리) : 부모 노드가 자식 노드를 최대 2개씩만 갖는 트리\nTernary tree (삼항 트리) : 자식 노드를 이상 3개 갖고 있는 트리\n위와 같은 종류가 있으며, 이진 트리를 기본으로 트리에 대해 설명하고자 한다.\n1) 완전 이진 트리 (Complete binary tree) https://gowoonsori.comimages/datastructure/tree/complete.png does not exist\r위 그림과 같이 마지막 레벨을 제외한 모든 서브트리의 레벨이 같아야 하고, 마지막 레벨은 왼쪽부터 채워져 있어야 한다.\n그렇다면 아래의 트리는 완전 이진 트리일까? https://gowoonsori.comimages/datastructure/tree/not_complete.png does not exist\r정답 보기 마지막 레벨인 1,3,6 이 왼쪽부터 채워지지 않았기 때문에 완전이진 트리라고 할 수 없다.\n2) 정 이진 트리 (Full binary tree) 자식 노드가 없거나 2개인 트리\n3) 포화 이진 트리 (Perfect binary tree) 아래 그림과 같이 빈 공간이 없이 모든 노드가 2개의 자식을 갖고 있는 트리\nhttps://gowoonsori.comimages/datastructure/tree/perfect.png does not exist\r4) 이진 탐색 트리 (Binary search tree) 부모노드 보다 작은 값의 노드는 왼쪽 child, 큰 값의 노드는 오른쪽 child로 구성되어 있는 tree.\nkey값의 중복이 가능하게 구현을 할 수는 있으나 기본적인 개념은 중복을 허용하지 않는다.\n3. Tree 순회 (=탐색, Search) 방법 루트(root) 를 시작으로해서 왼쪽 자식 들렸다가 오른쪽 자식 가는 방법으로 탐색을 한다.\n이때, root( 부모 노드 )를 언제 탐색하냐에 따라서 3가지 방법으로 나뉘게 된다.\n전위 순회 : root를 제일 먼저 순회 중위 순회 : root를 중간에 순회 후위 순회 : root를 제일 나중에 순회 예를 들어, 아래와 같은 트리가 있다고 한다면 https://gowoonsori.comimages/datastructure/tree/perfect2.png does not exist\r전위 순회 : 10, 5, 1, 7, 15, 12, 20\n중위 순회 : 1, 5, 7, 10, 12, 15, 20\n후위 순회 : 1, 7, 5, 12, 20, 15, 10\n의 순서로 순회하게 된다.\n4. 이진 탐색 트리 ( Binary Search Tree ) Note\n위에 설명했듯이 BST는 key값은 중복되지 않으며, 부모의 키가 왼쪽 자식보다는 크며, 오른쪽 자식 보다는 작다.\n왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.\n탐색 연산은 O(logn) 을 갖으며, 한쪽으로 치우쳐진 편향 트리(Skewed Tree) 가 되면 worst case로 O(n) 을 갖는다.\n1) Skewed Tree 계속 key값이 커지거나 반대로 계속 작아지는 경우에 아래와 같은 모양의 Skewed Tree가 된다.\nhttps://gowoonsori.comimages/datastructure/tree/skewd.png does not exist\r2) 구현 방법 배열 트리는 일정한 규칙을 가지고 있기 때문에 배열을 이용해서도 쉽게 구현이 가능하다. - 루트노드를 배열의 인덱스 0으로 시작하는 경우 - 왼쪽 자식의 인덱스 = (부모노드의 인덱스 _ 2) + 1 - 오른쪽 자식의 인덱스 = (부모노드의 인덱스 _ 2) + 2 - 루트노드를 배열의 인덱스 1로 시작하는 경우 - 왼쪽 자식의 인덱스 = 부모노드의 인덱스 _ 2 - 오른쪽 자식의 인덱스 = (부모노드의 인덱스 _ 2) + 1\n연결 리스트 연결리스트로 구현하면 왼쪽 자식,오른쪽 자식 가리킬 포인터를 하나씩 선언해서 가리키면 된다.\n코드 보기 #include\u0026lt;iostream\u0026gt; #include\u0026lt;Windows.h\u0026gt; enum { _Preorder=1, _Inorder, _Postorder }; template\u0026lt;typename T\u0026gt; class Node { public: T key; Node* LNode; Node* RNode; Node(T key = 0, Node* LNode = NULL, Node* RNode = NULL) { this-\u0026gt;key = key; this-\u0026gt;LNode = NULL; this-\u0026gt;RNode = RNode = NULL; } }; template\u0026lt;typename T\u0026gt; class BST { private: Node\u0026lt;T\u0026gt;* root; public: BST() : root(NULL){} void add(Node\u0026lt;T\u0026gt;* node); void Delete(T item); bool search_loop(T item); void Preorder(Node\u0026lt;T\u0026gt;* target); void Inorder(Node\u0026lt;T\u0026gt;* target); void Postorder(Node\u0026lt;T\u0026gt;* target); void showTree(int element); }; template\u0026lt;typename T\u0026gt; bool BST\u0026lt;T\u0026gt;::search_loop(T item) { Node\u0026lt;T\u0026gt;* s = this-\u0026gt;root; while (s != NULL) { if (s-\u0026gt;key == item) return true; //key가 존재한다면 true else if (s-\u0026gt;key \u0026gt; item) s = s-\u0026gt;LNode; //key가 item보다 크다면 왼쪽으로 이동 else s = s-\u0026gt;RNode; //key가 item보다 작다면 오른쪽으로 이동 } return false; } template\u0026lt;typename T\u0026gt; void BST\u0026lt;T\u0026gt;::add(Node\u0026lt;T\u0026gt;* node) { T item = node-\u0026gt;key; /*트리가 비어있다면*/ if (this-\u0026gt;root == NULL) { this-\u0026gt;root = node; return; } /*값이 존재하면*/ if (search_loop(item)) { std::cout \u0026lt;\u0026lt; \u0026#34;값이 이미 존재합니다\u0026#34; \u0026lt;\u0026lt; std::endl; return; } /*item 삽입*/ Node\u0026lt;T\u0026gt;* s = this-\u0026gt;root; while (1) { /*item이 key값보다 크다면*/ if (s-\u0026gt;key \u0026lt; item) { if (s-\u0026gt;RNode == NULL) { s-\u0026gt;RNode = node; return; } s = s-\u0026gt;RNode; } else { if (s-\u0026gt;LNode == NULL) { s-\u0026gt;LNode = node; return; } s = s-\u0026gt;LNode; } } } template\u0026lt;typename T\u0026gt; void BST\u0026lt;T\u0026gt;::Delete(T item) { Node\u0026lt;T\u0026gt;* t = this-\u0026gt;root; Node\u0026lt;T\u0026gt;* parent = NULL; Node\u0026lt;T\u0026gt;* child, * succ, * succ_p; /*key값을 찾거나 없다면 break*/ while (t != NULL \u0026amp;\u0026amp; t-\u0026gt;key != item) { parent = t; t = (item \u0026lt; parent-\u0026gt;key) ? parent-\u0026gt;LNode : parent-\u0026gt;RNode; } /*-----탐색 종료------*/ /*값이 없다면*/ if (t == NULL) { std::cout \u0026lt;\u0026lt; \u0026#34;해당 값이 존재 하지 않습니다.\u0026#34; \u0026lt;\u0026lt; std::endl; return; } /*자식노드가 없다면*/ if (t-\u0026gt;RNode == NULL \u0026amp;\u0026amp; t-\u0026gt;LNode == NULL) { if (parent != NULL) { /*부모노드의 왼쪽에 있다면*/ if (parent-\u0026gt;LNode == t) parent-\u0026gt;LNode = NULL; else parent-\u0026gt;RNode = NULL; delete(t); } else { delete(t); this-\u0026gt;root = NULL; } } /*1개의 자식이 있다면 */ else if (t-\u0026gt;RNode == NULL || t-\u0026gt;LNode == NULL) { child = (t-\u0026gt;LNode == NULL) ? t-\u0026gt;RNode : t-\u0026gt;LNode; if (parent != NULL) { if (parent-\u0026gt;LNode == t) parent-\u0026gt;LNode = child; else parent-\u0026gt;RNode = child; delete(t); } /*삭제할 노드가 root라면*/ else { delete(t); this-\u0026gt;root = child; } } /*2개의 자식이 있다면 오른쪽 child의 가장 작은 값을 attach*/ else { succ_p = t; succ = t-\u0026gt;RNode; /*오른쪽 child의 가장 작은 값 찾기*/ /*succ_p == 가장 작은 값의 부모 노드*/ /*succ 는 가장 작은 값의 노드*/ while (succ-\u0026gt;LNode != NULL) { succ_p = succ; succ = succ-\u0026gt;LNode; } /*삭제하려는 노드의 오른쪽 child의 leftnode가 있다면 succ_p leftnode의 rightnode를 succ_p의 왼쪽에 연결*/ if (succ_p-\u0026gt;LNode == succ) { succ_p-\u0026gt;LNode = succ-\u0026gt;RNode; } /*삭제하려는 노드의 오른쪽child의 left node가 없다면 오른쪽 child의 right node를 삭제할 노드의 오른쪽에 연결*/ else succ_p-\u0026gt;RNode = succ-\u0026gt;RNode; /*삭제할 노드와 교환 후 삭제*/ t-\u0026gt;key = succ-\u0026gt;key; t = succ; delete(t); } return; } //전위 순회 template\u0026lt;typename T\u0026gt; void BST\u0026lt;T\u0026gt;::Preorder(Node\u0026lt;T\u0026gt;* target) { if (target == NULL)return; std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; this-\u0026gt;Preorder(target-\u0026gt;LNode); this-\u0026gt;Preorder(target-\u0026gt;RNode); } //중위 순회 template\u0026lt;typename T\u0026gt; void BST\u0026lt;T\u0026gt;::Inorder(Node\u0026lt;T\u0026gt;* target) { if (target == NULL)return; this-\u0026gt;Inorder(target-\u0026gt;LNode); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; this-\u0026gt;Inorder(target-\u0026gt;RNode); } //후위 순회 template\u0026lt;typename T\u0026gt; void BST\u0026lt;T\u0026gt;::Postorder(Node\u0026lt;T\u0026gt;* target) { if (target == NULL)return; this-\u0026gt;Postorder(target-\u0026gt;LNode); this-\u0026gt;Postorder(target-\u0026gt;RNode); std::cout \u0026lt;\u0026lt; target-\u0026gt;key \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } template\u0026lt;typename T\u0026gt; void BST\u0026lt;T\u0026gt;::showTree(int element) { switch (element) { case _Preorder: this-\u0026gt;Preorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case _Inorder: this-\u0026gt;Inorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; case _Postorder: this-\u0026gt;Postorder(this-\u0026gt;root); std::cout \u0026lt;\u0026lt; std::endl; break; default: break; } } int main() { BST\u0026lt;int\u0026gt; tree; tree.add(new Node\u0026lt;int\u0026gt;(35)); tree.add(new Node\u0026lt;int\u0026gt;(18)); tree.add(new Node\u0026lt;int\u0026gt;(68)); tree.add(new Node\u0026lt;int\u0026gt;(99)); tree.add(new Node\u0026lt;int\u0026gt;(26)); tree.add(new Node\u0026lt;int\u0026gt;(7)); tree.add(new Node\u0026lt;int\u0026gt;(12)); tree.add(new Node\u0026lt;int\u0026gt;(3)); tree.add(new Node\u0026lt;int\u0026gt;(30)); tree.add(new Node\u0026lt;int\u0026gt;(22)); tree.showTree(1); tree.showTree(2); tree.showTree(3); tree.Delete(18); tree.showTree(1); return 0; } 5. Tree의 단점 위에 설명했던 skewed Tree형태가 된다면, 배열보다 많은 메모리를 사용했지만 시간복잡도가 같게되는 비효율적인 상황이 발생하기도 한다.\n해결 방법 ➡ Rebalancing 기법 사용\n"},{"section":"Blog","slug":"/blog/etc/start-blog/","title":"블로그 첫 시작 👋","description":"블로그를 시작하게 된 이유와 다짐","date":"2020년 9월 18일","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"184\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/image-placeholder_huf5f2d24635a285cfc2259aa9741acb2a_4881_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"기타","tags":"","content":"우선, 나는 말수가 적은 편이다. 말을 적게한다고 생각을 안하는 것이 아니라 머리속에서 생각은 정말 많으나, 그것을 입밖으로 꺼낼때 정리가 되지 않아 버벅거리기도 하고, 조사를 잘못 선택하여 말을 하거나 말을 하는 도중에 머리속이 꼬여 중간에 말을 멈추기도 한다.\n말은 생각을 언어로 바꾼 것이기 때문에 많은 생각들을 정리하는 연습과 맞춤법, 올바른 조사사용 등 올바른 언어 습관을 글쓰기를 통해 얻고자 글쓰기를 시작하기로 했다.\n현재 나는 개발자 더 나아가 엔지니어로 불리고 싶은 학생이다.\n배운 기술지식들이 많은데 이를 언제든 찾아 볼 수 있게 하고 다른 사람들과 지식공유를 하기 위함이다.\n나만 이해한 것이 아닌 남들도 이해하기 쉽게 작성해야 한다는 생각에 주제에 대해서 더 많이 찾아보고 공부 할 수 있게 되지 않을까?\ngithub page를 선택한 이유 블로그를 작성하는 방법으로는 플랫폼으로는 네이버 블로그, tstory, velog 등 여러가지가 있다.\n기술 블로그로 유명한 tstory, wordpress등 이 있는 데 나는 velog를 조금 사용해보다가 커스터마이징이 가능한 나만의 블로그를 갖고 싶다는 생각에 github page를 선택했다.\n( 처음 세팅하는 데 각종 오류들로 많은 시간을 소비한 것은 안 비밀 \u0026hellip;ㅎㅎ)\n글 주제 기술 블로그인만큼 Computer Science 지식이 주로 작성을 할 생각이다.\n현재 github에 my-tech라는 이름의 repo로 TIL (Today I Learn)을 진행하고 있는 데 레포에 작성한 내용을 더 다듬어서 블로그에 업로드 할 것 이다.\nTIL을 했던 경험, project를 진행하고 겪었던 일들과 쉬는 날 놀러갔다온 일상적인 얘기도 조금씩 업로드 할 수 도 있다.\n목표 적어도 한 달에 3개의 글을 작성하는 것이 목표입니다. 🙏\n"}]